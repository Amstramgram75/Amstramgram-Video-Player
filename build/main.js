/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/css/amstramgramVideoPlayer.scss":
/*!*********************************************!*\
  !*** ./app/css/amstramgramVideoPlayer.scss ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAvY3NzL2Ftc3RyYW1ncmFtVmlkZW9QbGF5ZXIuc2Nzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9EOlxcTGF1cmVudFxcRG9jdW1lbnRzXFxIdG1sXFxhbXN0cmFtZ3JhbVZpZGVvUGxheWVyXFxhcHBcXGNzc1xcYW1zdHJhbWdyYW1WaWRlb1BsYXllci5zY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/css/amstramgramVideoPlayer.scss\n");

/***/ }),

/***/ "./app/js/amstramgramVideoPlayer.js":
/*!******************************************!*\
  !*** ./app/js/amstramgramVideoPlayer.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AmstramgramVideoPlayer; });\n/* harmony import */ var _css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/amstramgramVideoPlayer.scss */ \"./app/css/amstramgramVideoPlayer.scss\");\n/* harmony import */ var _css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n/*TODO :\r\n  Menu contextuel\r\n  Tuto thumnails\r\n  Test paramètres\r\n*/\r\n\r\n/*  \r\n  AmstramgramVideoPlayer.players : tableau des players\r\n  AmstramgramVideoPlayer.currentPlayer : player en cours de lecture\r\n  AmstramgramVideoPlayer.currentFullScreenPlayer : player en mode plein écran\r\n  AmstramgramVideoPlayer.defaultOptions :\r\n    PROPRIÉTÉS PROPRES À LA SOURCE\r\n    - autoplay : si true, l'attribut autoplay est posé sur le tag <video>.\r\n      À noter que la lecture automatique sera bloquée si le volume n'est pas nul.\r\n      Défaut : false.\r\n    - crossorigin : attribut posé sur le tag <video>.\r\n      Défaut : false.\r\n    - download : propriétés du bouton Download.\r\n        - label :     texte affecté au titre du bouton et à son attribut aria-label\r\n                      Défaut : \"Télécharger\".\r\n        - disabled :  si true, le bouton porte l'attribut disabled et demeure donc inactif.\r\n                      Défaut : false.         \r\n        - hidden :    si true, la propriété display du bouton est passée en 'hidden' et le bouton est donc invisible.\r\n                      Défaut : false.         \r\n      Défaut : {label:'Télécharger', disabled:false, hidden:false}.\r\n    - duration :  durée de la vidéo exprimée en seconde.\r\n      Ce paramètre est mis à jour sur les événement loadedmetadata et durationchange de la vidéo.\r\n      Défaut : 120.\r\n    - format : format de la vidéo exprimée sous la forme d'un rapport (16/9, 4/3, etc.) ou d'un nombre.\r\n      Défaut : 16/9.\r\n    - fullscreen : propriétés du bouton Fullscreen.\r\n        - label : \r\n          - enter : texte affecté au titre du bouton et à son attribut aria-label en mode normal\r\n                    Défaut : \"Plein écran\".\r\n          - exit :  texte affecté au titre du bouton et à son attribut aria-label en mode plein écran\r\n                    Défaut : \"Quitter le plein écran\".\r\n        - disabled :  si true, le bouton porte l'attribut disabled et demeure donc inactif.\r\n                      Défaut : false.         \r\n        - hidden :    si true, la propriété display du bouton est passée en 'hidden' et le bouton est donc invisible.\r\n                      Défaut : false.         \r\n      Défaut :{label:{enter:'Plein écran', exit:'Quitter le plein écran'}, disabled:false, hidden:false}.\r\n    - loop : si true, l'attribut loop est posé sur le tag <video>.\r\n      Défaut : false.\r\n    - next : propriétés du bouton Next.\r\n        - label :     texte affecté au titre du bouton et à son attribut aria-label.\r\n                      Défaut : \"Suivant\".\r\n        - disabled :  si true, le bouton porte l'attribut disabled et demeure donc inactif.\r\n                      Défaut : true.         \r\n        - hidden :    si true, la propriété display du bouton est passée en 'hidden' et le bouton est donc invisible.\r\n                      Défaut : true.         \r\n      Défaut : {label:'Suivant', disabled:true, hidden:true},\r\n    - playsinline : si true, les attributs playsinline et webkit-playsinline sont posés sur le tag <video>.\r\n      Défaut : true.\r\n    - poster : source de l'image à afficher en poster.\r\n      Défaut : undefined.\r\n    - preload : attribut posé sur le tag <video>.\r\n      Défaut : 'none'.\r\n    - previous : propriétés du bouton Previous.\r\n        - label :     texte affecté au titre du bouton et à son attribut aria-label.\r\n                      Défaut : \"Précédent\".\r\n        - disabled :  si true, le bouton porte l'attribut disabled et demeure donc inactif.\r\n                      Défaut : true.         \r\n        - hidden :    si true, la propriété display du bouton est passée en 'hidden' et le bouton est donc invisible.\r\n                      Défaut : true.         \r\n      Défaut : {label:'Précédent', disabled:true, hidden:true}.\r\n    - skipTime: valeur attribuée au saut temporel réalisée par les flèches gauche et droite du clavier.\r\n      Elle s'exprime en secondes ou en pourcentage. Dans ce cas, la valeur résultante correspond à ce pourcentage appliqué à la durée du média.\r\n      Défaut : '1%'.\r\n    - thumbnails: Propriétés des vignettes.\r\n        - src :     source de l'image.\r\n                    L'image doit être constituée d'une seule bande de vignettes.\r\n                    Défaut : undefined.\r\n        - number :  nombre de vignettes.\r\n                    Ce nombre permet de déterminer la largeur d'une vignette = largeur de l'image / nombre de vignettes.\r\n                    Défaut : 100.\r\n      Défaut : {src:undefined, number:100}.\r\n    - volume :  volume à appliquer au média.\r\n                Doit être un nombre compris entre 0 et 1.\r\n      Défaut : 0.8.\r\n    - volumeButton : propriétés du bouton Volume.\r\n        - label : \r\n          - mute :  texte affecté au titre du bouton et à son attribut aria-label si le volume est supérieur à 0.\r\n                    Défaut : \"Désactiver le son\".\r\n          - exit :  texte affecté au titre du bouton et à son attribut aria-label si le volume est nul.\r\n                    Défaut : \"Activer le son\".\r\n        - disabled :  si true, le bouton porte l'attribut disabled et demeure donc inactif.\r\n                      Dans ce cas, le potentiomètre est caché.\r\n                      Défaut : false.         \r\n        - hidden :    si true, la propriété display du bouton est passée en 'hidden' et le bouton est donc invisible.\r\n                      Dans ce cas, le potentiomètre est caché.\r\n                      Défaut : false.         \r\n      Défaut : {label:{mute:'Désactiver le son', unmute:'Activer le son'}, disabled:false, hidden:false}.\r\n    - volumeGroup : Nombre entier supérieur à zéro spécifiant le groupe de lecteurs qui partagent le même volume.\r\n                    Tout changement de volume intervenant sur un des lecteurs de ce groupe sera effectué sur les autres lecteurs du même groupe.\r\n      Défaut : 0 (Le lecteur n'appartient à aucun groupe).\r\n    PROPRIÉTÉS PROPRES AU LECTEUR\r\n    - hideControlsDelay : Exprimée en ms, durée du délai intervenant avant de cacher la barre de contrôle.\r\n      Défaut : 5000.\r\n    - videoVolumeOrientation : si ce paramètre n'est pas défini par la chaine 'horizontal', le potentiomètre de volume est en mode vertical.\r\n      Défaut : 'vertical'.\r\n    - railMinWidthForNormalUI : largeur minimale disponible pour la barre temporelle dans l'interface normale.\r\n      Si la largeur disponible pour la barre temporelle est inférieure à ce paramètre, l'interface bascule en mode compact.\r\n      Défaut : 600.\r\n    PROPRIÉTES GLOBALES\r\n    - appLabel : texte à appliquer à l'aria-label du lecteur.\r\n      Défaut : 'Lecteur vidéo'.\r\n    - playLabel : texte affecté au titre du bouton Pause et à son attribut aria-label.\r\n      Défaut : 'Pause'.\r\n    - playLabel : texte affecté au titre du bouton Play et à son attribut aria-label.\r\n      Défaut : 'Lecture'.\r\n    - volumeHelpLabel : texte à appliquer au titre du potentiomètre.\r\n      Défaut : 'Utilisez les flèches Haut/Bas du clavier pour augmenter ou diminuer le volume'.\r\n    - volumeSliderLabel : texte à appliquer à l'aria-label du potentiomètre.\r\n      Défaut : 'Potentiomètre de volume'.\r\n  \r\n  Les options autoplay, crossorigin, loop, playsinline, poster peuvent être attribuées via les attributs HTML du tag <video>.\r\n  Si, par ailleurs, le tag comporte des attributs width et height, le format de la vidéo sera déterminé par ces valeurs.\r\n  S'il comporte l'attribut muted, le volume sera interprété comme nul.\r\n  Les paramètres passés au constructeur priment sur les attributs HTML.\r\n  Les paramètres listés sous le titre \"PROPRIÉTÉS PROPRES À LA SOURCE\" peuvent toutes être redéfinies lors du changement de source.\r\n  Le constructeur intègre de surcroit une propriété facultative volumeForced. Si celle-ci est spécifiée à true, le volume passé en paramètre sera\r\n  appliqué au lecteur et à son groupe éventuel. Dans les autres cas, si le lecteur appartient à un groupe déjà existant,\r\n  c'est le volume de ce groupe qui lui sera appliqué.\r\n  Cette propriété est également applicable au changement de source.\r\n\r\n  EXEMPLES\r\n  1.\r\n    HTML : \r\n      <video id=\"myvideo\" src=\"myvideo.mp4\" poster=\"myvideo.jpg\" preload=\"auto\">\r\n    Javascript :\r\n      let player = new AmstramgramVideoPlayer(document.querySelector('#myvideo'))\r\n  2.\r\n    HTML : \r\n      <video id=\"myvideo\">\r\n    Javascript :\r\n      let player = new AmstramgramVideoPlayer(document.querySelector('#myvideo'), {\r\n        autoplay: true,\r\n        duration: 125,\r\n        format: 4/3,\r\n        next: {label:'La vidéo suivante', disabled:false, hidden:false}\r\n        preload: 'auto',\r\n        previous: {label: 'Rien à voir', hidden:false}\r\n        skipTime: '2%',\r\n        src: 'myvideo.mp4',\r\n        volume: 0,\r\n        volumeGroup: 1,\r\n        videoVolumeOrientation: 'horizontal',\r\n      })\r\n      Et plus tard :\r\n      player.src = {\r\n        format: 16/9,\r\n        duration: 850,\r\n        next: {label:'Plus rien', disabled:true}\r\n        poster: 'myvideo2.jpg',\r\n        preload: 'none',\r\n        previous: {label:'Revoir la vidéo précédente', disabled:false}\r\n        skipTime: '5%',\r\n        src: 'myvideo2.mp4',\r\n        volume: 0.5,\r\n        volumeForced: true\r\n      }\r\n\r\n  GETTERs/SETTERs\r\n    - src\r\n        - get : retourne la source du média\r\n        - set : définit une nouvelle source et éventuellement un certain nombre de propriétés\r\n          Prend en paramètre une chaine définissant le chemin de la source ou un objet : {\r\n              autoplay: false,\r\n              crossorigin: 'anoanymous',\r\n              download: {label:'Télécharger', disabled:false, hidden:false},\r\n              duration:  200,\r\n              format : 16/9,\r\n              fullscreen: {label:{enter:'Plein écran', exit:'Quitter le plein écran'}, disabled:false, hidden:false},\r\n              loop: false,\r\n              next: {label:'Suivant', disabled:true, hidden:true},\r\n              playsinline: true, \r\n              poster: 'source du poster',\r\n              preload: 'none',\r\n              previous: {label:'Précédent', disabled:true, hidden:true},\r\n              skipTime: '1%',\r\n              thumbnails: {src:'source de l'image', number:100},\r\n              volume: 0.8,\r\n              volumeButton: {label:{mute:'Désactiver le son', unmute:'Activer le son'}, disabled:false, hidden:false},\r\n              volumeGroup: 0,\r\n              (volumeForced: true,)\r\n          }\r\n    - currentTime\r\n        - get : retourne la position temporelle courante.\r\n        - set : améne la tête de lecture à la position spécifiée en secondes.\r\n    - volume\r\n        - get : retourne le niveau de volume.\r\n        - set : fixe le volume au niveau spécifié (nombre entre 0 et 1).\r\n\r\n  GETTERS\r\n    - duration : retourne la durée du média si elle est disponible.\r\n    - paused : retroune true si le média est en pause\r\n\r\n  MÉTHODES\r\n    - play() : met le média en lecture.\r\n    - pause() : met le média en pause.\r\n    - reset() : reset le lecteur.\r\n    - togglePlayPause() : passe le média en pause s'il est en lecture et réciproquement.\r\n    - hideControls(delayed = false, forced = false) : cache la barre de contôle\r\n        Si delayed vaut true, la disparition n'intervient qu'apres le délai fixé par le paramètre hideControlsDelay du lecteur.\r\n        Par défaut, la disparition est bloquée si la vidéo est en pause.\r\n        Pour la forcer, il faut passer le deuxième argument à true.\r\n    - showControls : montre la barre de contrôle.\r\n    - previous() : affecte de nouvelles propriétés au bouton Previous.\r\n        Prend en paramètre un objet de la forme : {label:'Précédent', disabled:true, hidden:true}.\r\n    - next() : affecte de nouvelles propriétés au bouton Next.\r\n        Prend en paramètre un objet de la forme : {label:'Suivant', disabled:true, hidden:true}.\r\n    - download() : affecte de nouvelles propriétés au bouton Download.\r\n        Prend en paramètre un objet de la forme : {label:'Télécharger', disabled:false, hidden:false}.\r\n    - fullscreen() : affecte de nouvelles propriétés au bouton Fullscreen.\r\n        Prend en paramètre un objet de la forme : {label:{enter:'Plein écran', exit:'Quitter le plein écran'}, disabled:false, hidden:false}.\r\n    - volumeButton() : affecte de nouvelles propriétés au bouton Volume.\r\n        Prend en paramètre un objet de la forme : {label:{mute:'Désactiver le son', unmute:'Activer le son'}, disabled:false, hidden:false}.\r\n  \r\n  MÉTHODE STATIQUE\r\n    options() : permet de redéfinir les propriétés par défaut de la class avant toute création d'instance.\r\n\r\n  PROPRIÉTÉS\r\n    - container : pointe sur l'élément HTML container du lecteur.\r\n    - media : pointe sur l'élément HTML <video> du lecteur.\r\n    - params : renvoie les paramètres du lecteur.\r\n*/\r\n\r\n/************************************************\r\n *                                              *\r\n *              INITIALISATION                  *\r\n *                                              *\r\n ************************************************/\r\nconst \r\n  w = window, \r\n  d = document,\r\n  //Définition du type de pointeur\r\n  //Si PointerEvent est détecté, le type vaut 'pointer'\r\n  //Sinon, si TouchEvent est détecté, le type vaut 'touch' et il y a fort à parier qu'on soit sur iOS\r\n  //Enfin, si jamais PointerEvent et TouchEvent ne sont pas détectés, le type vaut 'mouse'\r\n  myPointerType = (w.PointerEvent)?'pointer':(w.TouchEvent)?'touch':'mouse',\r\n  //On en déduit le nom des évènements correspondants\r\n  myPointerEnter = (myPointerType == 'touch')?'none':myPointerType + 'enter',\r\n  myPointerLeave = (myPointerType == 'touch')?'none':myPointerType + 'leave',\r\n  myPointerDown = (myPointerType == 'touch')?'touchstart':myPointerType + 'down',\r\n  myPointerUp = (myPointerType == 'touch')?'touchend':myPointerType + 'up',\r\n  myPointerMove = myPointerType + 'move',\r\n  //Détection de l'user agent pour savoir si on est sur mobile\r\n  //Dans ce cas, on ne crée pas de potentiomètre de volume\r\n  UA = w.navigator.userAgent.toLowerCase(),\r\n  IS_MOBILE = (/ipad|iphone|ipod/i.test(UA) && !w.MSStream) || /android/i.test(UA)\r\n\r\nif (typeof Object.assign !== 'function' || !Array.from || !Array.prototype.includes || typeof window.CustomEvent !== \"function\") {\r\n  const scripts= d.getElementsByTagName('script'),\r\n        path= scripts[scripts.length-1].src.split('?')[0],\r\n        mydir= path.split('/').slice(0, -1).join('/')+'/',\r\n        s = d.createElement('script')\r\n  s.async=\"false\"\r\n  s.src = mydir + \"amstramgramVideoPlayerPolyfill.min.js\"\r\n  d.head.appendChild(s)\r\n}\r\n\r\n//Edge ne comprend toujours pas getAttributeNames (IE11 non plus, bien évidemment)\r\nif (Element.prototype.getAttributeNames == undefined) {\r\n  Element.prototype.getAttributeNames = function () {\r\n    var a = this.attributes, l = a.length, r = new Array(l);\r\n    for (var i = 0; i < l; i++) {\r\n      r[i] = a[i].name\r\n    }\r\n    return r\r\n  };\r\n}\r\n//Détection du support de la fonctionnalité sessionStorage\r\nconst storage = (function(){\r\n  try {\r\n      let x = '__storage_test__'\r\n      w.sessionStorage.setItem(x, x)\r\n      w.sessionStorage.removeItem(x)\r\n      return w.sessionStorage\r\n  }\r\n  catch(e) {return false}\r\n})()\r\n/*\r\nSi sessionStorage est disponible, on y stocke toutes les fonctionnalités détectés\r\nafin de ne plus avoir de détection à opérer par la suite.\r\nOn y conserve également les informations de volume pour chaque groupe de lecteurs\r\n\r\nCalcul de la largeur des éléments indicateurs temporel.\r\nCes largeurs dépendent du navigateur et doivent être déterminées\r\npour assurer le bon positionnement des éléments.\r\nOn mesure les largeurs pour des temps :\r\n- inférieur à une heure (durée affichée : 00:00)\r\n- supérieur ou égal à une heure (durée affichée : 00:00:00)\r\n*/\r\nlet timeWidth, longTimeWidth\r\nif (storage && storage.getItem('amst_timeWidth')) {\r\n  timeWidth = storage.getItem('amst_timeWidth')\r\n  longTimeWidth = storage.getItem('amst_longTimeWidth')\r\n} else {\r\n  const \r\n    measureTime = d.createElement('div'), \r\n    measureLongTime = d.createElement('div')\r\n  //La class amst__measureTime reprend les mêmes propriétés graphiques que la class amst__time\r\n  //mais assure un positionnement absolu.\r\n  measureTime.classList.add('amst__measureTime')\r\n  measureTime.innerHTML = '<span>00:00<span>'\r\n  measureLongTime.classList.add('amst__measureTime')\r\n  measureLongTime.innerHTML = '<span>00:00:00<span>'\r\n  d.body.appendChild(measureTime)\r\n  d.body.appendChild(measureLongTime)\r\n  timeWidth = measureTime.offsetWidth + 2\r\n  longTimeWidth = measureLongTime.offsetWidth + 2\r\n  d.body.removeChild(measureTime);\r\n  d.body.removeChild(measureLongTime);\r\n  if (storage) {\r\n    storage.setItem('amst_timeWidth', timeWidth)\r\n    storage.setItem('amst_longTimeWidth', longTimeWidth)\r\n  }\r\n}\r\n//Insertion des règles déterminées dans le DOM\r\nconst style = d.createElement(\"style\")\r\n// WebKit hack\r\nstyle.appendChild(d.createTextNode(\"\"))\r\nd.head.appendChild(style)\r\nstyle.sheet.insertRule(`.amst__time>span{width:${timeWidth}px;`,0)\r\nstyle.sheet.insertRule(`.amst__long .amst__time>span{width:${longTimeWidth}px;`,0)\r\n\r\n\r\n//Détection de la fonctionnalité fullscreen et de ses éventuels préfixes\r\nlet fullscreenAPI = false\r\nif (storage && storage.getItem('amst_fullscreenAPI') != undefined) {\r\n  fullscreenAPI = JSON.parse(storage.getItem('amst_fullscreenAPI'))\r\n} else {\r\n  //https://github.com/sindresorhus/screenfull.js/\r\n  //Détection des préfixes pour la gestion du plein écran\r\n  fullscreenAPI = (function(){\r\n    let \r\n      val,\r\n      fnMap = [\r\n        ['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenchange'],\r\n        // New WebKit\r\n        ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitfullscreenchange'],\r\n        // Old WebKit (Safari 5.1)\r\n        ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitfullscreenchange'],\r\n        ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozfullscreenchange'],\r\n        ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'MSFullscreenChange']\r\n      ],\r\n      i = 0,\r\n      l = fnMap.length,\r\n      ret = {}\r\n    for (; i < l; i++) {\r\n      val = fnMap[i]\r\n      if (val && val[1] in d) {\r\n        for (i = 0; i < val.length; i++) {\r\n          ret[fnMap[0][i]] = val[i];\r\n        }\r\n        return ret\r\n      }\r\n    }\r\n    return false;\r\n  })()\r\n  storage.setItem('amst_fullscreenAPI', JSON.stringify(fullscreenAPI))\r\n}\r\n\r\n/*\r\nPRÉFIXES CSS\r\nDéfinition des préfixes propres aux navigateurs\r\npour les propriétés transform et transition\r\nafin de pouvoir les ajuster dans javascript\r\nhttps://gist.github.com/streunerlein/2935794\r\n*/\r\nlet transitionPrefix, transformPrefix\r\nif (storage && storage.getItem('amst_transitionPrefix') != undefined && storage.getItem('amst_transformPrefix') != undefined) {\r\n  transitionPrefix = storage.getItem('amst_transitionPrefix')\r\n  transformPrefix = storage.getItem('amst_transformPrefix')\r\n} else {\r\n  let GetVendorPrefix = function(arrayOfPrefixes) {\r\n    let tmp = d.createElement(\"div\"),\r\n        result = ''\r\n    for (let i = 0; i < arrayOfPrefixes.length; ++i) {\r\n      if (typeof tmp.style[arrayOfPrefixes[i]] != 'undefined'){\r\n        result = arrayOfPrefixes[i]\r\n        break;\r\n      }\r\n      else {\r\n        result = null\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  transitionPrefix = GetVendorPrefix([\"transition\", \"msTransition\", \"MozTransition\", \"WebkitTransition\", \"OTransition\"])\r\n  transformPrefix = GetVendorPrefix([\"transform\", \"msTransform\", \"MozTransform\", \"WebkitTransform\", \"OTransform\"])\r\n  storage.setItem('amst_transitionPrefix', transitionPrefix)\r\n  storage.setItem('amst_transformPrefix', transformPrefix)\r\n}\r\n  \r\n\r\n/*DÉTECTECTION DES ECRANS TACTILES\r\n//https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent#Event_order\r\nPour rappel, la séquence des évènements sur une surface tactile se présente comme suit :\r\n  - touchstart\r\n  - Zero or more touchmove events, depending on movement of the finger(s)\r\n  - touchend\r\n  - mousemove\r\n  - mousedown\r\n  - mouseup\r\n  - click.\r\nDonc, sur une surface tactile, touchstart sera déclenché avant mousemove\r\net si l'on détecte un mousemove, c'est bel et bien que l'on n'est pas sur tactile.\r\n\r\nPar défaut, l'interface graphique est orientée touchDevice.\r\nSi l'on constate que l'on est sur le dispositif de pointage n'est pas tactile,\r\non applique au container principal une class no-touch.\r\nCette class assure la prise en charge de la pseudo-class css :hover.\r\nPar ailleurs, elle opère une réduction de moitié des hauteurs de la barre temporelle \r\net du potentiomètre de volume (s'il est en mode horizontal)\r\nlorsque ces éléments ne sont pas survolés par le pointeur.\r\nDans cette configuration, le survol de la barre de lecture affiche la position temporelle\r\net l'éventuelle vignette correspondant à la position du pointeur au dessus de cette barre.\r\nDans la configuration tactile, c'est le slide horizontal qui assure cette fonctionnalité :\r\nl'information temporelle et la vignette sont alors affichées dans la partie supérieure de la vidéo.\r\n\r\nOn déclare donc une variable _pointerType et on lui affecte la valeur 'unknown'.\r\nOn pose un premier écouteur pour détecter un éventuel déplacement du pointeur\r\net un second sur l'évènement touchstart.\r\nSi on détecte un touchstart, on donne la valeur 'touch' à la variable _pointerType.\r\nSi on détecte un déplacement, on passe la valeur 'mouse' à _pointerType..\r\nAussitôt la détection effectuée, on stoppe les deux écouteurs initialement posés\r\net on transmet l'information aux éventuelles instances créées entretemps\r\n*/  \r\nlet _pointerType = 'unknown'\r\nif (storage && storage.getItem('amst_pointerType')) {\r\n  _pointerType = storage.getItem('amst_pointerType')\r\n} else{\r\n  const\r\n    testPointerMove = function(e){\r\n      _pointerType = (e.pointerType)?e.pointerType:'mouse'\r\n      cleanTestPointer()\r\n    },\r\n    testTouchStart = function(){\r\n      _pointerType = 'touch'\r\n      cleanTestPointer()\r\n    },\r\n    cleanTestPointer = function(){\r\n      storage.setItem('amst_pointerType', _pointerType)\r\n      w.removeEventListener(myPointerMove, testPointerMove)\r\n      w.removeEventListener('touchstart', testTouchStart)\r\n      if (AmstramgramVideoPlayer.players.length > 0) {\r\n        AmstramgramVideoPlayer.players.forEach(p=>p.container.dispatchEvent(new CustomEvent('pointerDetected')))\r\n      }\r\n    }\r\n  w.addEventListener(myPointerMove, testPointerMove, false)\r\n}\r\n\r\n//Détection du support de l'option passive sur les events\r\n//https://github.com/WICG/EventListenerOptions/blob/gh-pages/EventListenerOptions.polyfill.js\r\nlet _supportPassiveEvents = false\r\nif (storage && storage.getItem('amst_supportPassiveEvents')) {\r\n  _supportPassiveEvents = storage.getItem('amst_supportPassiveEvents')\r\n} else{\r\n  d.createElement(\"div\").addEventListener(\"test\", ()=>{}, {\r\n    get passive() {\r\n      _supportPassiveEvents = true\r\n      storage.setItem('amst_supportPassiveEvents', _supportPassiveEvents)\r\n      return false\r\n    }\r\n  })\r\n}\r\n\r\n\r\n/************************************************\r\n *                                              *\r\n *                 DÉBUT CLASS                  *\r\n *                                              *\r\n ************************************************/\r\nclass AmstramgramVideoPlayer {\r\n  /*Fonction statique permettant de redéfinir les options par défaut \r\n    Usage : \r\n      AmstramgramVideoPlayer.options({volume:0})\r\n      let player = new AmstramgramVideoPlayer(document.querySelector('video'))\r\n  */\r\n  static options(obj){\r\n    if (AmstramgramVideoPlayer.players.length == 0) AmstramgramVideoPlayer.defaultOptions = mergeDeep(AmstramgramVideoPlayer.defaultOptions, obj)\r\n  }\r\n\r\n  constructor(el, params) {\r\n/************************************************\r\n *                                              *\r\n *               RÉCUPÉRATION ET                *\r\n *          TRAITEMENT DES PARAMÈTRES           *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n      Récupération des attributs HTML éventuels de l'élément. \r\n      On ne retient que ceux qui nous intéressent, à savoir :\r\n      - autoplay\r\n      - crossorigin\r\n      - loop\r\n      - muted\r\n      - playsinline\r\n      - poster\r\n      - preload\r\n      - src\r\n\r\n\r\n    AmstramgramVideoPlayer.defaultOptions = {\r\n      autoplay: false,\r\n      crossorigin: 'anonymous',\r\n      download: {label:'Télécharger', disabled:false, hidden:false},\r\n      duration: 120,\r\n      format: 16/9,\r\n      fullscreen: {label:{enter:'Plein écran', exit:'Quitter le plein écran'}, disabled:false, hidden:false},\r\n      loop: false,\r\n      next: {label:'Suivant', disabled:true, hidden:true},\r\n      playsinline: true,\r\n      poster: undefined,\r\n      preload: 'none',\r\n      previous: {label:'Précédent', disabled:true, hidden:true},\r\n      skipTime: '1%',\r\n      thumbnails: {src:undefined, number:100},\r\n      volume: 0.8,\r\n      volumeButton: {label:{mute:'Désactiver le son', unmute:'Activer le son'}, disabled:false, hidden:false},\r\n      //Players properties\r\n      volumeGroup: 0,\r\n      hideControlsDelay: 5000,\r\n      videoVolumeOrientation: 'vertical',\r\n      railMinWidthForNormalUI: 600,\r\n      //Global properties\r\n      appLabel:'Lecteur Vidéo',\r\n      pauseLabel:'Pause',\r\n      playLabel:'Lecture',\r\n      volumeHelpLabel:'Utilisez les flèches Haut/Bas du clavier pour augmenter ou diminuer le volume.',\r\n      volumeSliderLabel:'Potentiomètre de volume',\r\n    }\r\n  */\r\n\r\n    //booleanAttributes = attributs de valeur vide. S'ils sont présents, le paramètre correspondant est passé à true.\r\n    //La propriété muted si elle est présente sera convertie en volume = 0\r\n    //Les 3 autres seront appliquées à l'élément construit\r\n    const booleanAttributes = ['autoplay', 'loop', 'muted', 'playsinline']\r\n    //Les autres attributs à récupérer :\r\n    let attributes = booleanAttributes.concat(['crossorigin', 'poster', 'preload', 'src'])\r\n    //https://davidwalsh.name/javascript-attributes#comment-511786\r\n    this.params = el.getAttributeNames().reduce((obj, name)=>{\r\n      if (attributes.includes(name)) {\r\n        //si l'attribut traité nous intéresse, on passe sa valeur au paramètre qui lui correspond.\r\n        obj[name] = booleanAttributes.includes(name)?true:el.getAttribute(name)\r\n      }\r\n      return obj;\r\n    }, {})\r\n    //Conversion de muted en volume nul\r\n    if (this.params.muted) {\r\n      this.params.volume = 0\r\n      delete this.params.muted\r\n    }\r\n    //Si les attributs width et height sont présents et ont un sens,\r\n    //on en déduit le format\r\n    if (parseInt(el.getAttribute('width')) > 0 && parseInt(el.getAttribute('height')) > 0) {\r\n      this.params.format = parseInt(el.getAttribute('width')) / parseInt(el.getAttribute('height'))\r\n    }\r\n    //On supprime muted de la liste des attributs à traiter\r\n    //On rajoute les propriétés susceptibles d'être passées lors de la création de l'instance\r\n    attributes = attributes.filter(param=>{return param != 'muted'}).concat(['download', 'duration', 'format', 'fullscreen', 'hideControlsDelay', 'next', 'previous', 'skipTime', 'thumbnails', 'videoVolumeOrientation', 'volume', 'volumeButton', 'volumeForced', 'volumeGroup', 'railMinWidthForNormalUI'])\r\n    //Si des paramètres ont été passés à l'instance, ils priment sur ceux qui sont définis par les attributs.\r\n    //On élimine toute propriété qui n'aurait rien à faire là en ne retenant que celles qui sont listées dans le tableau attributes\r\n    if (params) \r\n      params = Object\r\n        .keys(params)\r\n        .filter(key=>attributes.includes(key))\r\n        .reduce((res, key)=>(res[key] = params[key], res), {})\r\n    //On merge les paramètres de l'instance avec ceux de la page HTML\r\n    if (params) this.params = mergeDeep(this.params, params)\r\n    this.params = mergeDeep(AmstramgramVideoPlayer.defaultOptions, this.params)\r\n/************************************************\r\n *                                              *\r\n *             FIN RÉCUPÉRATION ET              *\r\n *          TRAITEMENT DES PARAMÈTRES           *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *             CONSTRUCTION HTML                *\r\n *                                              *\r\n ************************************************/\r\n    const \r\n      wrapper = d.createElement('div'),//Élément wrapper renfermant tous les éléments HTML du lecteur\r\n      //Si le paramètre d'orientation du potentiometre de volume est défini autrement que par la chaine 'horizontal', \r\n      //on fixe sa valeur à 'vertical'\r\n      videoVolumeOrientation = (this.params.videoVolumeOrientation=='horizontal')?'horizontal':'vertical',\r\n      passive = _supportPassiveEvents\r\n\r\n    //Construction des éléments HTML de l'UI en fonction des paramètres\r\n    wrapper.classList.add('amst__wrapper')  \r\n    wrapper.classList.add('amst__video')  \r\n    wrapper.innerHTML = buildUI(this.params)\r\n    //Insertion du wrapper dans le DOM\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    //Pour éviter tout problème sous Androïd, on reset la source de l'élément original\r\n    //avant de le supprimer\r\n    el.removeAttribute('src')\r\n    el.parentNode.removeChild(el)\r\n    \r\n/************************************************\r\n *                                              *\r\n *             FIN CONSTRUCTION HTML            *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *          DÉCLARATIONS DES VARIABLES          *\r\n *                                              *\r\n ************************************************/\r\n    //Constantes\r\n    const \r\n      self = this,\r\n      $ = _$(wrapper),//Définition de la fonction $ : $('video') renvoie le premier élément HTML video contenu dans le wrapper\r\n      $$ = _$$(wrapper),//Définition de la fonction $$ : $$('.amst__layer') renvoie un tableau des éléments portant la classe amst__layer\r\n      media = this.media = $('video'),\r\n      container = this.container = $('.amst__container'),\r\n      layerPoster =  $('.amst__layer-poster'),\r\n      layerPosterCanvas =  $('.amst__layer-poster canvas'),\r\n      layerSeekingTouch = $('.amst__layer-seeking-touch'),\r\n      seekingTouch = $('.amst__seeking-touch'),\r\n      layerPlay = $('.amst__layer-play'),\r\n      layerLoading = $('.amst__layer-loading'),\r\n      controls = $('.amst__controls'),\r\n      controlsPadding = 2 * controls.css('padding-left'),\r\n      playPauseButton = $('.amst__playpause>button'),\r\n      rail = $('.amst__rail'),\r\n      slider = $('.amst__slider'),\r\n      handle = $('.amst__handle'),\r\n      timeCurrent = $('.amst__currenttime-bar'),\r\n      seeking = $('.amst__seeking'),\r\n      volumeButton = $('.amst__volumebutton button'),\r\n      volumeSlider = $('.amst__volume-slider')\r\n\r\n      \r\n    //Variables\r\n    let //Largeur du lecteur actualisée sur l'évènement resize \r\n        //et nécessaire pour positionner la vignette de preview sur tactile\r\n        playerWidth,\r\n        //Position et dimensions de l'élément volume recalculées lors d'un évènement resize ou scroll\r\n        volumeRect,\r\n        //Abscisse et largeur de l'élément slider recalculées lors d'un évènement resize ou scroll\r\n        sliderLeft, sliderWidth,\r\n        //Largeur cumulée des éléments visibles dans la barre de contrôle à l'exclusion du slider\r\n        //dont on peut déduire la largeur disponible pour le slider.\r\n        //LargeurDisponible = playerWidth - controlsElementsWidth - controlsPadding\r\n        //Si cette valeur est inférieure à celle donnée par l'option railMinWidthForNormalUI,\r\n        //on bascule vers l'interface réduite.\r\n        controlsElementsWidth,\r\n        timeoutGetControlsElementsWidth,\r\n        //Animation de la barre temporelle\r\n        updateTimeRailAnimation,\r\n        //Variable mise à jour sur l'évènement durationchange au cas où l'option skipTime ait été donnée en pourcentage.\r\n        //Elle retient la valeur du skip à effectuer exprimée en secondes\r\n        skipTime,\r\n        //Enregistre la position temporelle courante de la vidéo arrondie à la seconde inférieure.\r\n        //Le cas échéant, permet de relancer la lecture de la vidéo à l'endroit où elle a été\r\n        //stoppée par le lancement d'un autre lecteur.\r\n        floorCurrentTime = 0,\r\n        //Variable mise à jour sur l'événement timeupdate\r\n        //Provoque un reset de l'animation de la barre temporelle \r\n        //si elle diffère de plus d'une demi seconde de la position temporelle effective\r\n        prevCurrentTime = 0,\r\n        //Variable enregistrant la présence du pointeur sur les contrôles.\r\n        //Si true, on bloque la disparition de la barre de contrôle.\r\n        pointerOverControls = false,\r\n        //Stocke le buffer du média\r\n        //Si on détecte une différence entre buffered et media.buffered\r\n        //on reconstruit les zones rectangulaires qui mettent en évidence les parties chargées dans la barre temporelle.\r\n        buffered,\r\n        //Variable passée à true sur les événements seeking, waiting et loadeddata.\r\n        //Si true, on bloque la disparition de la barre de contrôle.\r\n        //Retourne à false sur les événements play, playing, seeked et canplay\r\n        isBuffering = false,\r\n        //setTimeout contrôlant la disparition de la barre de contrôle\r\n        hideControlsTimeOut,\r\n        //Largeur de l'élément seeking = $('.amst__seeking'), actualisée au premier mouvement de la souris sur la barre temporelle\r\n        //Necessaire pour positionner l'élément ainsi que son background\r\n        seekingWidth,\r\n        //Largeur de l'élément seekingTouch = $('.amst__seeking-touch'), actualisée au premier swipe horizontal sur la vidéo\r\n        //Necessaire pous positionner l'élément ainsi que son background\r\n        seekingTouchWidth,\r\n        //Largeur de la vignette déterminée après le chargement de l'image spécifiée \r\n        //en divisant la largeur de cette image par le nombre de vignettes déclaré en paramètre\r\n        thumbWidth = 0,\r\n        volumeBeforeMute\r\n\r\n\r\n/************************************************\r\n *                                              *\r\n *          FIN INSERTION DANS LE DOM           *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                     PLAY                     *\r\n *                                              *\r\n ************************************************/\r\n    //Fonction déclenchée par l'évènement 'amstEvent__play' généré par la méthode publique play()\r\n    function _play(){\r\n      //https://developers.google.com/web/updates/2016/03/play-returns-promise\r\n      let playPromise = media.play()\r\n      if (playPromise) playPromise.catch(()=>_pause())\r\n      //Si une autre instance est en cours de lecture, on la reset\r\n      if (AmstramgramVideoPlayer.currentPlayer && AmstramgramVideoPlayer.currentPlayer != self) AmstramgramVideoPlayer.currentPlayer.reset()\r\n      //On déclare l'instance comme lecteur courant\r\n      AmstramgramVideoPlayer.currentPlayer = self\r\n      container.focus()\r\n      //Mise à jour du bouton\r\n      playPauseButton.setAttributes({\r\n        class: 'amst__pause',\r\n        title: self.params.pauseLabel,\r\n        'aria-label': self.params.pauseLabel\r\n      })\r\n      //On cache le layer comprenant le gros bouton play\r\n      layerPlay.classList.add('amst__hidden')\r\n      //On programme la disparition de la barre de controle\r\n      if (!pointerOverControls) _hideControls({detail:{delayed:true}})\r\n    }\r\n    //On écoute l'évènement 'amstEvent__play' généré par la méthode play()\r\n    container.on('amstEvent__play', _play, false)\r\n/************************************************\r\n *                                              *\r\n *                  FIN PLAY                    *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                    PAUSE                     *\r\n *                                              *\r\n ************************************************/\r\n    //Fonction déclenchée par l'évènement 'amstEvent__pause' généré par la méthode publique pause()\r\n   function _pause(){\r\n      media.pause()\r\n      //Mise à jour du bouton\r\n      playPauseButton.setAttributes({\r\n        class: '',\r\n        title: self.params.playLabel,\r\n        'aria-label': self.params.playLabel\r\n      })\r\n      //On affiche le layer comprenant le gros bouton play\r\n      layerPlay.classList.remove('amst__hidden')\r\n      //On affiche la barre de contrôle.\r\n      _showControls()\r\n      container.focus()\r\n    }\r\n    //On écoute le custom event 'amstEvent__pause' généré par la méthode pause()\r\n    container.on('amstEvent__pause', _pause, false)\r\n/************************************************\r\n *                                              *\r\n *                  FIN PAUSE                   *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                    RESET                     *\r\n *                                              *\r\n ************************************************/\r\n    function _reset(){\r\n      /*La fonction est appelée si une autre instance passe en lecture\r\n      et que le présent lecteur avait auparavant été lancé.\r\n      Elle assure le reset complet de la source et le passage de preload en none\r\n      de manière à éviter tout problème avec les dispositifs qui limitent le nombre\r\n      de préchargements de videos sur une même page (Androïd entre autres).\r\n      Pour simuler une pause, on enregistre l'image courante de la vidéo\r\n      et on l'affiche dans un canvas à la place du poster.\r\n      */\r\n      //Dimensionnement du canvas\r\n      layerPosterCanvas.width = media.videoWidth\r\n      layerPosterCanvas.height = media.videoHeight\r\n      //Copie de l'image dans le canvas\r\n      layerPosterCanvas.getContext('2d').drawImage(media, 0, 0, layerPosterCanvas.width, layerPosterCanvas.height)\r\n      //On affiche le layer-poster. Le poster qui constitue le background est caché par le canvas.\r\n      layerPoster.classList.remove('amst__hidden')\r\n      //On reset le lecteur\r\n      container.classList.remove('amst__loadedmetadata')\r\n      media.src = ''\r\n      media.preload = 'none'\r\n      media.src = self.params.src\r\n    }\r\n    //On écoute l'évènement 'amstEvent__' généré par la méthode reset()\r\n    container.on('amstEvent__', _reset, false)\r\n/************************************************\r\n *                                              *\r\n *                  FIN RESET                   *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                HIDECONTROLS                  *\r\n *                                              *\r\n ************************************************/\r\n    /*Fonction déclenchée par le custom event 'amstEvent__hideControls' généré par la méthode publique hideControls()\r\n    @param {e} Custom Event\r\n    event.detail : \r\n      - delayed (boolean) - default false\r\n      - forced (boolean) - default false\r\n    Passé à true, delayed programme la disparition de la barre de controle \r\n    après un temps défini par l'option hideControlsDelay.\r\n    Passé à true, forced force la disparition de la barre de controle \r\n    alors même que la vidéo est en pause.\r\n    Il est uniquement employé sur les écrans tactiles lors du swipe horizontal \r\n    qui fait fonction de recherche.\r\n    La disparition avec délai se réalise via un bête setTimeout qui relance la fonction\r\n    elle même.\r\n    */\r\n    function _hideControls(e){\r\n      let delayed = e?e.detail.delayed:false,\r\n          forced = e?e.detail.forced:false\r\n      if (media.paused && !forced) {\r\n        //La barre de contrôle reste systématiquement visible\r\n        //à moins d'être sur tactile et que l'utilisateur opère un swipe horizontal\r\n        //pour se déplacer dans le temps.\r\n        return\r\n      } else if (delayed || isBuffering || pointerOverControls) {\r\n        //Si le paramètre delayed vaut true ou qu'un buffering est en cours\r\n        //ou que le pointeur est positionné sur la barre de contrôle :\r\n        //on annule l'éventuel timeout en cours et on en lance un nouveau\r\n        if (hideControlsTimeOut) clearTimeout(hideControlsTimeOut)\r\n        hideControlsTimeOut = setTimeout(()=>_hideControls(), self.params.hideControlsDelay)\r\n      } else {\r\n        //Sinon, on cache...\r\n        container.focus()\r\n        controls.style[transformPrefix] = 'translateX(-50%) scaleY(0)'\r\n      }\r\n    }\r\n    //On écoute le custom event 'amstEvent__hideControls' généré par la méthode hideControls()\r\n    container.on('amstEvent__hideControls', _hideControls, false)\r\n/************************************************\r\n *                                              *\r\n *              FIN HIDECONTROLS                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                SHOWCONTROLS                  *\r\n *                                              *\r\n ************************************************/\r\n    function _showControls(){\r\n      //On annule l'éventuelle programmation en cours\r\n      if (hideControlsTimeOut) clearTimeout(hideControlsTimeOut)\r\n      controls.style[transformPrefix] = ''\r\n      //Si la vidéo est en lecture, on programme la disparition de la barre\r\n      if (!media.paused) _hideControls({detail:{delayed:true}})\r\n    }\r\n    //On écoute l'évènement 'amstEvent__showControls' généré par la méthode showControls()\r\n    container.on('amstEvent__showControls', _showControls, false)\r\n/************************************************\r\n *                                              *\r\n *              FIN SHOWCONTROLS                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                UPDATEBUTTONS                 *\r\n *    MAJ PREVIOUS/NEXT/DOWNLOAD/FULLSCREEN     *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n    Chacun des boutons next, previous, download, volume et fullscreen peut être désactivé ou caché.\r\n    Par ailleurs, les boutons next, previous et download disposent d'un label configurable.\r\n    Les boutons fullscreen et volumeButton disposent eux de deux labels configurables\r\n    pour accompagner leur changement d'état éventuel (mute et unmute pour volumeButton, in et out pour fullscreen).\r\n    Les fonctions publiques previous(), next(), download(), fullscreen() et volumeButton() génèrent\r\n    chacunes un événement dédié qui déclenchent respectivement les fonctions \r\n    _previous(), _next(), _download(), _fullscreen() et _volumeButton(),\r\n    lesquelles assurent la mise à jour du bouton ciblé.\r\n    On prévoit deux variables pour les titres associés au bouton fullscreen\r\n    afin de pouvoir le mettre à jour lors des entrées/sorties du mode plein écran\r\n    */\r\n    let enterFullScreenLabel, exitFullScreenLabel\r\n    //On déclare une fonction getMovie pour réagir au click éventuel sur le bouton download.\r\n    //L'écouteur n'est placé que si le bouton porte en option les paramètres disabled:false et hidden:false.\r\n    //Dans les autres cas, il est retiré.\r\n    function getMovie(){\r\n      window.location = self.src.substring(0, self.src.lastIndexOf('/')) + '/index.php?file=' + self.src.substring(self.src.lastIndexOf('/') + 1)\r\n    }\r\n    /*\r\n    Mise à jour des class et attributs du bouton\r\n    name : nom du bouton\r\n    label : label du bouton\r\n    */\r\n    function updateButtonsAttributes(name, label){\r\n      const lowerCaseName = name.toLowerCase(),//pour volumeButton\r\n            buttonContainer = $(`.amst__${lowerCaseName}`), \r\n            button = $(`.amst__${lowerCaseName} > button`)\r\n      //Mise à jour de l'attribut HTML disabled en fonction de l'option disabled.\r\n      if (self.params[name].disabled === true) {\r\n        button.setAttribute('disabled','')\r\n      } else {\r\n        button.removeAttribute('disabled')\r\n      }\r\n      //Mise à jour de la class en fonction de l'option hidden.\r\n      if (self.params[name].hidden === true) {\r\n        buttonContainer.classList.add('amst__hidden')\r\n      } else {\r\n        buttonContainer.classList.remove('amst__hidden')\r\n      }\r\n      //On cache le potentiométre si le bouton de volume est disabled ou hidden.\r\n      if (name == 'volumeButton' && volumeSlider) {\r\n        if (self.params.volumeButton.disabled === true || self.params.volumeButton.hidden === true) {\r\n          volumeSlider.classList.add('amst__hidden')\r\n        } else {\r\n          volumeSlider.classList.remove('amst__hidden')\r\n        }\r\n      }\r\n\r\n      //Mis à jour du label\r\n      button.setAttributes({\r\n        title: label,\r\n        'aria-label': label\r\n      })\r\n      getControlsElementsWidth()\r\n    }\r\n    function updateAllButtons(){//Fonction appelée lors de la mise à jour de la source\r\n      _previous()\r\n      _next()\r\n      _download()\r\n      _volumeButton()\r\n      if (fullscreenAPI) _fullscreen()\r\n    }\r\n    function _previous(){\r\n      updateButtonsAttributes('previous', self.params.previous.label)\r\n    }\r\n    function _next(){\r\n      updateButtonsAttributes('next', self.params.next.label)\r\n    }\r\n    function _download() {\r\n      if (self.params.download.disabled === false && self.params.download.hidden === false) {\r\n        //On pose l'écouteur\r\n        $('.amst__download>button').on('click', getMovie, false)\r\n      } else {\r\n        //On retire l'écouteur\r\n        $('.amst__download>button').off('click', getMovie)\r\n      }\r\n      updateButtonsAttributes('download', self.params.download.label)\r\n    }\r\n    function _fullscreen(){\r\n      enterFullScreenLabel = self.params.fullscreen.label.enter\r\n      exitFullScreenLabel = self.params.fullscreen.label.exit\r\n      updateButtonsAttributes('fullscreen', (AmstramgramVideoPlayer.currentFullScreenPlayer==self)?exitFullScreenLabel:enterFullScreenLabel)\r\n    }\r\n    function _volumeButton(){\r\n      updateButtonsAttributes('volumeButton', (self.volume==0)?self.params.volumeButton.label.unmute:self.params.volumeButton.label.mute)\r\n    }\r\n    //On écoute les événements générés par les setters previous, next, download et fullscreen\r\n    container.on('amstEvent__previousButton', _previous, false)\r\n    container.on('amstEvent__nextButton', _next, false)\r\n    container.on('amstEvent__fullscreenButton', _fullscreen, false)\r\n    container.on('amstEvent__downloadButton', _download, false)\r\n    container.on('amstEvent__volumeButton', _volumeButton, false)\r\n/************************************************\r\n *                                              *\r\n *             FIN UPDATEBUTTONS                *\r\n *    MAJ PREVIOUS/NEXT/DOWNLOAD/FULLSCREEN     *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                    SOURCE                    *\r\n *                                              *\r\n ************************************************/\r\n    function _src(e) {\r\n      let mySrc = e.detail\r\n      //Le cas échéant, on transforme  le paramètre passé au setter en objet\r\n      mySrc = (typeof mySrc === 'object')?mySrc:{src:mySrc}\r\n      if (mySrc.volumeGroup < 1) mySrc.volumeGroup = self.params.volumeGroup\r\n      if (!isNaN(mySrc.volume) && (mySrc.volumeForced === true || !storage.getItem(`amst_volumegroup${mySrc.volumeGroup}`))) {\r\n        //Si un volume a été spécifié et que \r\n        //l'option volumeForced est présente ou que le volumeGroup ne figure pas dans sessionStorage\r\n        self.params.volume = mySrc.volume\r\n        if (mySrc.volumeGroup > 0) storage.setItem(`amst_volumegroup${mySrc.volumeGroup}`, mySrc.volume)\r\n      } else if (storage.getItem(`amst_volumegroup${mySrc.volumeGroup}`)) {\r\n        self.params.volume = storage.getItem(`amst_volumegroup${mySrc.volumeGroup}`)\r\n      }\r\n      //On ne conserve dans mySrc que les propriétés relevantes. \r\n      const srcValidParameters = ['autoplay', 'crossorigin', 'download', 'duration', 'format', 'fullscreen', 'loop', 'next', 'playsinline', 'poster', 'preload', 'previous', 'src', 'skipTime', 'thumbnails', 'volumeButton', 'volumeGroup']\r\n      mySrc = srcValidParameters.reduce((obj, name)=>{\r\n        if (srcValidParameters.includes(name) && mySrc[name] != undefined) {\r\n          obj[name] = mySrc[name]\r\n        }\r\n        return obj;\r\n      }, {})\r\n      //S'il s'agit d'un changement de source\r\n      if (media.getAttribute('src')) {\r\n        //On reset le player\r\n        self.pause()\r\n        prevCurrentTime = 0\r\n        floorCurrentTime = 0\r\n        buffered = undefined\r\n        //On supprime l'ensemble des attributs HTML présents dans le tag <video>\r\n        while (media.attributes.length > 0) media.removeAttribute(media.attributes[0].name)\r\n        //Reset des paramètres autoplay, crossorigin, loop, playsinline, thumnails\r\n        const arr = ['autoplay', 'crossorigin', 'loop', 'playsinline', 'thumbnails']\r\n        arr.forEach(p=>self.params[p] = AmstramgramVideoPlayer.defaultOptions[p])\r\n        //Reset des class sur le container\r\n        container.classList.remove('amst__thumbnails','amst__loadedmetadata')\r\n        //Reset des vignettes\r\n        thumbWidth = 0\r\n        seekingWidth = undefined\r\n        seeking.removeAttribute('style')\r\n        seekingTouchWidth = undefined\r\n        seekingTouch.removeAttribute('style')\r\n        //Mise à jour des paramètres de l'instance.\r\n        for (let [key, value] of Object.entries(mySrc)) {\r\n          self.params[key] = value\r\n        }\r\n      }\r\n      //Le cas échéant, on charge l'image contenant les vignettes\r\n      if (self.params.thumbnails.src) {\r\n        let thumb = new Image()\r\n        const thumbEvent = function(e){\r\n          thumb.removeEventListener('load', thumbEvent)\r\n          thumb.removeEventListener('error', thumbEvent)\r\n          if (e.type == 'load') {\r\n            //Si la source de l'image est valide\r\n            container.classList.add('amst__thumbnails')\r\n            //On détermine la largeur des vignettes\r\n            thumbWidth = thumb.naturalWidth/self.params.thumbnails.number\r\n            //On applique le style résultant aux éléments seeking et et seekingTouch\r\n            let css = {width: `${thumb.naturalWidth/self.params.thumbnails.number}px`, height: `${thumb.naturalHeight}px`, 'background-image':`url(\"${self.params.thumbnails.src}\")`}\r\n            seeking.css(css)\r\n            seekingTouch.css(css)\r\n          } else {\r\n            self.params.thumbnails.src = undefined\r\n          }\r\n        }\r\n        thumb.addEventListener('error', thumbEvent, false)\r\n        thumb.addEventListener('load', thumbEvent, false)\r\n        thumb.src = self.params.thumbnails.src\r\n      }\r\n      //Initialisation/Mise à jour des attributs du tag video\r\n      let attributes = {\r\n        src: self.params.src,\r\n        preload: (IS_MOBILE)?'none':self.params.preload\r\n      }\r\n      if (self.params.playsinline === true) {\r\n        attributes.playsinline = '',\r\n        attributes['webkit-playsinline'] = ''\r\n      }\r\n      if (self.params.loop === true) {\r\n        attributes.loop = ''\r\n      }\r\n      if (self.params.crossorigin) {\r\n        attributes.crossorigin = self.params.crossorigin\r\n      }\r\n      media.setAttributes(attributes)\r\n      //Initialisation/Mise à jour du volume\r\n      self.volume = (IS_MOBILE && self.params.volume > 0)?1:self.params.volume\r\n      if (!volumeBeforeMute) {\r\n        volumeBeforeMute = (media.volume == 0)?0.1:media.volume\r\n        if (IS_MOBILE) volumeBeforeMute = 1\r\n      }\r\n      //Initialisation/Mise à jour du format\r\n      container.style.paddingBottom = 1 / self.params.format * 100 + '%'\r\n      //Initialisation/Mise à jour du poster\r\n      if (self.params.poster) {\r\n        layerPoster.style.backgroundImage = `url(\"${self.params.poster}\")`\r\n        layerPoster.classList.remove('amst__hidden')\r\n      }\r\n      //Initialisation/Mise à jour des informations temporelles\r\n      $('.amst__duration').innerHTML = secondsToTimeCode(self.params.duration)\r\n      $('.amst__currenttime').innerHTML = secondsToTimeCode(0, (self.params.duration > 3600));\r\n      //Mise à jour des boutons\r\n      updateAllButtons()\r\n      //Si autoplay, on lance la lecture\r\n      if (self.params.autoplay === true) {\r\n        _play()\r\n      }\r\n    }\r\n    //On écoute le custom event 'amstEvent__src' généré par la méthode src()\r\n    container.on('amstEvent__src', _src, false)\r\n    //Initialisation de la source\r\n    _src({detail:this.params})\r\n/************************************************\r\n *                                              *\r\n *                  FIN SOURCE                  *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *               ÉVÈNEMENTS MEDIA               *\r\n *                                              *\r\n ************************************************/\r\n    media\r\n      .on('mousemove', ()=>_showControls(), passive?{passive:true}:false)\r\n      .on('loadedmetadata', ()=>{\r\n        let myFormat = this.params.format = media.videoWidth / media.videoHeight\r\n        //Actualisation de la taille du container en fonction du format réel de la vidéo\r\n        if (AmstramgramVideoPlayer.currentFullScreenPlayer == self) {\r\n          w.dispatchEvent(new CustomEvent('optimizedResize'))\r\n        } else {\r\n          container.style.paddingBottom = 1 / myFormat * 100 + '%'\r\n        }\r\n        container.classList.add('amst__loadedmetadata')\r\n        //Si le lecteur a été reseté du fait du lancement d'un autre lecteur\r\n        //on replace la tête de lecture au temps où elle s'était arrétée\r\n        media.currentTime = floorCurrentTime\r\n      })\r\n      .on('loadeddata', ()=>{\r\n        //Pour iOS sur reset du player\r\n        media.currentTime = floorCurrentTime\r\n      })\r\n      .on('durationchange', ()=>{\r\n        this.params.duration = media.duration\r\n        //Mise à jour de skipTime\r\n        skipTime = (typeof(this.params.skipTime)=='string' && this.params.skipTime.slice(-1)=='%')?parseFloat(this.params.skipTime) * media.duration / 100:parseFloat(this.params.skipTime)\r\n        //Mise à jour des champs indicateurs de temps\r\n        if (media.duration >= 3600) {//Si la durée du media est supérieure à 1 heure\r\n          //La classe amst__long augmente la largeur des containers indicateurs de temps\r\n          container.classList.add('amst__long')\r\n        } else {\r\n          container.classList.remove('amst__long')\r\n        }\r\n        slider.setAttribute('aria-valuemax', media.duration)\r\n        $('.amst__duration').innerHTML = secondsToTimeCode(media.duration)\r\n        $('.amst__currenttime').innerHTML = secondsToTimeCode(floorCurrentTime, (media.duration > 3600))\r\n        //On reprend une mesure des contrôles au cas où le container ait gagné ou perdu la class amst__long \r\n        getControlsElementsWidth()\r\n      })\r\n      .on('progress', updateBuffer)//Mise à jour du canvas indicateur de buffering\r\n      .on('timeupdate', ()=>{\r\n        //L'évènement est aussi déclenché lorsqu'on reset la source du media,\r\n        //ce qui se produit au reset du player effectué suite au lancement de la lecture d'un autre player.\r\n        //Dans ce cas, la propriété duration du media n'est pas définie.\r\n        if (isNaN(media.duration)) return\r\n        updateBuffer()//Mise à jour du canvas indicateur de buffering\r\n        slider.setAttribute('aria-valuenow', media.currentTime)\r\n        let mediaFloorCurrentTime = Math.floor(media.currentTime)\r\n        if (floorCurrentTime != mediaFloorCurrentTime) {\r\n          //On n'actualise le champs indicateur du temps courant que si nécessaire\r\n          //c'est à dire si l'arrondi à la seconde du temps courant diffère de celui qu'on a précédemment pris soin d'enregistrer\r\n          floorCurrentTime = mediaFloorCurrentTime\r\n          let time = secondsToTimeCode(floorCurrentTime, (media.duration > 3600))\r\n          $('.amst__currenttime').innerHTML = time\r\n          slider.setAttribute('aria-valuetext', time)\r\n        }\r\n        if (prevCurrentTime == 0 || Math.abs(media.currentTime - prevCurrentTime) > 0.5) {\r\n          cancelAnimationFrame(updateTimeRailAnimation)\r\n          updateTimeRail()\r\n        }\r\n        prevCurrentTime = media.currentTime\r\n      })\r\n      .on('ended', ()=>{\r\n        media.currentTime = 0\r\n        this.pause()\r\n      })\r\n      .on('pause', ()=>cancelAnimationFrame(updateTimeRailAnimation))\r\n      .on('playing', ()=>{\r\n        //On force la fonction updateTimeRail en passant prevCurrentTime à 0.\r\n        prevCurrentTime = 0\r\n        layerPoster.classList.add('amst__hidden')\r\n      })\r\n      .on('seeked', ()=>{\r\n        //L'évènement est ausssi déclenché à la suite de l'évènement ended.\r\n        //Dans ce cas, currentTime vaut 0, la vidéo est en pause et on affiche le poster\r\n        if (floorCurrentTime == 0 && this.paused) {\r\n          layerPosterCanvas.width = 0\r\n          layerPosterCanvas.height = 0\r\n          layerPoster.classList.remove('amst__hidden')\r\n        }\r\n      })\r\n      .on('play playing seeked canplay', ()=>{\r\n        isBuffering = false\r\n        container.classList.remove('amst__buffering')\r\n      })\r\n      .on('seeking waiting loadeddata', ()=>{\r\n        isBuffering = true\r\n        container.classList.add('amst__buffering')\r\n      })\r\n/************************************************\r\n *                                              *\r\n *             FIN ÉVÈNEMENTS MEDIA             *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                 UPDATEBUFFER                 *\r\n *                                              *\r\n ************************************************/\r\n    //Initialisation du canvas indicateur de buffering\r\n    const loadedBar = $('.amst__loaded-bar'),\r\n          loadedBarHeight = loadedBar.offsetHeight\r\n    let ctxLoadedBar = loadedBar.getContext('2d')\r\n    loadedBar.height = loadedBarHeight\r\n    ctxLoadedBar.fillStyle = loadedBar.css('color')\r\n    //Mise à jour du canvas indicateur de buffering appelée sur les évènements progress et timeupdate\r\n    function updateBuffer(){\r\n      //Comparaison de deux objets TimeRanges\r\n      function compareTimeRanges(t1, t2){\r\n        if (!t1 || !t2 || t1.length != t2.length) {\r\n          //Si l'un des objets n'existe pas ou si leurs longueurs diffèrent, on renvoie false\r\n          return false\r\n        } else {\r\n          for (let i = 0; i < t1.length; i++) {\r\n            //Comparaison de chacun des éléments contenus dans les TimeRanges\r\n            //Si on trouve une différence, on arrete et on renvoie false\r\n            if (t1.start(i) != t2.start(i) || t1.end(i) != t2.end(i)) {\r\n              i = t1.length\r\n              return false\r\n            }\r\n          }\r\n        }\r\n        return true\r\n      }\r\n      //Si le timeRanges renvoyé par la propriété buffered du média est différent de celui déjà enregistré\r\n      //On actualise le canvas indicateur de buffering\r\n      if (!compareTimeRanges(media.buffered, buffered)) {\r\n        ctxLoadedBar.clearRect(0, 0, loadedBar.width, loadedBar.height)\r\n        let inc = loadedBar.width / media.duration\r\n        for (let i = 0; i < media.buffered.length; i++) {\r\n          let start = media.buffered.start(i) * inc,\r\n              width = (media.buffered.end(i) * inc) - start\r\n          new AmstRoundedRect(ctxLoadedBar, loadedBarHeight, start, width)\r\n        }\r\n        buffered = media.buffered\r\n      }\r\n    }\r\n/************************************************\r\n *                                              *\r\n *              FIN UPDATEBUFFER                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *               UPDATETIMERAIL                 *\r\n *                                              *\r\n ************************************************/\r\n    //On fixe le scaleX de timeCurrent à la valeur correspondant au ratio : currentTime/duration\r\n    //Pour handle, on réalise l'opération équivalente en jouant sur la valeur de son translateX.\r\n    //Si le media est en lecture, on réitère l'opération via un requestAnimationFrame\r\n    //On enregistre le rayon de handle\r\n    let handleRadius = 0.5 * handle.offsetWidth\r\n    function updateTimeRail(){\r\n      let trans = (media.paused && !media.seeking)?'all .15s ease-in':'none',\r\n          t = media.currentTime,\r\n          T = media.duration,\r\n          //Si la source change, media.duration risque de ne pas être définie.\r\n          //Dans ce cas, ratio vaut 0\r\n          ratio = isNaN(T)?0:(t / T).toFixed(4),\r\n          translate = (ratio * sliderWidth) - handleRadius\r\n      translate = Math.max(translate, 0)\r\n      translate = Math.min(translate, sliderWidth - 2 * handleRadius) + 'px'\r\n      if (media.paused) {\r\n        //Mise à jour de timeCurrent\r\n        timeCurrent.css({[transitionPrefix]:trans, [transformPrefix]:`scaleX(${ratio})`})\r\n        //Mise à jour de handle\r\n        handle.css({[transitionPrefix]:trans, [transformPrefix]:`translateX(${translate})`})\r\n      } else {\r\n        //Mise à jour de timeCurrent\r\n        timeCurrent.css({[transitionPrefix]:trans, [transformPrefix]:`scaleX(${ratio})`})\r\n        //Mise à jour de handle\r\n        handle.css({[transitionPrefix]:trans, [transformPrefix]:`translateX(${translate})`})\r\n        updateTimeRailAnimation = requestAnimationFrame(updateTimeRail)\r\n      }\r\n    }\r\n/************************************************\r\n *                                              *\r\n *             FIN UPDATETIMERAIL               *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *         ÉVTS TACTILES SUR LA VIDÉO           *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n    À la suite d'un évènement 'touchstart', on place un écouteur sur l'évènement 'touchend'\r\n    Cet écouteur est retiré si un évènement touchmove est déclenché.\r\n    Si la vidéo est en pause :\r\n      - on affiche le gros bouton Play au centre et la barre de contrôle.\r\n      - un tap passe la vidéo en lecture, le gros bouton Play est caché \r\n          et la barre de contrôle disparait au bout d'un temps défini par l'option hideControlsDelay.\r\n      - un slide horizontal affiche le seeking et, le cas échéant, la vignette \r\n          mais fait disparaitre la barre de controle.\r\n          Celle-ci réapparait à la fin du slide, la vidéo reste en pause et sa tête de lecture est positionnée\r\n          au temps correspondant à l'endroit où le slide a cessé.\r\n    Si la vidéo est en lecture :\r\n      - un tap passe la vidéo en pause et on affiche le gros bouton Play ainsi que la barre de contrôle.\r\n      - si la barre de contrôle est apparente, un slide vertical vers le bas la fait disparaitre.\r\n      - si la barre de contrôle est cachée, un slide vertical vers le haut la fait apparaitre.\r\n      - un slide horizontal affiche le seeking et, le cas échéant, la vignette. Si elle est apparente, la barre de contrôle est cachée.\r\n          À la fin du slide, la lecture reprend au temps correspondant à l'endroit où le slide a cessé.\r\n    */\r\n    $$([media, layerLoading, layerSeekingTouch, layerPlay])\r\n      .on('touchstart', function(e){\r\n        const target = $(e.target),\r\n              startTime = new Date().getTime(),\r\n              //Durée maximale, exprimée en ms, comprise entre touchstart et touchend pour que \r\n              //l'évènement résultant soit considéré comme un click si aucun touchmove n'a été détecté.\r\n              maxDelay = 800,\r\n              //Position temporelle exprimée en pourcentage par rapport à la durée du média\r\n              timeRatio = (media.duration)?media.currentTime/media.duration:undefined\r\n        let startX = e.changedTouches[0].pageX,//Abscisse de l'évènement\r\n            startY = e.changedTouches[0].pageY,//Ordonnée de l'évènement\r\n            distX = 0,//Variable destinée à stocker la distance parcourue sur l'axe X\r\n            distY = 0,//Variable destinée à stocker la distance parcourue sur l'axe Y\r\n            //Variable incrémentée d'un pas à chaque fois qu'on détecte un déplacement horizontal\r\n            //et décrémentée d'un pas à chaque fois qu'on détecte un déplacement vertical\r\n            horizontalMove = 0,\r\n            seekingRatio = undefined,//Variable définie uniquement dans le cas d'un déplacement horizontal\r\n            toggleControls = false//Variable passant à true s'il s'agit d'un déplacement vertical\r\n        target.on('touchend', touchEnd, passive?{passive:true}:false)\r\n        target.on('touchmove', touchMove, passive?{passive:false}:false)\r\n        function touchMove(e){\r\n          //Si la vidéo n'est pas chargée et n'a donc pas de durée définie\r\n          //Ou si la vidéo est en pause et qu'on a détecté un swipe vertical,\r\n          //on ne fait rien.\r\n          //Ainsi, s'il s'agit d'un swipe vertical, on ne bloque pas le scroll.\r\n          if (!media.duration || (self.paused && horizontalMove < -5)) return\r\n          //Dans tous les autres case, on bloque le scroll éventuel.\r\n          e.preventDefault()\r\n          //Mesure des distances\r\n          distX = e.changedTouches[0].pageX - startX\r\n          distY = e.changedTouches[0].pageY - startY\r\n          //Mise à jour de horizontalMove en fonction du mouvement détecté\r\n          if (Math.abs(distX) > Math.abs(distY)) {//Horizontal\r\n            horizontalMove ++\r\n          } else {//Vertical\r\n            horizontalMove --\r\n          }\r\n          if (horizontalMove >= 5) {//Si le mouvement horizontal se confirme\r\n            seekingRatio = Math.min(Math.max(timeRatio + (distX / playerWidth),0),0.999)\r\n            if (!seekingTouchWidth) seekingTouchWidth = seekingTouch.offsetWidth\r\n            const translate = Math.min(Math.max(seekingRatio * playerWidth - 0.5 * seekingTouchWidth, 0), playerWidth - seekingTouchWidth) + 'px'\r\n            let css = {[transformPrefix]:`translateX(${translate})`}\r\n            if (self.params.thumbnails.src) {\r\n              css['backgroundPosition'] = - Math.floor(seekingRatio * 100) * thumbWidth + 'px 0'\r\n            }\r\n            seekingTouch.css(css)\r\n            $('.amst__seeking-touch-cache').style[transformPrefix] = `scaleX(${seekingRatio})`\r\n            $('.amst__seeking-touch > span').innerHTML = secondsToTimeCode(media.duration * seekingRatio, (media.duration > 3600))\r\n            if (horizontalMove == 5) {\r\n              //On affiche le layer seeking\r\n              layerSeekingTouch.classList.add('amst__show')\r\n              //on cache la barre de contrôle sans délai et ce même si la vidéo est en pause\r\n              _hideControls({detail:{delayed: false, forced:true}})\r\n            }\r\n          }\r\n          if (-5 == horizontalMove) {//Si le mouvement vertical se confirme\r\n            toggleControls = true\r\n            if (distY < 0) {\r\n              _showControls()\r\n            } else {\r\n              _hideControls()\r\n            }\r\n          }\r\n        }\r\n        function touchEnd(){\r\n          if (seekingRatio != undefined) {//Si seeking et donc swipe horizontal\r\n            //On place la tête de lecture au temps résultant\r\n            media.currentTime = media.duration * seekingRatio\r\n            //On cache le layer seeking\r\n            layerSeekingTouch.classList.remove('amst__show')\r\n            _showControls()\r\n          } else if (!toggleControls) {//Si aucun mouvement n'a été détecté\r\n            //Si le touchend intervient avant le délai maximum défini par maxDelay\r\n            if (maxDelay > new Date().getTime() - startTime) {\r\n              //On bascule entre pause et lecture\r\n              self.togglePlayPause()\r\n            } /*else { TODO : afficher le menu contextuel\r\n              showMenu()\r\n            }*/\r\n          }\r\n          target.off('touchend', touchEnd)\r\n          target.off('touchmove', touchMove)\r\n        }\r\n      }, passive?{passive:false}:false)\r\n/************************************************\r\n *                                              *\r\n *        FIN ÉVTS TACTILES SUR LA VIDÉO        *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                ÉVTS GÉNÉRAUX                 *\r\n *                                              *\r\n ************************************************/\r\n    //Si l'on est pas sur un écran tactile, un click sur la vidéo passe celle-ci en pause\r\n    //même si un buffering est en cours.\r\n    $$([media, layerLoading]).on('click', ()=>this.pause(), false)\r\n    //Tout évènement souris provoque l'ajout de la classe 'keyboard-inactive' au container\r\n    //Cette classe empêche l'affichage d'une bordure sur les éléments qui ont le focus\r\n    container.on('touchstart mousedown', ()=>{container.classList.remove('amst__keyboard-active')}, passive?{passive:true}:false)\r\n    // Un click sur le bouton Play/Pause déclenche une bascule Play/Pause   \r\n    $('.amst__playpause').on('click', ()=>this.togglePlayPause())\r\n    //Un click sur le gros bouton Play au centre de la vidéo déclenche une lecture \r\n    layerPlay.on('click', ()=>this.play())\r\n/************************************************\r\n *                                              *\r\n *               FIN ÉVTS GÉNÉRAUX              *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *         AFFICHER/CACHER LES CONTRÔLES        *\r\n *                                              *\r\n ************************************************/\r\n    //Si le pointeur est sur la barre de contrôle, on bloque la disparition de la barre\r\n    //S'il sort de la zone, on rétablit la disparition\r\n    //Rien ne se passe si l'on est sur tactile\r\n    controls\r\n      .on(myPointerEnter, (e)=>{\r\n        if (myPointerType == 'touch' || (e.pointerType && e.pointerType == 'touch')) return false\r\n        _showControls()\r\n        pointerOverControls = true\r\n      })\r\n      .on(myPointerLeave, (e)=>{\r\n        if (myPointerType == 'touch' || (e.pointerType && e.pointerType == 'touch')) return false\r\n        pointerOverControls = false\r\n        _hideControls({detail:{delayed:true}})\r\n      })\r\n/************************************************\r\n *                                              *\r\n *      FIN AFFICHER/CACHER LES CONTRÔLES       *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *             ÉVÉNEMENTS SUR RAIL              *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n    Afin de faciliter la vie du visiteur, le rail dispose d'une hauteur de 35px.\r\n    Un clic ou un move amène le curseur à la position de l'évènement\r\n    et la tête de lecture de vidéo au temps correspondant.\r\n    On pose un écouteur sur l'évènement myPointerDown qui correspond à mousedown sur desktop\r\n    et à touchstart sur tactile.\r\n    */\r\n    rail.on(myPointerDown, ()=>{\r\n      //Si la vidéo n'est pas chargée, on abandonne...\r\n      if (isNaN(media.duration)) return false\r\n      //Sinon, on pose un écouteur sur l'évènement myPointerMove (mousemove/touchmove)\r\n      //et un autre sur myPointerUp (mouseup/touchend) et mypointerLeave (mouseleave)\r\n      rail.on(myPointerMove, moveHandle, passive?{passive:true}:false)\r\n      rail.on(myPointerUp + ' ' +  myPointerLeave, cleanTimeSliderMoveEvents, false)\r\n    }, passive?{passive:true}:false)\r\n    function moveHandle(e) {\r\n      //On détermine l'abscisse de la position où l'évènement se produit\r\n      //et on en déduit la position temporelle résultante de la tête de lecture\r\n      let eventX = (e.changedTouches)?e.changedTouches[0].clientX:e.clientX,\r\n          x = eventX - sliderLeft,\r\n          translate = x / sliderWidth\r\n      media.currentTime = translate * media.duration\r\n    }\r\n    function cleanTimeSliderMoveEvents(e){\r\n      //Si la vidéo n'est pas en pause et que le pointeur ne survole plus la barre de contrôle,\r\n      //on programme la disparition de ladite barre.\r\n      if (!self.paused && !pointerOverControls) _hideControls({detail:{delayed:true}})\r\n      //On opère le déplacement de la tête de lecture ce qui provoque celui du curseur\r\n      moveHandle(e)\r\n      //On retire les écouteurs.\r\n      rail.off(myPointerMove, moveHandle)\r\n      rail.off(myPointerUp + ' ' +  myPointerLeave, cleanTimeSliderMoveEvents)\r\n    }\r\n/************************************************\r\n *                                              *\r\n *           FIN ÉVÉNEMENTS SUR RAIL            *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *         ÉVÉNEMENTS SOURIS SUR SLIDER         *\r\n *                                              *\r\n ************************************************/\r\n    //Lorsque la souris survole la barre de lecture, on fait apparaître le curseur\r\n    //indiquant la position temporelle correspondante ainsi que la vignette si thumbnails.src est défini.\r\n    throttle(myPointerMove, 'optimizedPointerMove', slider)\r\n    //L'élément seeking se déplace avec le pointeur et on actualise son contenu affiché en conséquence\r\n    slider.on('optimizedPointerMove', (e)=>{\r\n      //Si l'évènement est de source tactile ou que la vidéo n'est pas chargée, on l'ignore\r\n      if (myPointerType == 'touch' || (e.pointerType && e.pointerType == 'touch') || isNaN(media.duration)) return false\r\n      //Si la largeur de l'élément seeking n'a pas encore été déterminée,\r\n      //on initialise la variable seekingWidth\r\n      if (!seekingWidth) seekingWidth = seeking.offsetWidth\r\n      let seekingWrapperPosition = e.detail.clientX - sliderLeft\r\n      const seekingRatio = seekingWrapperPosition / sliderWidth,\r\n            thumbBackgroundPosition = - Math.floor(seekingRatio * 100) * thumbWidth + 'px',\r\n            seekingWrapperHalfWidth = 0.5 * seekingWidth - 6\r\n      if (self.params.thumbnails.src) seeking.style.backgroundPosition = thumbBackgroundPosition + ' 0'\r\n      $('.amst__cursor').style[transformPrefix] = `translateX(${seekingWrapperPosition}px)`\r\n      //On fait en sorte que le wrapper ne déborde pas aux extrémités de la barre temporelle\r\n      seekingWrapperPosition = Math.max(seekingWrapperPosition, seekingWrapperHalfWidth)\r\n      seekingWrapperPosition = Math.min(seekingWrapperPosition, sliderWidth - seekingWrapperHalfWidth)\r\n      $('.amst__seeking-wrapper').style[transformPrefix] = `translateX(${seekingWrapperPosition}px)`\r\n      $('.amst__seeking > span').innerHTML = secondsToTimeCode(seekingRatio * media.duration, (media.duration > 3600))\r\n    })\r\n/************************************************\r\n *                                              *\r\n *            FIN SOURIS SUR SLIDER             *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                 VOLUMECHANGE                 *\r\n *                                              *\r\n ************************************************/\r\n    media.on('volumechange', ()=>{\r\n      if (!IS_MOBILE) {\r\n        const vol = parseInt(media.volume * 100)\r\n        volumeSlider.setAttributes({\r\n          'aria-valuenow': vol,\r\n          'aria-valuetext': vol + '%',\r\n        })\r\n        if (videoVolumeOrientation == 'horizontal') {\r\n          $('.amst__volume-current').style.width = vol + '%'\r\n        } else {\r\n          $('.amst__volume-handle').style.bottom = vol + '%'\r\n        }\r\n      }\r\n      //Mise à jour en cas de mute/demute\r\n      if (media.volume == 0) {\r\n        media.muted = true\r\n        volumeButton.setAttributes({\r\n          title: self.params.volumeButton.label.unmute,\r\n          'aria-label': self.params.volumeButton.label.unmute,\r\n          class: 'amst__unmute'\r\n        })\r\n      } else {\r\n        media.muted = false\r\n        volumeBeforeMute = media.volume\r\n        if (volumeButton.classList.contains('amst__unmute')) {\r\n          volumeButton.removeAttribute('class')\r\n          volumeButton.setAttributes({\r\n            title: self.params.volumeButton.label.mute,\r\n            'aria-label': self.params.volumeButton.label.mute,\r\n          })\r\n        }\r\n      }\r\n      //Stockage du volume pour le groupe correspondant\r\n      if (storage && self.params.volumeGroup > 0) {\r\n        storage.setItem(`amst_volumegroup${self.params.volumeGroup}`, self.volume)\r\n      }\r\n      self.params.volume = self.volume\r\n      //Propagation du changement de volume au éventuels autres players du même volumeGroup\r\n      if (self.params.volumeGroup > 0 && AmstramgramVideoPlayer.players.length > 1) {\r\n        AmstramgramVideoPlayer.players.forEach((player)=>{\r\n          if (player != self && player.params.volumeGroup == self.params.volumeGroup && player.volume != self.volume) {\r\n            player.volume = self.volume\r\n          }\r\n        })\r\n      }\r\n    })\r\n/************************************************\r\n *                                              *\r\n *              FIN VOLUMECHANGE                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *             VOLUME CLICK SUR HP              *\r\n *                                              *\r\n ************************************************/\r\n    volumeButton.on('click', ()=>{\r\n      if (media.muted) {\r\n        media.volume = volumeBeforeMute\r\n        media.muted = false\r\n      } else {\r\n        media.volume = 0\r\n        media.muted = true\r\n      }\r\n    })\r\n/************************************************\r\n *                                              *\r\n *           FIN VOLUME CLICK SUR HP            *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *   VOLUME POTENTIOMÈTRE - SOURIS & CLAVIER    *\r\n *                                              *\r\n ************************************************/\r\n    if (!IS_MOBILE) {\r\n      volumeSlider.on(myPointerDown,()=>{\r\n        volumeSlider\r\n          .on(myPointerMove, updateVolume)\r\n          .on(myPointerLeave, cleanVolumeEvents)\r\n          .on(myPointerUp, updateVolume)\r\n          .on(myPointerUp, cleanVolumeEvents)\r\n      })\r\n      const updateVolume = function(e){\r\n        let ratio\r\n        if (videoVolumeOrientation == 'horizontal') {\r\n          ratio = Math.max(0, e.clientX - volumeRect.left)\r\n          ratio =  ratio / volumeRect.width\r\n          ratio = (ratio > 0.96)?1:ratio\r\n        } else {\r\n          volumeSlider.style.cursor = 'ns-resize'\r\n          ratio = volumeRect.height - e.clientY + volumeRect.top\r\n          ratio = Math.max(0 ,Math.min(ratio, 100)) / 100\r\n        }\r\n        self.volume = ratio\r\n      }\r\n      const cleanVolumeEvents = function(){\r\n        volumeSlider\r\n          .off(myPointerMove, updateVolume)\r\n          .off(myPointerLeave, cleanVolumeEvents)\r\n          .off(myPointerUp, updateVolume)\r\n          .off(myPointerUp, cleanVolumeEvents)\r\n        if (videoVolumeOrientation == 'vertical') {\r\n          volumeSlider.style.cursor = ''\r\n        }\r\n      }\r\n      //évènements clavier\r\n      container.on('keydown', function(e){\r\n        container.classList.add('amst__keyboard-active')\r\n        _showControls()\r\n        if ([37,38,39,40,77].includes(e.which)) e.preventDefault()\r\n        if (e.which > 36 && e.which < 41) {\r\n          if ((e.which == 38 || e.which == 40) && d.activeElement != volumeSlider) {\r\n            if (videoVolumeOrientation == 'vertical') {\r\n              volumeSlider.on('transitionend', function onTransitionEnd(){\r\n                this.removeEventListener('transitionend', onTransitionEnd)\r\n                this.focus()\r\n              })\r\n              volumeButton.focus()\r\n            } else volumeSlider.focus();\r\n          }\r\n          if ((e.which == 37 || e.which == 39) && d.activeElement != slider) {\r\n            slider.focus()\r\n          }\r\n        }\r\n        switch (e.which) {\r\n          case 77://M->Mute/Unmute\r\n            if (self.params.volumeButton.disabled !== true && self.params.volumeButton.hidden !== true) {\r\n              volumeButton.dispatchEvent(new MouseEvent('click'))\r\n              volumeButton.focus()\r\n            }\r\n            break\r\n          case 40://Arrow Down\r\n            if (self.params.volumeButton.disabled !== true && self.params.volumeButton.hidden !== true) {\r\n              self.volume = Math.max(0, self.volume - 0.05)\r\n            }\r\n            break\r\n          case 38://Arrow Up\r\n            if (self.params.volumeButton.disabled !== true && self.params.volumeButton.hidden !== true) {\r\n              self.volume = Math.min(1, self.volume + 0.05)\r\n            }\r\n            break\r\n          case 37://Arrow Left\r\n            self.currentTime = Math.max(0, self.currentTime - skipTime)\r\n            break\r\n          case 39://Arrow Right\r\n            self.currentTime = Math.min(self.duration, self.currentTime + skipTime)\r\n            break\r\n          case 32://Space\r\n            if (d.activeElement == playPauseButton) {\r\n              return\r\n            } else if (d.activeElement.nodeName != 'BUTTON') {\r\n              e.preventDefault()\r\n              self.togglePlayPause()\r\n            }\r\n            break\r\n        }\r\n      }, false)\r\n    }\r\n/************************************************\r\n *                                              *\r\n *          FIN VOLUME POTENTIOMÈTRE            *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                 FULLSCREEN                   *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n    Lorsqu'on passe en plein écran, les propriétés pageXOffset et pageYOffset de window sont modifiées.\r\n    Si l'on ne prend pas de précautions, à la sortie du plein écran, la page aura perdu son scroll initial.\r\n    On intialise donc deux variables scrollX et scrollY dans lesquelles on stockera les valeurs de scroll\r\n    avant le passage en plein écran pour pouvoir les rétablir à la sortie.\r\n    Au passage en mode plein écran, on pose un écouteur spécifique sur l'événement resize.\r\n    Dans ce mode, le display du wrapper passe en flex et on pose un margin:auto sur le container\r\n    afin d'assurer son centrage horizontal et vertical.\r\n    Si l'écran est plus large que la vidéo, le container est centré horizontalement, sa hauteur est fixée à 100%, \r\n    son padding-bottom est annulé et sa largeur est déterminée grâce au format de la vidéo.\r\n    Dans le cas contraire, le container est centré verticalement, son padding-bottom est donné par le format de la vidéo et sa largeur fixée à 100%.\r\n    À la sortie du plein écran, on assure un nettoyage des styles ajoutés.\r\n    */\r\n    if (fullscreenAPI) {\r\n      let scrollX = 0, \r\n          scrollY = 0\r\n      const fullScreenButton = $('.amst__fullscreen>button')\r\n      fullScreenButton.on('click', ()=>{\r\n        if (d[fullscreenAPI.fullscreenElement] !== null) {//On est en mode plein écran\r\n          //On en sort\r\n          d[fullscreenAPI.exitFullscreen]()\r\n        } else {//On n'est pas en mode plein écran\r\n          //On mémorise la position dans la page pour pouvoir la rétablir à la sortie du plein écran\r\n          scrollX = w.pageXOffset\r\n          scrollY = w.pageYOffset\r\n          //On passe en plein écran\r\n          wrapper[fullscreenAPI.requestFullscreen]()\r\n          // container[fullscreenAPI.requestFullscreen]()\r\n          //On initialise la propriété currentFullScreenPlayer de la class\r\n          AmstramgramVideoPlayer.currentFullScreenPlayer = self\r\n        }\r\n      })\r\n      //Ecoute de l'évènement fullscreenchange\r\n      d.addEventListener(fullscreenAPI.fullscreenchange, function(){\r\n        if (d[fullscreenAPI.fullscreenElement] == wrapper) {//Si le player passe en plein écran\r\n          //Écoute du resize\r\n          w.addEventListener('optimizedResize', resizeFullScreen)\r\n          wrapper.classList.add('amst__isfullscreen')\r\n          //On enlève la transition sur la padding du container\r\n          container.classList.add('amst__notransition')\r\n          //Mise à jour du bouton et de ses labels\r\n          fullScreenButton.setAttributes({\r\n            title: exitFullScreenLabel,\r\n            'aria-label': exitFullScreenLabel,\r\n            class:' amst__unfullscreen'\r\n          })\r\n          resizeFullScreen()\r\n        } else if (AmstramgramVideoPlayer.currentFullScreenPlayer == self){//Si le player sort du plein écran\r\n          //On retire l'écouteur sur le resize\r\n          w.removeEventListener('optimizedResize', resizeFullScreen)\r\n          //On reset les dimensions éventuellement spécifiées par la fonction resizeFullScreen\r\n          container.setAttribute('style',`padding-bottom:${1 / self.params.format * 100}%`)\r\n          wrapper.classList.remove('amst__isfullscreen')\r\n          //Mise à jour du bouton et de ses labels\r\n          fullScreenButton.setAttributes({\r\n            title: enterFullScreenLabel,\r\n            'aria-label': enterFullScreenLabel,\r\n            class: ''\r\n          })\r\n          //On se repositionne sur la page\r\n          setTimeout(()=>{\r\n            w.scroll(scrollX, scrollY)\r\n            //On remet la transition sur le padding du container\r\n            setTimeout(()=>{container.classList.remove('amst__notransition')},50)\r\n          },50)\r\n          //On reset la propriété currentFullScreenPlayer de la class\r\n          AmstramgramVideoPlayer.currentFullScreenPlayer = undefined\r\n        }\r\n      }, false);\r\n      const resizeFullScreen = function() {\r\n        if (w.innerWidth / w.innerHeight > self.params.format) {//Si l'écran est plus large que la vidéo\r\n          container.css({\r\n            width: w.innerHeight * self.params.format + 'px',\r\n            height: '100%',\r\n            'paddingBottom': 0\r\n          })\r\n        } else {\r\n          container.css({\r\n            width: '100%',\r\n            height: 'auto',\r\n            'paddingBottom': 1 / self.params.format * 100 + '%'\r\n          })\r\n        }\r\n        resize()\r\n      }\r\n    }\r\n/************************************************\r\n *                                              *\r\n *                FIN FULLSCREEN                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                    RESIZE                    *\r\n *                                              *\r\n ************************************************/\r\n    /*\r\n    On effectue une mesure des éléments HTML\r\n    Cette opération est pondérée par un setTimeout afin d'éviter les redondances.\r\n    Elle est en effet appelée à chaque fois qu'un bouton est mis à jour.\r\n    Si plusieurs boutons sont modifiés en même temps, elle n'est ainsi effectuée qu'une fois.\r\n    */\r\n    function getControlsElementsWidth(){\r\n      if (timeoutGetControlsElementsWidth) clearTimeout(timeoutGetControlsElementsWidth)\r\n      timeoutGetControlsElementsWidth = setTimeout(function(){\r\n        controlsElementsWidth = 0\r\n        $$('.amst__controls>div:not(.amst__rail):not(.amst__hidden):not(.amst__time-duration)').forEach(el=>{\r\n          if (el.classList.contains('amst__time')) {\r\n            controlsElementsWidth += (2 * el.offsetWidth)\r\n          } else {\r\n            controlsElementsWidth += el.offsetWidth\r\n          }\r\n        })\r\n      resize()\r\n      },1)\r\n    }\r\n    \r\n    w.addEventListener('optimizedResize', resize)\r\n    w.addEventListener('optimizedScroll', resize)\r\n\r\n    function resize(){\r\n      playerWidth = container.offsetWidth\r\n      if (playerWidth - controlsPadding - controlsElementsWidth < AmstramgramVideoPlayer.defaultOptions.railMinWidthForNormalUI) {\r\n        container.classList.add('amst__compact')\r\n      } else {\r\n        container.classList.remove('amst__compact')\r\n      }\r\n      let sliderRect = slider.getBoundingClientRect()\r\n      sliderLeft = sliderRect.left\r\n      sliderWidth = sliderRect.width\r\n      updateTimeRail()\r\n      //Si le format de la source est modifiée, l'abscisse du potentiomètre de volume en mode vertical \r\n      //ne sera fixée qu'à la fin de l'animation posée sur le padding-bottom du container.\r\n      if (!IS_MOBILE) {\r\n        const updateVolumeRect = function(e) {\r\n          volumeRect = $('.amst__volume-total').getBoundingClientRect()\r\n          if (e && e.target == container) {\r\n            container.off('transitionend', updateVolumeRect)\r\n          }\r\n        }\r\n        container.on('transitionend', updateVolumeRect, false)\r\n        updateVolumeRect()\r\n      }\r\n    }\r\n/************************************************\r\n *                                              *\r\n *                  FIN RESIZE                  *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                 FINALISATION                 *\r\n *                                              *\r\n ************************************************/\r\n    if (params && typeof params.oninit === \"function\") {\r\n      setTimeout(function(){params.oninit(self)},1)\r\n    }\r\n\r\n    //La fonction pointerDetected() écoute l'évènement 'pointerDetected' dispatché par la class\r\n    //lorsque le type de pointeur a été détecté.\r\n    function pointerDetected(){\r\n      container.removeEventListener('pointerDetected', pointerDetected)\r\n      if (_pointerType != 'touch') container.classList.add('amst__no-touch')\r\n    }\r\n    //Si la class n'a pas encore détecté le type de pointeur, on se prépare à réagir à sa future détection\r\n    if (_pointerType == 'unknown') {\r\n      container.addEventListener('pointerDetected', pointerDetected, false)\r\n    } else if (_pointerType != 'touch') {\r\n      container.classList.add('amst__no-touch')\r\n    }\r\n    //On ajoute l'instance dans le tableau regroupant toutes les autres instances de players\r\n    AmstramgramVideoPlayer.players.push(this)\r\n  }\r\n/************************************************\r\n *                                              *\r\n *                  FIN RESIZE                  *\r\n *               FIN CONSTRUCTOR                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                GETTERS/SETTERS               *\r\n *                                              *\r\n ************************************************/\r\n  set src(src){\r\n    /*\r\n    src est :\r\n      - soit une chaine renvoyant vers la source vidéo\r\n      - soit un objet de la forme \r\n        {\r\n          src: 'chemin du fichier vidéo',\r\n          format: 'rapport largeur/hauteur de la vidéo',\r\n          poster: 'chemin du fichier poster',\r\n          volume: 'volume',\r\n          duration: 'durée de la vidéo en seconde',\r\n          skipTime: 'valeur de l'incrément temporel lorsque l'utilisateur appuie sur les flèches gauche ou droite de son clavier'\r\n          thumbnails: 'chemin du fichier des vignettes',\r\n          previous: objet,\r\n          next: objet,\r\n          fullscreen: objet,\r\n          download: objet,\r\n        }\r\n    */\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__src',{'detail': src}))\r\n  }\r\n  get src(){\r\n    return this.media.getAttribute('src')\r\n  }\r\n\r\n  get paused(){\r\n    return this.media.paused\r\n  }\r\n  get duration(){\r\n    return this.media.duration\r\n  }\r\n\r\n  set currentTime(t) {\r\n    if (this.media.duration && t >= 0 && t <= this.media.duration) {\r\n      this.media.currentTime = t\r\n    }\r\n  }\r\n  get currentTime(){\r\n    return this.media.currentTime\r\n  }\r\n\r\n  set volume(vol){\r\n    this.media.volume = vol\r\n  }\r\n  get volume(){\r\n    return this.media.volume\r\n  }\r\n/************************************************\r\n *                                              *\r\n *             FIN GETTERS/SETTERS              *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                  MÉTHODES                    *\r\n *                                              *\r\n ************************************************/\r\n  pause(){\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__pause'))\r\n  }\r\n\r\n  play(){\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__play'))\r\n  }\r\n\r\n  reset(){\r\n    this.pause()\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__reset'))\r\n  }\r\n \r\n  togglePlayPause(){\r\n    if (this.paused) {\r\n      this.play()\r\n    } else {\r\n      this.pause()\r\n    }\r\n  }\r\n\r\n  hideControls(delayed = false, forced = false){\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__hideControls',{'detail':{delayed: delayed, forced: forced}}))\r\n  }\r\n\r\n  showControls(){\r\n    this.container.dispatchEvent(new CustomEvent('amstEvent__showControls'))\r\n  }\r\n\r\n  previous(opt){\r\n    if (isObject(opt)) {\r\n      //Mise à jour des paramètres\r\n      this.params = mergeDeep(this.params, {previous:opt})\r\n      //Génération de l'événement qui va provoquer la mise à jour\r\n      this.container.dispatchEvent(new CustomEvent('amstEvent__previousButton'))\r\n    }\r\n  }\r\n  next(opt){\r\n    if (isObject(opt)) {\r\n      this.params = mergeDeep(this.params, {next:opt})\r\n      this.container.dispatchEvent(new CustomEvent('amstEvent__nextButton'))\r\n    }\r\n  }\r\n  fullscreen(opt){\r\n    if (isObject(opt)) {\r\n      this.params = mergeDeep(this.params, {fullscreen:opt})\r\n      this.container.dispatchEvent(new CustomEvent('amstEvent__fullscreenButton'))\r\n    }\r\n  }\r\n  download(opt){\r\n    if (isObject(opt)) {\r\n      this.params = mergeDeep(this.params, {download:opt})\r\n      this.container.dispatchEvent(new CustomEvent('amstEvent__downloadButton'))\r\n    }\r\n  }\r\n  volumeButton(opt){\r\n    if (isObject(opt)) {\r\n      this.params = mergeDeep(this.params, {volumeButton:opt})\r\n      this.container.dispatchEvent(new CustomEvent('amstEvent__volumeButton'))\r\n    }\r\n  }\r\n}\r\n/************************************************\r\n *                                              *\r\n *             FIN GETTERS/SETTERS              *\r\n *                  FIN CLASS                   *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *             PROPRIÉTÉS GLOBALES              *\r\n *                                              *\r\n ************************************************/\r\nAmstramgramVideoPlayer.currentPlayer = undefined\r\nAmstramgramVideoPlayer.players = []\r\nAmstramgramVideoPlayer.defaultOptions = {\r\n  autoplay: false,\r\n  crossorigin: 'anonymous',\r\n  download: {label:'Télécharger', disabled:false, hidden:false},\r\n  duration: 120,\r\n  format: 16/9,\r\n  fullscreen: {label:{enter:'Plein écran', exit:'Quitter le plein écran'}, disabled:false, hidden:false},\r\n  loop: false,\r\n  next: {label:'Suivant', disabled:true, hidden:true},\r\n  playsinline: true,\r\n  poster: undefined,\r\n  preload: 'none',\r\n  previous: {label:'Précédent', disabled:true, hidden:true},\r\n  skipTime: '1%',\r\n  thumbnails: {src:undefined, number:100},\r\n  volume: 0.8,\r\n  volumeButton: {label:{mute:'Désactiver le son', unmute:'Activer le son'}, disabled:false, hidden:false},\r\n  //Players properties\r\n  volumeGroup: 0,\r\n  hideControlsDelay: 5000,\r\n  videoVolumeOrientation: 'vertical',\r\n  railMinWidthForNormalUI: 600,\r\n  //Global properties\r\n  appLabel:'Lecteur Vidéo',\r\n  pauseLabel:'Pause',\r\n  playLabel:'Lecture',\r\n  volumeHelpLabel:'Utilisez les flèches Haut/Bas du clavier pour augmenter ou diminuer le volume.',\r\n  volumeSliderLabel:'Potentiomètre de volume',\r\n}\r\n/************************************************\r\n *                                              *\r\n *           FIN PROPRIÉTÉS GLOBALES            *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                   BUILDUI                    *\r\n *                                              *\r\n ************************************************/\r\nfunction buildUI(params){\r\n  let videoVolumeHTMLString = '',\r\n      volumeSliderHTMLString = ''\r\n  if (!IS_MOBILE) {\r\n    volumeSliderHTMLString = `\r\n      <div class=\"amst__volume-slider\" aria-label=\"${params.volumeSliderLabel}\" aria-valuemin=\"0\" aria-valuemax=\"100\" aria-valuenow=\"100\" aria-valuetext=\"100%\" role=\"slider\" aria-orientation=\"${params.videoVolumeOrientation}\" tabindex=\"0\" title=\"${params.volumeHelpLabel}\">\r\n        <span class=\"amst__offscreen\">${params.volumeHelpLabel}</span>\r\n        <div class=\"amst__volume-total\">\r\n          <div class=\"amst__volume-current\" style=\"height: 100%;\"></div>`\r\n    if(params.videoVolumeOrientation != 'horizontal') {\r\n      volumeSliderHTMLString += `<div class=\"amst__volume-handle\" style=\"bottom: 100%; margin-bottom: -3px;\"></div>`\r\n    }\r\n    volumeSliderHTMLString += `</div></div>`\r\n  }\r\n  videoVolumeHTMLString = `\r\n    <div class=\"amst__button amst__volumebutton\">\r\n      <button type=\"button\" tabindex=\"0\"></button>`\r\n  if (params.videoVolumeOrientation != 'horizontal') {\r\n    videoVolumeHTMLString += (volumeSliderHTMLString + '</div>')\r\n  } else {\r\n    videoVolumeHTMLString += ('</div>' + volumeSliderHTMLString)\r\n  }\r\n\r\n  let buildUIStr = `\r\n    <span class=\"amst__offscreen\">${params.appLabel}</span>\r\n    <div class=\"amst__container\" tabindex=\"0\" role=\"application\" aria-label=\"${params.appLabel}\">\r\n      <div class=\"amst__mediaelement\">\r\n        <video></video>\r\n      </div>\r\n    <div class=\"amst__layers\">\r\n      <div class=\"amst__layer-poster\">\r\n        <canvas></canvas>\r\n      </div>\r\n      <div class=\"amst__layer-loading\">\r\n        <div class=\"amst__loading\">\r\n          <span class=\"amst__svg\"></span>\r\n        </div>\r\n      </div>\r\n      <div class=\"amst__layer-play\">\r\n        <div class=\"amst__svg\" role=\"button\" tabindex=\"0\" aria-label=\"${params.playLabel}\" aria-pressed=\"false\"></div>\r\n      </div>\r\n      <div class=\"amst__layer-seeking-touch\">\r\n        <div class=\"amst__seeking-touch-cache\"></div>\r\n        <span class=\"amst__time amst__seeking-touch\">\r\n          <span></span>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"amst__controls\">\r\n      <div class=\"amst__button amst__previous\">\r\n        <button type=\"button\" title=\"${params.previous.label}\" aria-label=\"${params.previous.label}\" tabindex=\"0\"></button>\r\n      </div>\r\n      <div class=\"amst__button amst__playpause\">\r\n        <button type=\"button\" title=\"${params.playLabel}\" aria-label=\"${params.playLabel}\" tabindex=\"0\"></button>\r\n      </div>\r\n      <div class=\"amst__button amst__next\">\r\n        <button type=\"button\" title=\"${params.next.label}\" aria-label=\"${params.next.label}\" tabindex=\"0\"></button>\r\n      </div>\r\n      <div class=\"amst__time\" role=\"timer\" aria-live=\"off\">\r\n        <span class=\"amst__currenttime\">00:00</span>\r\n      </div>\r\n      <div class=\"amst__rail\">\r\n        <span class=\"amst__slider\" role=\"slider\" tabindex=\"0\">\r\n          <span class=\"amst__buffering-bar\"></span>\r\n          <canvas class=\"amst__loaded-bar\"></canvas>\r\n          <span class=\"amst__currenttime-bar\"></span>\r\n          <span class=\"amst__handle\"><span></span></span>\r\n          <span class=\"amst__cursor\"><span></span></span>\r\n          <span class=\"amst__seeking-wrapper\">\r\n            <span class=\"amst__time amst__seeking\">\r\n              <span>00:00</span>\r\n            </span>\r\n          </span>\r\n        </span>\r\n      </div>\r\n      <div class=\"amst__time amst__time-duration\">\r\n        <span class=\"amst__duration\">00:00</span>\r\n      </div>`\r\n  buildUIStr += videoVolumeHTMLString\r\n  if (fullscreenAPI) buildUIStr +=  `        \r\n      <div class=\"amst__button amst__fullscreen\">\r\n        <button type=\"button\" title=\"${params.fullscreen.label}\" aria-label=\"${params.fullscreen.label}\" tabindex=\"0\"></button>\r\n      </div>`\r\n  buildUIStr += `\r\n      <div class=\"amst__button amst__download\">\r\n        <button type=\"button\" title=\"${params.download.label}\" aria-label=\"${params.download.label}\" tabindex=\"0\"></button>\r\n      </div>\r\n    </div>\r\n  `\r\n  return buildUIStr\r\n}\r\n/************************************************\r\n *                                              *\r\n *                 FIN BUILDUI                  *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                 UTILITAIRES                  *\r\n *                                              *\r\n ************************************************/\r\nfunction secondsToTimeCode(t, long){\r\n  t = Math.round(t)\r\n  let h = Math.floor(t / 3600),\r\n      m = Math.floor((t - h * 3600) / 60),\r\n      s = Math.round(t % 60)\r\n  h = (h>9)?h+':':(h>0)?'0'+h+':':long?'00:':''\r\n  m = (m>9)?m:'0'+m\r\n  s = (s>9)?s:'0'+s\r\n\treturn h + m +  ':' + s\r\n}\r\n\r\n//http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html\r\nclass AmstRoundedRect{\r\n  constructor(ctx, h, x, w) {\r\n    let y = 0, r = 2;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + r, y);\r\n    ctx.lineTo(x + w - r, y);\r\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\r\n    ctx.lineTo(x + w, y + h - r);\r\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\r\n    ctx.lineTo(x + r, y + h);\r\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\r\n    ctx.lineTo(x, y + r);\r\n    ctx.quadraticCurveTo(x, y, x + r, y);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n  }\r\n}\r\n\r\nlet throttle = (type, name, obj = w)=>{\r\n  let running = false,\r\n      func = (e)=>{\r\n        if (running) return\r\n        running = true\r\n        requestAnimationFrame(()=>{\r\n          obj.dispatchEvent(new CustomEvent(name, {detail:e}))\r\n          running = false\r\n        })\r\n      }\r\n  obj.addEventListener(type, func)\r\n};\r\nthrottle('resize', 'optimizedResize')\r\nthrottle('scroll', 'optimizedScroll')\r\n\r\n//https://stackoverflow.com/a/37164538\r\nfunction isObject(item) {\r\n  return (item && typeof item === 'object' && !Array.isArray(item));\r\n}\r\n\r\nfunction mergeDeep(target, source) {\r\n  let output = Object.assign({}, target)\r\n  if (isObject(target) && isObject(source)) {\r\n    Object.keys(source).forEach(key => {\r\n      if (isObject(source[key])) {\r\n        if (!(key in target))\r\n          Object.assign(output, { [key]: source[key] })\r\n        else\r\n          output[key] = mergeDeep(target[key], source[key])\r\n      } else {\r\n        Object.assign(output, { [key]: source[key] })\r\n      }\r\n    })\r\n  }\r\n  return output\r\n}\r\n/************************************************\r\n *                                              *\r\n *               FIN UTILITAIRES                *\r\n *                                              *\r\n *          /////////////////////////           *\r\n *                                              *\r\n *                   $ et $$                    *\r\n *                                              *\r\n ************************************************/\r\nlet _$ = (context)=>{\r\n  let $ = function(selector) {\r\n    let el = (typeof selector === 'string')?context.querySelector(selector):selector\r\n    if (el) {\r\n      el.css = (newCSS)=>{\r\n        if (typeof newCSS === 'string') {\r\n          let v = w.getComputedStyle(el, null).getPropertyValue(newCSS)\r\n          return isNaN(parseFloat(v))?v:(parseFloat(v))\r\n        } else {\r\n          Object.assign(el.style, newCSS)\r\n          return el\t\t\r\n        }\r\n      }\r\n      el.setAttributes = (attrs)=>{\r\n        Object.keys(attrs).forEach(key=>el.setAttribute(key, attrs[key]))\r\n      }\r\n      el.on = function(events, handler, options = false){\r\n        events.split(' ').forEach(e=>el.addEventListener(e, handler, options));\r\n        return el\t\t\r\n      }\r\n      el.off = function(events, handler){\r\n        events.split(' ').forEach(e=>el.removeEventListener(e, handler));\r\n        return el\t\t\r\n      }\r\n    }\r\n    return el\r\n  }\r\n  return $\r\n}\r\n\r\nlet _$$ = (context)=>{\r\n  let $$ = (selector)=>{\r\n    let els = (Array.isArray(selector))?selector:Array.from(context.querySelectorAll(selector))\r\n    els.css = (newCSS)=>{\r\n      if (typeof newCSS === 'string') {\r\n        let v = window.getComputedStyle(els[0], null).getPropertyValue(newCSS)\r\n        return isNaN(parseFloat(v))?v:(parseFloat(v))\r\n      } else {\r\n        els.forEach(el=>{\r\n          Object.assign(el.style, newCSS)\r\n        })\r\n        return els\t\t\r\n      }\r\n    }\r\n    els.on = function(events, handler, options = false){\r\n      els.forEach(el=>{\r\n        events.split(' ').forEach(e=>el.addEventListener(e, handler, options));\r\n      })\r\n      return els\t\t\r\n    }\r\n    els.off = function(events, handler){\r\n      els.forEach(el=>{\r\n        events.split(' ').forEach(e=>el.removeEventListener(e, handler));\r\n      })\r\n      return els\t\t\r\n    }\r\n    let r = (els.length)?els:null\r\n    return r\r\n  }\r\n  return $$\r\n}\r\n/************************************************\r\n *                                              *\r\n *              THIS IS THE END...              *\r\n *                                              *\r\n ************************************************///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAvanMvYW1zdHJhbWdyYW1WaWRlb1BsYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9EOlxcTGF1cmVudFxcRG9jdW1lbnRzXFxIdG1sXFxhbXN0cmFtZ3JhbVZpZGVvUGxheWVyXFxhcHBcXGpzXFxhbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY3NzL2Ftc3RyYW1ncmFtVmlkZW9QbGF5ZXIuc2NzcydcclxuXHJcbi8qVE9ETyA6XHJcbiAgTWVudSBjb250ZXh0dWVsXHJcbiAgVHV0byB0aHVtbmFpbHNcclxuICBUZXN0IHBhcmFtw6h0cmVzXHJcbiovXHJcblxyXG4vKiAgXHJcbiAgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5wbGF5ZXJzIDogdGFibGVhdSBkZXMgcGxheWVyc1xyXG4gIEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudFBsYXllciA6IHBsYXllciBlbiBjb3VycyBkZSBsZWN0dXJlXHJcbiAgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5jdXJyZW50RnVsbFNjcmVlblBsYXllciA6IHBsYXllciBlbiBtb2RlIHBsZWluIMOpY3JhblxyXG4gIEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuZGVmYXVsdE9wdGlvbnMgOlxyXG4gICAgUFJPUFJJw4lUw4lTIFBST1BSRVMgw4AgTEEgU09VUkNFXHJcbiAgICAtIGF1dG9wbGF5IDogc2kgdHJ1ZSwgbCdhdHRyaWJ1dCBhdXRvcGxheSBlc3QgcG9zw6kgc3VyIGxlIHRhZyA8dmlkZW8+LlxyXG4gICAgICDDgCBub3RlciBxdWUgbGEgbGVjdHVyZSBhdXRvbWF0aXF1ZSBzZXJhIGJsb3F1w6llIHNpIGxlIHZvbHVtZSBuJ2VzdCBwYXMgbnVsLlxyXG4gICAgICBEw6lmYXV0IDogZmFsc2UuXHJcbiAgICAtIGNyb3Nzb3JpZ2luIDogYXR0cmlidXQgcG9zw6kgc3VyIGxlIHRhZyA8dmlkZW8+LlxyXG4gICAgICBEw6lmYXV0IDogZmFsc2UuXHJcbiAgICAtIGRvd25sb2FkIDogcHJvcHJpw6l0w6lzIGR1IGJvdXRvbiBEb3dubG9hZC5cclxuICAgICAgICAtIGxhYmVsIDogICAgIHRleHRlIGFmZmVjdMOpIGF1IHRpdHJlIGR1IGJvdXRvbiBldCDDoCBzb24gYXR0cmlidXQgYXJpYS1sYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgRMOpZmF1dCA6IFwiVMOpbMOpY2hhcmdlclwiLlxyXG4gICAgICAgIC0gZGlzYWJsZWQgOiAgc2kgdHJ1ZSwgbGUgYm91dG9uIHBvcnRlIGwnYXR0cmlidXQgZGlzYWJsZWQgZXQgZGVtZXVyZSBkb25jIGluYWN0aWYuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogZmFsc2UuICAgICAgICAgXHJcbiAgICAgICAgLSBoaWRkZW4gOiAgICBzaSB0cnVlLCBsYSBwcm9wcmnDqXTDqSBkaXNwbGF5IGR1IGJvdXRvbiBlc3QgcGFzc8OpZSBlbiAnaGlkZGVuJyBldCBsZSBib3V0b24gZXN0IGRvbmMgaW52aXNpYmxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgRMOpZmF1dCA6IGZhbHNlLiAgICAgICAgIFxyXG4gICAgICBEw6lmYXV0IDoge2xhYmVsOidUw6lsw6ljaGFyZ2VyJywgZGlzYWJsZWQ6ZmFsc2UsIGhpZGRlbjpmYWxzZX0uXHJcbiAgICAtIGR1cmF0aW9uIDogIGR1csOpZSBkZSBsYSB2aWTDqW8gZXhwcmltw6llIGVuIHNlY29uZGUuXHJcbiAgICAgIENlIHBhcmFtw6h0cmUgZXN0IG1pcyDDoCBqb3VyIHN1ciBsZXMgw6l2w6luZW1lbnQgbG9hZGVkbWV0YWRhdGEgZXQgZHVyYXRpb25jaGFuZ2UgZGUgbGEgdmlkw6lvLlxyXG4gICAgICBEw6lmYXV0IDogMTIwLlxyXG4gICAgLSBmb3JtYXQgOiBmb3JtYXQgZGUgbGEgdmlkw6lvIGV4cHJpbcOpZSBzb3VzIGxhIGZvcm1lIGQndW4gcmFwcG9ydCAoMTYvOSwgNC8zLCBldGMuKSBvdSBkJ3VuIG5vbWJyZS5cclxuICAgICAgRMOpZmF1dCA6IDE2LzkuXHJcbiAgICAtIGZ1bGxzY3JlZW4gOiBwcm9wcmnDqXTDqXMgZHUgYm91dG9uIEZ1bGxzY3JlZW4uXHJcbiAgICAgICAgLSBsYWJlbCA6IFxyXG4gICAgICAgICAgLSBlbnRlciA6IHRleHRlIGFmZmVjdMOpIGF1IHRpdHJlIGR1IGJvdXRvbiBldCDDoCBzb24gYXR0cmlidXQgYXJpYS1sYWJlbCBlbiBtb2RlIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBcIlBsZWluIMOpY3JhblwiLlxyXG4gICAgICAgICAgLSBleGl0IDogIHRleHRlIGFmZmVjdMOpIGF1IHRpdHJlIGR1IGJvdXRvbiBldCDDoCBzb24gYXR0cmlidXQgYXJpYS1sYWJlbCBlbiBtb2RlIHBsZWluIMOpY3JhblxyXG4gICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBcIlF1aXR0ZXIgbGUgcGxlaW4gw6ljcmFuXCIuXHJcbiAgICAgICAgLSBkaXNhYmxlZCA6ICBzaSB0cnVlLCBsZSBib3V0b24gcG9ydGUgbCdhdHRyaWJ1dCBkaXNhYmxlZCBldCBkZW1ldXJlIGRvbmMgaW5hY3RpZi5cclxuICAgICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBmYWxzZS4gICAgICAgICBcclxuICAgICAgICAtIGhpZGRlbiA6ICAgIHNpIHRydWUsIGxhIHByb3ByacOpdMOpIGRpc3BsYXkgZHUgYm91dG9uIGVzdCBwYXNzw6llIGVuICdoaWRkZW4nIGV0IGxlIGJvdXRvbiBlc3QgZG9uYyBpbnZpc2libGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogZmFsc2UuICAgICAgICAgXHJcbiAgICAgIETDqWZhdXQgOntsYWJlbDp7ZW50ZXI6J1BsZWluIMOpY3JhbicsIGV4aXQ6J1F1aXR0ZXIgbGUgcGxlaW4gw6ljcmFuJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LlxyXG4gICAgLSBsb29wIDogc2kgdHJ1ZSwgbCdhdHRyaWJ1dCBsb29wIGVzdCBwb3PDqSBzdXIgbGUgdGFnIDx2aWRlbz4uXHJcbiAgICAgIETDqWZhdXQgOiBmYWxzZS5cclxuICAgIC0gbmV4dCA6IHByb3ByacOpdMOpcyBkdSBib3V0b24gTmV4dC5cclxuICAgICAgICAtIGxhYmVsIDogICAgIHRleHRlIGFmZmVjdMOpIGF1IHRpdHJlIGR1IGJvdXRvbiBldCDDoCBzb24gYXR0cmlidXQgYXJpYS1sYWJlbC5cclxuICAgICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBcIlN1aXZhbnRcIi5cclxuICAgICAgICAtIGRpc2FibGVkIDogIHNpIHRydWUsIGxlIGJvdXRvbiBwb3J0ZSBsJ2F0dHJpYnV0IGRpc2FibGVkIGV0IGRlbWV1cmUgZG9uYyBpbmFjdGlmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgRMOpZmF1dCA6IHRydWUuICAgICAgICAgXHJcbiAgICAgICAgLSBoaWRkZW4gOiAgICBzaSB0cnVlLCBsYSBwcm9wcmnDqXTDqSBkaXNwbGF5IGR1IGJvdXRvbiBlc3QgcGFzc8OpZSBlbiAnaGlkZGVuJyBldCBsZSBib3V0b24gZXN0IGRvbmMgaW52aXNpYmxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgRMOpZmF1dCA6IHRydWUuICAgICAgICAgXHJcbiAgICAgIETDqWZhdXQgOiB7bGFiZWw6J1N1aXZhbnQnLCBkaXNhYmxlZDp0cnVlLCBoaWRkZW46dHJ1ZX0sXHJcbiAgICAtIHBsYXlzaW5saW5lIDogc2kgdHJ1ZSwgbGVzIGF0dHJpYnV0cyBwbGF5c2lubGluZSBldCB3ZWJraXQtcGxheXNpbmxpbmUgc29udCBwb3PDqXMgc3VyIGxlIHRhZyA8dmlkZW8+LlxyXG4gICAgICBEw6lmYXV0IDogdHJ1ZS5cclxuICAgIC0gcG9zdGVyIDogc291cmNlIGRlIGwnaW1hZ2Ugw6AgYWZmaWNoZXIgZW4gcG9zdGVyLlxyXG4gICAgICBEw6lmYXV0IDogdW5kZWZpbmVkLlxyXG4gICAgLSBwcmVsb2FkIDogYXR0cmlidXQgcG9zw6kgc3VyIGxlIHRhZyA8dmlkZW8+LlxyXG4gICAgICBEw6lmYXV0IDogJ25vbmUnLlxyXG4gICAgLSBwcmV2aW91cyA6IHByb3ByacOpdMOpcyBkdSBib3V0b24gUHJldmlvdXMuXHJcbiAgICAgICAgLSBsYWJlbCA6ICAgICB0ZXh0ZSBhZmZlY3TDqSBhdSB0aXRyZSBkdSBib3V0b24gZXQgw6Agc29uIGF0dHJpYnV0IGFyaWEtbGFiZWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogXCJQcsOpY8OpZGVudFwiLlxyXG4gICAgICAgIC0gZGlzYWJsZWQgOiAgc2kgdHJ1ZSwgbGUgYm91dG9uIHBvcnRlIGwnYXR0cmlidXQgZGlzYWJsZWQgZXQgZGVtZXVyZSBkb25jIGluYWN0aWYuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogdHJ1ZS4gICAgICAgICBcclxuICAgICAgICAtIGhpZGRlbiA6ICAgIHNpIHRydWUsIGxhIHByb3ByacOpdMOpIGRpc3BsYXkgZHUgYm91dG9uIGVzdCBwYXNzw6llIGVuICdoaWRkZW4nIGV0IGxlIGJvdXRvbiBlc3QgZG9uYyBpbnZpc2libGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogdHJ1ZS4gICAgICAgICBcclxuICAgICAgRMOpZmF1dCA6IHtsYWJlbDonUHLDqWPDqWRlbnQnLCBkaXNhYmxlZDp0cnVlLCBoaWRkZW46dHJ1ZX0uXHJcbiAgICAtIHNraXBUaW1lOiB2YWxldXIgYXR0cmlidcOpZSBhdSBzYXV0IHRlbXBvcmVsIHLDqWFsaXPDqWUgcGFyIGxlcyBmbMOoY2hlcyBnYXVjaGUgZXQgZHJvaXRlIGR1IGNsYXZpZXIuXHJcbiAgICAgIEVsbGUgcydleHByaW1lIGVuIHNlY29uZGVzIG91IGVuIHBvdXJjZW50YWdlLiBEYW5zIGNlIGNhcywgbGEgdmFsZXVyIHLDqXN1bHRhbnRlIGNvcnJlc3BvbmQgw6AgY2UgcG91cmNlbnRhZ2UgYXBwbGlxdcOpIMOgIGxhIGR1csOpZSBkdSBtw6lkaWEuXHJcbiAgICAgIETDqWZhdXQgOiAnMSUnLlxyXG4gICAgLSB0aHVtYm5haWxzOiBQcm9wcmnDqXTDqXMgZGVzIHZpZ25ldHRlcy5cclxuICAgICAgICAtIHNyYyA6ICAgICBzb3VyY2UgZGUgbCdpbWFnZS5cclxuICAgICAgICAgICAgICAgICAgICBMJ2ltYWdlIGRvaXQgw6p0cmUgY29uc3RpdHXDqWUgZCd1bmUgc2V1bGUgYmFuZGUgZGUgdmlnbmV0dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiB1bmRlZmluZWQuXHJcbiAgICAgICAgLSBudW1iZXIgOiAgbm9tYnJlIGRlIHZpZ25ldHRlcy5cclxuICAgICAgICAgICAgICAgICAgICBDZSBub21icmUgcGVybWV0IGRlIGTDqXRlcm1pbmVyIGxhIGxhcmdldXIgZCd1bmUgdmlnbmV0dGUgPSBsYXJnZXVyIGRlIGwnaW1hZ2UgLyBub21icmUgZGUgdmlnbmV0dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiAxMDAuXHJcbiAgICAgIETDqWZhdXQgOiB7c3JjOnVuZGVmaW5lZCwgbnVtYmVyOjEwMH0uXHJcbiAgICAtIHZvbHVtZSA6ICB2b2x1bWUgw6AgYXBwbGlxdWVyIGF1IG3DqWRpYS5cclxuICAgICAgICAgICAgICAgIERvaXQgw6p0cmUgdW4gbm9tYnJlIGNvbXByaXMgZW50cmUgMCBldCAxLlxyXG4gICAgICBEw6lmYXV0IDogMC44LlxyXG4gICAgLSB2b2x1bWVCdXR0b24gOiBwcm9wcmnDqXTDqXMgZHUgYm91dG9uIFZvbHVtZS5cclxuICAgICAgICAtIGxhYmVsIDogXHJcbiAgICAgICAgICAtIG11dGUgOiAgdGV4dGUgYWZmZWN0w6kgYXUgdGl0cmUgZHUgYm91dG9uIGV0IMOgIHNvbiBhdHRyaWJ1dCBhcmlhLWxhYmVsIHNpIGxlIHZvbHVtZSBlc3Qgc3Vww6lyaWV1ciDDoCAwLlxyXG4gICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBcIkTDqXNhY3RpdmVyIGxlIHNvblwiLlxyXG4gICAgICAgICAgLSBleGl0IDogIHRleHRlIGFmZmVjdMOpIGF1IHRpdHJlIGR1IGJvdXRvbiBldCDDoCBzb24gYXR0cmlidXQgYXJpYS1sYWJlbCBzaSBsZSB2b2x1bWUgZXN0IG51bC5cclxuICAgICAgICAgICAgICAgICAgICBEw6lmYXV0IDogXCJBY3RpdmVyIGxlIHNvblwiLlxyXG4gICAgICAgIC0gZGlzYWJsZWQgOiAgc2kgdHJ1ZSwgbGUgYm91dG9uIHBvcnRlIGwnYXR0cmlidXQgZGlzYWJsZWQgZXQgZGVtZXVyZSBkb25jIGluYWN0aWYuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEYW5zIGNlIGNhcywgbGUgcG90ZW50aW9tw6h0cmUgZXN0IGNhY2jDqS5cclxuICAgICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBmYWxzZS4gICAgICAgICBcclxuICAgICAgICAtIGhpZGRlbiA6ICAgIHNpIHRydWUsIGxhIHByb3ByacOpdMOpIGRpc3BsYXkgZHUgYm91dG9uIGVzdCBwYXNzw6llIGVuICdoaWRkZW4nIGV0IGxlIGJvdXRvbiBlc3QgZG9uYyBpbnZpc2libGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICBEYW5zIGNlIGNhcywgbGUgcG90ZW50aW9tw6h0cmUgZXN0IGNhY2jDqS5cclxuICAgICAgICAgICAgICAgICAgICAgIETDqWZhdXQgOiBmYWxzZS4gICAgICAgICBcclxuICAgICAgRMOpZmF1dCA6IHtsYWJlbDp7bXV0ZTonRMOpc2FjdGl2ZXIgbGUgc29uJywgdW5tdXRlOidBY3RpdmVyIGxlIHNvbid9LCBkaXNhYmxlZDpmYWxzZSwgaGlkZGVuOmZhbHNlfS5cclxuICAgIC0gdm9sdW1lR3JvdXAgOiBOb21icmUgZW50aWVyIHN1cMOpcmlldXIgw6AgesOpcm8gc3DDqWNpZmlhbnQgbGUgZ3JvdXBlIGRlIGxlY3RldXJzIHF1aSBwYXJ0YWdlbnQgbGUgbcOqbWUgdm9sdW1lLlxyXG4gICAgICAgICAgICAgICAgICAgIFRvdXQgY2hhbmdlbWVudCBkZSB2b2x1bWUgaW50ZXJ2ZW5hbnQgc3VyIHVuIGRlcyBsZWN0ZXVycyBkZSBjZSBncm91cGUgc2VyYSBlZmZlY3R1w6kgc3VyIGxlcyBhdXRyZXMgbGVjdGV1cnMgZHUgbcOqbWUgZ3JvdXBlLlxyXG4gICAgICBEw6lmYXV0IDogMCAoTGUgbGVjdGV1ciBuJ2FwcGFydGllbnQgw6AgYXVjdW4gZ3JvdXBlKS5cclxuICAgIFBST1BSScOJVMOJUyBQUk9QUkVTIEFVIExFQ1RFVVJcclxuICAgIC0gaGlkZUNvbnRyb2xzRGVsYXkgOiBFeHByaW3DqWUgZW4gbXMsIGR1csOpZSBkdSBkw6lsYWkgaW50ZXJ2ZW5hbnQgYXZhbnQgZGUgY2FjaGVyIGxhIGJhcnJlIGRlIGNvbnRyw7RsZS5cclxuICAgICAgRMOpZmF1dCA6IDUwMDAuXHJcbiAgICAtIHZpZGVvVm9sdW1lT3JpZW50YXRpb24gOiBzaSBjZSBwYXJhbcOodHJlIG4nZXN0IHBhcyBkw6lmaW5pIHBhciBsYSBjaGFpbmUgJ2hvcml6b250YWwnLCBsZSBwb3RlbnRpb23DqHRyZSBkZSB2b2x1bWUgZXN0IGVuIG1vZGUgdmVydGljYWwuXHJcbiAgICAgIETDqWZhdXQgOiAndmVydGljYWwnLlxyXG4gICAgLSByYWlsTWluV2lkdGhGb3JOb3JtYWxVSSA6IGxhcmdldXIgbWluaW1hbGUgZGlzcG9uaWJsZSBwb3VyIGxhIGJhcnJlIHRlbXBvcmVsbGUgZGFucyBsJ2ludGVyZmFjZSBub3JtYWxlLlxyXG4gICAgICBTaSBsYSBsYXJnZXVyIGRpc3BvbmlibGUgcG91ciBsYSBiYXJyZSB0ZW1wb3JlbGxlIGVzdCBpbmbDqXJpZXVyZSDDoCBjZSBwYXJhbcOodHJlLCBsJ2ludGVyZmFjZSBiYXNjdWxlIGVuIG1vZGUgY29tcGFjdC5cclxuICAgICAgRMOpZmF1dCA6IDYwMC5cclxuICAgIFBST1BSScOJVEVTIEdMT0JBTEVTXHJcbiAgICAtIGFwcExhYmVsIDogdGV4dGUgw6AgYXBwbGlxdWVyIMOgIGwnYXJpYS1sYWJlbCBkdSBsZWN0ZXVyLlxyXG4gICAgICBEw6lmYXV0IDogJ0xlY3RldXIgdmlkw6lvJy5cclxuICAgIC0gcGxheUxhYmVsIDogdGV4dGUgYWZmZWN0w6kgYXUgdGl0cmUgZHUgYm91dG9uIFBhdXNlIGV0IMOgIHNvbiBhdHRyaWJ1dCBhcmlhLWxhYmVsLlxyXG4gICAgICBEw6lmYXV0IDogJ1BhdXNlJy5cclxuICAgIC0gcGxheUxhYmVsIDogdGV4dGUgYWZmZWN0w6kgYXUgdGl0cmUgZHUgYm91dG9uIFBsYXkgZXQgw6Agc29uIGF0dHJpYnV0IGFyaWEtbGFiZWwuXHJcbiAgICAgIETDqWZhdXQgOiAnTGVjdHVyZScuXHJcbiAgICAtIHZvbHVtZUhlbHBMYWJlbCA6IHRleHRlIMOgIGFwcGxpcXVlciBhdSB0aXRyZSBkdSBwb3RlbnRpb23DqHRyZS5cclxuICAgICAgRMOpZmF1dCA6ICdVdGlsaXNleiBsZXMgZmzDqGNoZXMgSGF1dC9CYXMgZHUgY2xhdmllciBwb3VyIGF1Z21lbnRlciBvdSBkaW1pbnVlciBsZSB2b2x1bWUnLlxyXG4gICAgLSB2b2x1bWVTbGlkZXJMYWJlbCA6IHRleHRlIMOgIGFwcGxpcXVlciDDoCBsJ2FyaWEtbGFiZWwgZHUgcG90ZW50aW9tw6h0cmUuXHJcbiAgICAgIETDqWZhdXQgOiAnUG90ZW50aW9tw6h0cmUgZGUgdm9sdW1lJy5cclxuICBcclxuICBMZXMgb3B0aW9ucyBhdXRvcGxheSwgY3Jvc3NvcmlnaW4sIGxvb3AsIHBsYXlzaW5saW5lLCBwb3N0ZXIgcGV1dmVudCDDqnRyZSBhdHRyaWJ1w6llcyB2aWEgbGVzIGF0dHJpYnV0cyBIVE1MIGR1IHRhZyA8dmlkZW8+LlxyXG4gIFNpLCBwYXIgYWlsbGV1cnMsIGxlIHRhZyBjb21wb3J0ZSBkZXMgYXR0cmlidXRzIHdpZHRoIGV0IGhlaWdodCwgbGUgZm9ybWF0IGRlIGxhIHZpZMOpbyBzZXJhIGTDqXRlcm1pbsOpIHBhciBjZXMgdmFsZXVycy5cclxuICBTJ2lsIGNvbXBvcnRlIGwnYXR0cmlidXQgbXV0ZWQsIGxlIHZvbHVtZSBzZXJhIGludGVycHLDqXTDqSBjb21tZSBudWwuXHJcbiAgTGVzIHBhcmFtw6h0cmVzIHBhc3PDqXMgYXUgY29uc3RydWN0ZXVyIHByaW1lbnQgc3VyIGxlcyBhdHRyaWJ1dHMgSFRNTC5cclxuICBMZXMgcGFyYW3DqHRyZXMgbGlzdMOpcyBzb3VzIGxlIHRpdHJlIFwiUFJPUFJJw4lUw4lTIFBST1BSRVMgw4AgTEEgU09VUkNFXCIgcGV1dmVudCB0b3V0ZXMgw6p0cmUgcmVkw6lmaW5pZXMgbG9ycyBkdSBjaGFuZ2VtZW50IGRlIHNvdXJjZS5cclxuICBMZSBjb25zdHJ1Y3RldXIgaW50w6hncmUgZGUgc3VyY3JvaXQgdW5lIHByb3ByacOpdMOpIGZhY3VsdGF0aXZlIHZvbHVtZUZvcmNlZC4gU2kgY2VsbGUtY2kgZXN0IHNww6ljaWZpw6llIMOgIHRydWUsIGxlIHZvbHVtZSBwYXNzw6kgZW4gcGFyYW3DqHRyZSBzZXJhXHJcbiAgYXBwbGlxdcOpIGF1IGxlY3RldXIgZXQgw6Agc29uIGdyb3VwZSDDqXZlbnR1ZWwuIERhbnMgbGVzIGF1dHJlcyBjYXMsIHNpIGxlIGxlY3RldXIgYXBwYXJ0aWVudCDDoCB1biBncm91cGUgZMOpasOgIGV4aXN0YW50LFxyXG4gIGMnZXN0IGxlIHZvbHVtZSBkZSBjZSBncm91cGUgcXVpIGx1aSBzZXJhIGFwcGxpcXXDqS5cclxuICBDZXR0ZSBwcm9wcmnDqXTDqSBlc3Qgw6lnYWxlbWVudCBhcHBsaWNhYmxlIGF1IGNoYW5nZW1lbnQgZGUgc291cmNlLlxyXG5cclxuICBFWEVNUExFU1xyXG4gIDEuXHJcbiAgICBIVE1MIDogXHJcbiAgICAgIDx2aWRlbyBpZD1cIm15dmlkZW9cIiBzcmM9XCJteXZpZGVvLm1wNFwiIHBvc3Rlcj1cIm15dmlkZW8uanBnXCIgcHJlbG9hZD1cImF1dG9cIj5cclxuICAgIEphdmFzY3JpcHQgOlxyXG4gICAgICBsZXQgcGxheWVyID0gbmV3IEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI215dmlkZW8nKSlcclxuICAyLlxyXG4gICAgSFRNTCA6IFxyXG4gICAgICA8dmlkZW8gaWQ9XCJteXZpZGVvXCI+XHJcbiAgICBKYXZhc2NyaXB0IDpcclxuICAgICAgbGV0IHBsYXllciA9IG5ldyBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNteXZpZGVvJyksIHtcclxuICAgICAgICBhdXRvcGxheTogdHJ1ZSxcclxuICAgICAgICBkdXJhdGlvbjogMTI1LFxyXG4gICAgICAgIGZvcm1hdDogNC8zLFxyXG4gICAgICAgIG5leHQ6IHtsYWJlbDonTGEgdmlkw6lvIHN1aXZhbnRlJywgZGlzYWJsZWQ6ZmFsc2UsIGhpZGRlbjpmYWxzZX1cclxuICAgICAgICBwcmVsb2FkOiAnYXV0bycsXHJcbiAgICAgICAgcHJldmlvdXM6IHtsYWJlbDogJ1JpZW4gw6Agdm9pcicsIGhpZGRlbjpmYWxzZX1cclxuICAgICAgICBza2lwVGltZTogJzIlJyxcclxuICAgICAgICBzcmM6ICdteXZpZGVvLm1wNCcsXHJcbiAgICAgICAgdm9sdW1lOiAwLFxyXG4gICAgICAgIHZvbHVtZUdyb3VwOiAxLFxyXG4gICAgICAgIHZpZGVvVm9sdW1lT3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcclxuICAgICAgfSlcclxuICAgICAgRXQgcGx1cyB0YXJkIDpcclxuICAgICAgcGxheWVyLnNyYyA9IHtcclxuICAgICAgICBmb3JtYXQ6IDE2LzksXHJcbiAgICAgICAgZHVyYXRpb246IDg1MCxcclxuICAgICAgICBuZXh0OiB7bGFiZWw6J1BsdXMgcmllbicsIGRpc2FibGVkOnRydWV9XHJcbiAgICAgICAgcG9zdGVyOiAnbXl2aWRlbzIuanBnJyxcclxuICAgICAgICBwcmVsb2FkOiAnbm9uZScsXHJcbiAgICAgICAgcHJldmlvdXM6IHtsYWJlbDonUmV2b2lyIGxhIHZpZMOpbyBwcsOpY8OpZGVudGUnLCBkaXNhYmxlZDpmYWxzZX1cclxuICAgICAgICBza2lwVGltZTogJzUlJyxcclxuICAgICAgICBzcmM6ICdteXZpZGVvMi5tcDQnLFxyXG4gICAgICAgIHZvbHVtZTogMC41LFxyXG4gICAgICAgIHZvbHVtZUZvcmNlZDogdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gIEdFVFRFUnMvU0VUVEVSc1xyXG4gICAgLSBzcmNcclxuICAgICAgICAtIGdldCA6IHJldG91cm5lIGxhIHNvdXJjZSBkdSBtw6lkaWFcclxuICAgICAgICAtIHNldCA6IGTDqWZpbml0IHVuZSBub3V2ZWxsZSBzb3VyY2UgZXQgw6l2ZW50dWVsbGVtZW50IHVuIGNlcnRhaW4gbm9tYnJlIGRlIHByb3ByacOpdMOpc1xyXG4gICAgICAgICAgUHJlbmQgZW4gcGFyYW3DqHRyZSB1bmUgY2hhaW5lIGTDqWZpbmlzc2FudCBsZSBjaGVtaW4gZGUgbGEgc291cmNlIG91IHVuIG9iamV0IDoge1xyXG4gICAgICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcclxuICAgICAgICAgICAgICBjcm9zc29yaWdpbjogJ2Fub2FueW1vdXMnLFxyXG4gICAgICAgICAgICAgIGRvd25sb2FkOiB7bGFiZWw6J1TDqWzDqWNoYXJnZXInLCBkaXNhYmxlZDpmYWxzZSwgaGlkZGVuOmZhbHNlfSxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogIDIwMCxcclxuICAgICAgICAgICAgICBmb3JtYXQgOiAxNi85LFxyXG4gICAgICAgICAgICAgIGZ1bGxzY3JlZW46IHtsYWJlbDp7ZW50ZXI6J1BsZWluIMOpY3JhbicsIGV4aXQ6J1F1aXR0ZXIgbGUgcGxlaW4gw6ljcmFuJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LFxyXG4gICAgICAgICAgICAgIGxvb3A6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIG5leHQ6IHtsYWJlbDonU3VpdmFudCcsIGRpc2FibGVkOnRydWUsIGhpZGRlbjp0cnVlfSxcclxuICAgICAgICAgICAgICBwbGF5c2lubGluZTogdHJ1ZSwgXHJcbiAgICAgICAgICAgICAgcG9zdGVyOiAnc291cmNlIGR1IHBvc3RlcicsXHJcbiAgICAgICAgICAgICAgcHJlbG9hZDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgIHByZXZpb3VzOiB7bGFiZWw6J1Byw6ljw6lkZW50JywgZGlzYWJsZWQ6dHJ1ZSwgaGlkZGVuOnRydWV9LFxyXG4gICAgICAgICAgICAgIHNraXBUaW1lOiAnMSUnLFxyXG4gICAgICAgICAgICAgIHRodW1ibmFpbHM6IHtzcmM6J3NvdXJjZSBkZSBsJ2ltYWdlJywgbnVtYmVyOjEwMH0sXHJcbiAgICAgICAgICAgICAgdm9sdW1lOiAwLjgsXHJcbiAgICAgICAgICAgICAgdm9sdW1lQnV0dG9uOiB7bGFiZWw6e211dGU6J0TDqXNhY3RpdmVyIGxlIHNvbicsIHVubXV0ZTonQWN0aXZlciBsZSBzb24nfSwgZGlzYWJsZWQ6ZmFsc2UsIGhpZGRlbjpmYWxzZX0sXHJcbiAgICAgICAgICAgICAgdm9sdW1lR3JvdXA6IDAsXHJcbiAgICAgICAgICAgICAgKHZvbHVtZUZvcmNlZDogdHJ1ZSwpXHJcbiAgICAgICAgICB9XHJcbiAgICAtIGN1cnJlbnRUaW1lXHJcbiAgICAgICAgLSBnZXQgOiByZXRvdXJuZSBsYSBwb3NpdGlvbiB0ZW1wb3JlbGxlIGNvdXJhbnRlLlxyXG4gICAgICAgIC0gc2V0IDogYW3DqW5lIGxhIHTDqnRlIGRlIGxlY3R1cmUgw6AgbGEgcG9zaXRpb24gc3DDqWNpZmnDqWUgZW4gc2Vjb25kZXMuXHJcbiAgICAtIHZvbHVtZVxyXG4gICAgICAgIC0gZ2V0IDogcmV0b3VybmUgbGUgbml2ZWF1IGRlIHZvbHVtZS5cclxuICAgICAgICAtIHNldCA6IGZpeGUgbGUgdm9sdW1lIGF1IG5pdmVhdSBzcMOpY2lmacOpIChub21icmUgZW50cmUgMCBldCAxKS5cclxuXHJcbiAgR0VUVEVSU1xyXG4gICAgLSBkdXJhdGlvbiA6IHJldG91cm5lIGxhIGR1csOpZSBkdSBtw6lkaWEgc2kgZWxsZSBlc3QgZGlzcG9uaWJsZS5cclxuICAgIC0gcGF1c2VkIDogcmV0cm91bmUgdHJ1ZSBzaSBsZSBtw6lkaWEgZXN0IGVuIHBhdXNlXHJcblxyXG4gIE3DiVRIT0RFU1xyXG4gICAgLSBwbGF5KCkgOiBtZXQgbGUgbcOpZGlhIGVuIGxlY3R1cmUuXHJcbiAgICAtIHBhdXNlKCkgOiBtZXQgbGUgbcOpZGlhIGVuIHBhdXNlLlxyXG4gICAgLSByZXNldCgpIDogcmVzZXQgbGUgbGVjdGV1ci5cclxuICAgIC0gdG9nZ2xlUGxheVBhdXNlKCkgOiBwYXNzZSBsZSBtw6lkaWEgZW4gcGF1c2UgcydpbCBlc3QgZW4gbGVjdHVyZSBldCByw6ljaXByb3F1ZW1lbnQuXHJcbiAgICAtIGhpZGVDb250cm9scyhkZWxheWVkID0gZmFsc2UsIGZvcmNlZCA9IGZhbHNlKSA6IGNhY2hlIGxhIGJhcnJlIGRlIGNvbnTDtGxlXHJcbiAgICAgICAgU2kgZGVsYXllZCB2YXV0IHRydWUsIGxhIGRpc3Bhcml0aW9uIG4naW50ZXJ2aWVudCBxdSdhcHJlcyBsZSBkw6lsYWkgZml4w6kgcGFyIGxlIHBhcmFtw6h0cmUgaGlkZUNvbnRyb2xzRGVsYXkgZHUgbGVjdGV1ci5cclxuICAgICAgICBQYXIgZMOpZmF1dCwgbGEgZGlzcGFyaXRpb24gZXN0IGJsb3F1w6llIHNpIGxhIHZpZMOpbyBlc3QgZW4gcGF1c2UuXHJcbiAgICAgICAgUG91ciBsYSBmb3JjZXIsIGlsIGZhdXQgcGFzc2VyIGxlIGRldXhpw6htZSBhcmd1bWVudCDDoCB0cnVlLlxyXG4gICAgLSBzaG93Q29udHJvbHMgOiBtb250cmUgbGEgYmFycmUgZGUgY29udHLDtGxlLlxyXG4gICAgLSBwcmV2aW91cygpIDogYWZmZWN0ZSBkZSBub3V2ZWxsZXMgcHJvcHJpw6l0w6lzIGF1IGJvdXRvbiBQcmV2aW91cy5cclxuICAgICAgICBQcmVuZCBlbiBwYXJhbcOodHJlIHVuIG9iamV0IGRlIGxhIGZvcm1lIDoge2xhYmVsOidQcsOpY8OpZGVudCcsIGRpc2FibGVkOnRydWUsIGhpZGRlbjp0cnVlfS5cclxuICAgIC0gbmV4dCgpIDogYWZmZWN0ZSBkZSBub3V2ZWxsZXMgcHJvcHJpw6l0w6lzIGF1IGJvdXRvbiBOZXh0LlxyXG4gICAgICAgIFByZW5kIGVuIHBhcmFtw6h0cmUgdW4gb2JqZXQgZGUgbGEgZm9ybWUgOiB7bGFiZWw6J1N1aXZhbnQnLCBkaXNhYmxlZDp0cnVlLCBoaWRkZW46dHJ1ZX0uXHJcbiAgICAtIGRvd25sb2FkKCkgOiBhZmZlY3RlIGRlIG5vdXZlbGxlcyBwcm9wcmnDqXTDqXMgYXUgYm91dG9uIERvd25sb2FkLlxyXG4gICAgICAgIFByZW5kIGVuIHBhcmFtw6h0cmUgdW4gb2JqZXQgZGUgbGEgZm9ybWUgOiB7bGFiZWw6J1TDqWzDqWNoYXJnZXInLCBkaXNhYmxlZDpmYWxzZSwgaGlkZGVuOmZhbHNlfS5cclxuICAgIC0gZnVsbHNjcmVlbigpIDogYWZmZWN0ZSBkZSBub3V2ZWxsZXMgcHJvcHJpw6l0w6lzIGF1IGJvdXRvbiBGdWxsc2NyZWVuLlxyXG4gICAgICAgIFByZW5kIGVuIHBhcmFtw6h0cmUgdW4gb2JqZXQgZGUgbGEgZm9ybWUgOiB7bGFiZWw6e2VudGVyOidQbGVpbiDDqWNyYW4nLCBleGl0OidRdWl0dGVyIGxlIHBsZWluIMOpY3Jhbid9LCBkaXNhYmxlZDpmYWxzZSwgaGlkZGVuOmZhbHNlfS5cclxuICAgIC0gdm9sdW1lQnV0dG9uKCkgOiBhZmZlY3RlIGRlIG5vdXZlbGxlcyBwcm9wcmnDqXTDqXMgYXUgYm91dG9uIFZvbHVtZS5cclxuICAgICAgICBQcmVuZCBlbiBwYXJhbcOodHJlIHVuIG9iamV0IGRlIGxhIGZvcm1lIDoge2xhYmVsOnttdXRlOidEw6lzYWN0aXZlciBsZSBzb24nLCB1bm11dGU6J0FjdGl2ZXIgbGUgc29uJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LlxyXG4gIFxyXG4gIE3DiVRIT0RFIFNUQVRJUVVFXHJcbiAgICBvcHRpb25zKCkgOiBwZXJtZXQgZGUgcmVkw6lmaW5pciBsZXMgcHJvcHJpw6l0w6lzIHBhciBkw6lmYXV0IGRlIGxhIGNsYXNzIGF2YW50IHRvdXRlIGNyw6lhdGlvbiBkJ2luc3RhbmNlLlxyXG5cclxuICBQUk9QUknDiVTDiVNcclxuICAgIC0gY29udGFpbmVyIDogcG9pbnRlIHN1ciBsJ8OpbMOpbWVudCBIVE1MIGNvbnRhaW5lciBkdSBsZWN0ZXVyLlxyXG4gICAgLSBtZWRpYSA6IHBvaW50ZSBzdXIgbCfDqWzDqW1lbnQgSFRNTCA8dmlkZW8+IGR1IGxlY3RldXIuXHJcbiAgICAtIHBhcmFtcyA6IHJlbnZvaWUgbGVzIHBhcmFtw6h0cmVzIGR1IGxlY3RldXIuXHJcbiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgIElOSVRJQUxJU0FUSU9OICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmNvbnN0IFxyXG4gIHcgPSB3aW5kb3csIFxyXG4gIGQgPSBkb2N1bWVudCxcclxuICAvL0TDqWZpbml0aW9uIGR1IHR5cGUgZGUgcG9pbnRldXJcclxuICAvL1NpIFBvaW50ZXJFdmVudCBlc3QgZMOpdGVjdMOpLCBsZSB0eXBlIHZhdXQgJ3BvaW50ZXInXHJcbiAgLy9TaW5vbiwgc2kgVG91Y2hFdmVudCBlc3QgZMOpdGVjdMOpLCBsZSB0eXBlIHZhdXQgJ3RvdWNoJyBldCBpbCB5IGEgZm9ydCDDoCBwYXJpZXIgcXUnb24gc29pdCBzdXIgaU9TXHJcbiAgLy9FbmZpbiwgc2kgamFtYWlzIFBvaW50ZXJFdmVudCBldCBUb3VjaEV2ZW50IG5lIHNvbnQgcGFzIGTDqXRlY3TDqXMsIGxlIHR5cGUgdmF1dCAnbW91c2UnXHJcbiAgbXlQb2ludGVyVHlwZSA9ICh3LlBvaW50ZXJFdmVudCk/J3BvaW50ZXInOih3LlRvdWNoRXZlbnQpPyd0b3VjaCc6J21vdXNlJyxcclxuICAvL09uIGVuIGTDqWR1aXQgbGUgbm9tIGRlcyDDqXbDqG5lbWVudHMgY29ycmVzcG9uZGFudHNcclxuICBteVBvaW50ZXJFbnRlciA9IChteVBvaW50ZXJUeXBlID09ICd0b3VjaCcpPydub25lJzpteVBvaW50ZXJUeXBlICsgJ2VudGVyJyxcclxuICBteVBvaW50ZXJMZWF2ZSA9IChteVBvaW50ZXJUeXBlID09ICd0b3VjaCcpPydub25lJzpteVBvaW50ZXJUeXBlICsgJ2xlYXZlJyxcclxuICBteVBvaW50ZXJEb3duID0gKG15UG9pbnRlclR5cGUgPT0gJ3RvdWNoJyk/J3RvdWNoc3RhcnQnOm15UG9pbnRlclR5cGUgKyAnZG93bicsXHJcbiAgbXlQb2ludGVyVXAgPSAobXlQb2ludGVyVHlwZSA9PSAndG91Y2gnKT8ndG91Y2hlbmQnOm15UG9pbnRlclR5cGUgKyAndXAnLFxyXG4gIG15UG9pbnRlck1vdmUgPSBteVBvaW50ZXJUeXBlICsgJ21vdmUnLFxyXG4gIC8vRMOpdGVjdGlvbiBkZSBsJ3VzZXIgYWdlbnQgcG91ciBzYXZvaXIgc2kgb24gZXN0IHN1ciBtb2JpbGVcclxuICAvL0RhbnMgY2UgY2FzLCBvbiBuZSBjcsOpZSBwYXMgZGUgcG90ZW50aW9tw6h0cmUgZGUgdm9sdW1lXHJcbiAgVUEgPSB3Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcclxuICBJU19NT0JJTEUgPSAoL2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KFVBKSAmJiAhdy5NU1N0cmVhbSkgfHwgL2FuZHJvaWQvaS50ZXN0KFVBKVxyXG5cclxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nIHx8ICFBcnJheS5mcm9tIHx8ICFBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMgfHwgdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgY29uc3Qgc2NyaXB0cz0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksXHJcbiAgICAgICAgcGF0aD0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aC0xXS5zcmMuc3BsaXQoJz8nKVswXSxcclxuICAgICAgICBteWRpcj0gcGF0aC5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5qb2luKCcvJykrJy8nLFxyXG4gICAgICAgIHMgPSBkLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXHJcbiAgcy5hc3luYz1cImZhbHNlXCJcclxuICBzLnNyYyA9IG15ZGlyICsgXCJhbXN0cmFtZ3JhbVZpZGVvUGxheWVyUG9seWZpbGwubWluLmpzXCJcclxuICBkLmhlYWQuYXBwZW5kQ2hpbGQocylcclxufVxyXG5cclxuLy9FZGdlIG5lIGNvbXByZW5kIHRvdWpvdXJzIHBhcyBnZXRBdHRyaWJ1dGVOYW1lcyAoSUUxMSBub24gcGx1cywgYmllbiDDqXZpZGVtbWVudClcclxuaWYgKEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5hbWVzID09IHVuZGVmaW5lZCkge1xyXG4gIEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5hbWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGEgPSB0aGlzLmF0dHJpYnV0ZXMsIGwgPSBhLmxlbmd0aCwgciA9IG5ldyBBcnJheShsKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHJbaV0gPSBhW2ldLm5hbWVcclxuICAgIH1cclxuICAgIHJldHVybiByXHJcbiAgfTtcclxufVxyXG4vL0TDqXRlY3Rpb24gZHUgc3VwcG9ydCBkZSBsYSBmb25jdGlvbm5hbGl0w6kgc2Vzc2lvblN0b3JhZ2VcclxuY29uc3Qgc3RvcmFnZSA9IChmdW5jdGlvbigpe1xyXG4gIHRyeSB7XHJcbiAgICAgIGxldCB4ID0gJ19fc3RvcmFnZV90ZXN0X18nXHJcbiAgICAgIHcuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh4LCB4KVxyXG4gICAgICB3LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oeClcclxuICAgICAgcmV0dXJuIHcuc2Vzc2lvblN0b3JhZ2VcclxuICB9XHJcbiAgY2F0Y2goZSkge3JldHVybiBmYWxzZX1cclxufSkoKVxyXG4vKlxyXG5TaSBzZXNzaW9uU3RvcmFnZSBlc3QgZGlzcG9uaWJsZSwgb24geSBzdG9ja2UgdG91dGVzIGxlcyBmb25jdGlvbm5hbGl0w6lzIGTDqXRlY3TDqXNcclxuYWZpbiBkZSBuZSBwbHVzIGF2b2lyIGRlIGTDqXRlY3Rpb24gw6Agb3DDqXJlciBwYXIgbGEgc3VpdGUuXHJcbk9uIHkgY29uc2VydmUgw6lnYWxlbWVudCBsZXMgaW5mb3JtYXRpb25zIGRlIHZvbHVtZSBwb3VyIGNoYXF1ZSBncm91cGUgZGUgbGVjdGV1cnNcclxuXHJcbkNhbGN1bCBkZSBsYSBsYXJnZXVyIGRlcyDDqWzDqW1lbnRzIGluZGljYXRldXJzIHRlbXBvcmVsLlxyXG5DZXMgbGFyZ2V1cnMgZMOpcGVuZGVudCBkdSBuYXZpZ2F0ZXVyIGV0IGRvaXZlbnQgw6p0cmUgZMOpdGVybWluw6llc1xyXG5wb3VyIGFzc3VyZXIgbGUgYm9uIHBvc2l0aW9ubmVtZW50IGRlcyDDqWzDqW1lbnRzLlxyXG5PbiBtZXN1cmUgbGVzIGxhcmdldXJzIHBvdXIgZGVzIHRlbXBzIDpcclxuLSBpbmbDqXJpZXVyIMOgIHVuZSBoZXVyZSAoZHVyw6llIGFmZmljaMOpZSA6IDAwOjAwKVxyXG4tIHN1cMOpcmlldXIgb3Ugw6lnYWwgw6AgdW5lIGhldXJlIChkdXLDqWUgYWZmaWNow6llIDogMDA6MDA6MDApXHJcbiovXHJcbmxldCB0aW1lV2lkdGgsIGxvbmdUaW1lV2lkdGhcclxuaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3RpbWVXaWR0aCcpKSB7XHJcbiAgdGltZVdpZHRoID0gc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3RpbWVXaWR0aCcpXHJcbiAgbG9uZ1RpbWVXaWR0aCA9IHN0b3JhZ2UuZ2V0SXRlbSgnYW1zdF9sb25nVGltZVdpZHRoJylcclxufSBlbHNlIHtcclxuICBjb25zdCBcclxuICAgIG1lYXN1cmVUaW1lID0gZC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgXHJcbiAgICBtZWFzdXJlTG9uZ1RpbWUgPSBkLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgLy9MYSBjbGFzcyBhbXN0X19tZWFzdXJlVGltZSByZXByZW5kIGxlcyBtw6ptZXMgcHJvcHJpw6l0w6lzIGdyYXBoaXF1ZXMgcXVlIGxhIGNsYXNzIGFtc3RfX3RpbWVcclxuICAvL21haXMgYXNzdXJlIHVuIHBvc2l0aW9ubmVtZW50IGFic29sdS5cclxuICBtZWFzdXJlVGltZS5jbGFzc0xpc3QuYWRkKCdhbXN0X19tZWFzdXJlVGltZScpXHJcbiAgbWVhc3VyZVRpbWUuaW5uZXJIVE1MID0gJzxzcGFuPjAwOjAwPHNwYW4+J1xyXG4gIG1lYXN1cmVMb25nVGltZS5jbGFzc0xpc3QuYWRkKCdhbXN0X19tZWFzdXJlVGltZScpXHJcbiAgbWVhc3VyZUxvbmdUaW1lLmlubmVySFRNTCA9ICc8c3Bhbj4wMDowMDowMDxzcGFuPidcclxuICBkLmJvZHkuYXBwZW5kQ2hpbGQobWVhc3VyZVRpbWUpXHJcbiAgZC5ib2R5LmFwcGVuZENoaWxkKG1lYXN1cmVMb25nVGltZSlcclxuICB0aW1lV2lkdGggPSBtZWFzdXJlVGltZS5vZmZzZXRXaWR0aCArIDJcclxuICBsb25nVGltZVdpZHRoID0gbWVhc3VyZUxvbmdUaW1lLm9mZnNldFdpZHRoICsgMlxyXG4gIGQuYm9keS5yZW1vdmVDaGlsZChtZWFzdXJlVGltZSk7XHJcbiAgZC5ib2R5LnJlbW92ZUNoaWxkKG1lYXN1cmVMb25nVGltZSk7XHJcbiAgaWYgKHN0b3JhZ2UpIHtcclxuICAgIHN0b3JhZ2Uuc2V0SXRlbSgnYW1zdF90aW1lV2lkdGgnLCB0aW1lV2lkdGgpXHJcbiAgICBzdG9yYWdlLnNldEl0ZW0oJ2Ftc3RfbG9uZ1RpbWVXaWR0aCcsIGxvbmdUaW1lV2lkdGgpXHJcbiAgfVxyXG59XHJcbi8vSW5zZXJ0aW9uIGRlcyByw6hnbGVzIGTDqXRlcm1pbsOpZXMgZGFucyBsZSBET01cclxuY29uc3Qgc3R5bGUgPSBkLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxyXG4vLyBXZWJLaXQgaGFja1xyXG5zdHlsZS5hcHBlbmRDaGlsZChkLmNyZWF0ZVRleHROb2RlKFwiXCIpKVxyXG5kLmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpXHJcbnN0eWxlLnNoZWV0Lmluc2VydFJ1bGUoYC5hbXN0X190aW1lPnNwYW57d2lkdGg6JHt0aW1lV2lkdGh9cHg7YCwwKVxyXG5zdHlsZS5zaGVldC5pbnNlcnRSdWxlKGAuYW1zdF9fbG9uZyAuYW1zdF9fdGltZT5zcGFue3dpZHRoOiR7bG9uZ1RpbWVXaWR0aH1weDtgLDApXHJcblxyXG5cclxuLy9Ew6l0ZWN0aW9uIGRlIGxhIGZvbmN0aW9ubmFsaXTDqSBmdWxsc2NyZWVuIGV0IGRlIHNlcyDDqXZlbnR1ZWxzIHByw6lmaXhlc1xyXG5sZXQgZnVsbHNjcmVlbkFQSSA9IGZhbHNlXHJcbmlmIChzdG9yYWdlICYmIHN0b3JhZ2UuZ2V0SXRlbSgnYW1zdF9mdWxsc2NyZWVuQVBJJykgIT0gdW5kZWZpbmVkKSB7XHJcbiAgZnVsbHNjcmVlbkFQSSA9IEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKCdhbXN0X2Z1bGxzY3JlZW5BUEknKSlcclxufSBlbHNlIHtcclxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2NyZWVuZnVsbC5qcy9cclxuICAvL0TDqXRlY3Rpb24gZGVzIHByw6lmaXhlcyBwb3VyIGxhIGdlc3Rpb24gZHUgcGxlaW4gw6ljcmFuXHJcbiAgZnVsbHNjcmVlbkFQSSA9IChmdW5jdGlvbigpe1xyXG4gICAgbGV0IFxyXG4gICAgICB2YWwsXHJcbiAgICAgIGZuTWFwID0gW1xyXG4gICAgICAgIFsncmVxdWVzdEZ1bGxzY3JlZW4nLCAnZXhpdEZ1bGxzY3JlZW4nLCAnZnVsbHNjcmVlbkVsZW1lbnQnLCAnZnVsbHNjcmVlbmNoYW5nZSddLFxyXG4gICAgICAgIC8vIE5ldyBXZWJLaXRcclxuICAgICAgICBbJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJywgJ3dlYmtpdEV4aXRGdWxsc2NyZWVuJywgJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JywgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnXSxcclxuICAgICAgICAvLyBPbGQgV2ViS2l0IChTYWZhcmkgNS4xKVxyXG4gICAgICAgIFsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSddLFxyXG4gICAgICAgIFsnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLCAnbW96Q2FuY2VsRnVsbFNjcmVlbicsICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsICdtb3pmdWxsc2NyZWVuY2hhbmdlJ10sXHJcbiAgICAgICAgWydtc1JlcXVlc3RGdWxsc2NyZWVuJywgJ21zRXhpdEZ1bGxzY3JlZW4nLCAnbXNGdWxsc2NyZWVuRWxlbWVudCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnXVxyXG4gICAgICBdLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgbCA9IGZuTWFwLmxlbmd0aCxcclxuICAgICAgcmV0ID0ge31cclxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhbCA9IGZuTWFwW2ldXHJcbiAgICAgIGlmICh2YWwgJiYgdmFsWzFdIGluIGQpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICByZXRbZm5NYXBbMF1baV1dID0gdmFsW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9KSgpXHJcbiAgc3RvcmFnZS5zZXRJdGVtKCdhbXN0X2Z1bGxzY3JlZW5BUEknLCBKU09OLnN0cmluZ2lmeShmdWxsc2NyZWVuQVBJKSlcclxufVxyXG5cclxuLypcclxuUFLDiUZJWEVTIENTU1xyXG5Ew6lmaW5pdGlvbiBkZXMgcHLDqWZpeGVzIHByb3ByZXMgYXV4IG5hdmlnYXRldXJzXHJcbnBvdXIgbGVzIHByb3ByacOpdMOpcyB0cmFuc2Zvcm0gZXQgdHJhbnNpdGlvblxyXG5hZmluIGRlIHBvdXZvaXIgbGVzIGFqdXN0ZXIgZGFucyBqYXZhc2NyaXB0XHJcbmh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0cmV1bmVybGVpbi8yOTM1Nzk0XHJcbiovXHJcbmxldCB0cmFuc2l0aW9uUHJlZml4LCB0cmFuc2Zvcm1QcmVmaXhcclxuaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3RyYW5zaXRpb25QcmVmaXgnKSAhPSB1bmRlZmluZWQgJiYgc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3RyYW5zZm9ybVByZWZpeCcpICE9IHVuZGVmaW5lZCkge1xyXG4gIHRyYW5zaXRpb25QcmVmaXggPSBzdG9yYWdlLmdldEl0ZW0oJ2Ftc3RfdHJhbnNpdGlvblByZWZpeCcpXHJcbiAgdHJhbnNmb3JtUHJlZml4ID0gc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3RyYW5zZm9ybVByZWZpeCcpXHJcbn0gZWxzZSB7XHJcbiAgbGV0IEdldFZlbmRvclByZWZpeCA9IGZ1bmN0aW9uKGFycmF5T2ZQcmVmaXhlcykge1xyXG4gICAgbGV0IHRtcCA9IGQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcclxuICAgICAgICByZXN1bHQgPSAnJ1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheU9mUHJlZml4ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0bXAuc3R5bGVbYXJyYXlPZlByZWZpeGVzW2ldXSAhPSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgcmVzdWx0ID0gYXJyYXlPZlByZWZpeGVzW2ldXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICB0cmFuc2l0aW9uUHJlZml4ID0gR2V0VmVuZG9yUHJlZml4KFtcInRyYW5zaXRpb25cIiwgXCJtc1RyYW5zaXRpb25cIiwgXCJNb3pUcmFuc2l0aW9uXCIsIFwiV2Via2l0VHJhbnNpdGlvblwiLCBcIk9UcmFuc2l0aW9uXCJdKVxyXG4gIHRyYW5zZm9ybVByZWZpeCA9IEdldFZlbmRvclByZWZpeChbXCJ0cmFuc2Zvcm1cIiwgXCJtc1RyYW5zZm9ybVwiLCBcIk1velRyYW5zZm9ybVwiLCBcIldlYmtpdFRyYW5zZm9ybVwiLCBcIk9UcmFuc2Zvcm1cIl0pXHJcbiAgc3RvcmFnZS5zZXRJdGVtKCdhbXN0X3RyYW5zaXRpb25QcmVmaXgnLCB0cmFuc2l0aW9uUHJlZml4KVxyXG4gIHN0b3JhZ2Uuc2V0SXRlbSgnYW1zdF90cmFuc2Zvcm1QcmVmaXgnLCB0cmFuc2Zvcm1QcmVmaXgpXHJcbn1cclxuICBcclxuXHJcbi8qRMOJVEVDVEVDVElPTiBERVMgRUNSQU5TIFRBQ1RJTEVTXHJcbi8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cy9TdXBwb3J0aW5nX2JvdGhfVG91Y2hFdmVudF9hbmRfTW91c2VFdmVudCNFdmVudF9vcmRlclxyXG5Qb3VyIHJhcHBlbCwgbGEgc8OpcXVlbmNlIGRlcyDDqXbDqG5lbWVudHMgc3VyIHVuZSBzdXJmYWNlIHRhY3RpbGUgc2UgcHLDqXNlbnRlIGNvbW1lIHN1aXQgOlxyXG4gIC0gdG91Y2hzdGFydFxyXG4gIC0gWmVybyBvciBtb3JlIHRvdWNobW92ZSBldmVudHMsIGRlcGVuZGluZyBvbiBtb3ZlbWVudCBvZiB0aGUgZmluZ2VyKHMpXHJcbiAgLSB0b3VjaGVuZFxyXG4gIC0gbW91c2Vtb3ZlXHJcbiAgLSBtb3VzZWRvd25cclxuICAtIG1vdXNldXBcclxuICAtIGNsaWNrLlxyXG5Eb25jLCBzdXIgdW5lIHN1cmZhY2UgdGFjdGlsZSwgdG91Y2hzdGFydCBzZXJhIGTDqWNsZW5jaMOpIGF2YW50IG1vdXNlbW92ZVxyXG5ldCBzaSBsJ29uIGTDqXRlY3RlIHVuIG1vdXNlbW92ZSwgYydlc3QgYmVsIGV0IGJpZW4gcXVlIGwnb24gbidlc3QgcGFzIHN1ciB0YWN0aWxlLlxyXG5cclxuUGFyIGTDqWZhdXQsIGwnaW50ZXJmYWNlIGdyYXBoaXF1ZSBlc3Qgb3JpZW50w6llIHRvdWNoRGV2aWNlLlxyXG5TaSBsJ29uIGNvbnN0YXRlIHF1ZSBsJ29uIGVzdCBzdXIgbGUgZGlzcG9zaXRpZiBkZSBwb2ludGFnZSBuJ2VzdCBwYXMgdGFjdGlsZSxcclxub24gYXBwbGlxdWUgYXUgY29udGFpbmVyIHByaW5jaXBhbCB1bmUgY2xhc3Mgbm8tdG91Y2guXHJcbkNldHRlIGNsYXNzIGFzc3VyZSBsYSBwcmlzZSBlbiBjaGFyZ2UgZGUgbGEgcHNldWRvLWNsYXNzIGNzcyA6aG92ZXIuXHJcblBhciBhaWxsZXVycywgZWxsZSBvcMOocmUgdW5lIHLDqWR1Y3Rpb24gZGUgbW9pdGnDqSBkZXMgaGF1dGV1cnMgZGUgbGEgYmFycmUgdGVtcG9yZWxsZSBcclxuZXQgZHUgcG90ZW50aW9tw6h0cmUgZGUgdm9sdW1lIChzJ2lsIGVzdCBlbiBtb2RlIGhvcml6b250YWwpXHJcbmxvcnNxdWUgY2VzIMOpbMOpbWVudHMgbmUgc29udCBwYXMgc3Vydm9sw6lzIHBhciBsZSBwb2ludGV1ci5cclxuRGFucyBjZXR0ZSBjb25maWd1cmF0aW9uLCBsZSBzdXJ2b2wgZGUgbGEgYmFycmUgZGUgbGVjdHVyZSBhZmZpY2hlIGxhIHBvc2l0aW9uIHRlbXBvcmVsbGVcclxuZXQgbCfDqXZlbnR1ZWxsZSB2aWduZXR0ZSBjb3JyZXNwb25kYW50IMOgIGxhIHBvc2l0aW9uIGR1IHBvaW50ZXVyIGF1IGRlc3N1cyBkZSBjZXR0ZSBiYXJyZS5cclxuRGFucyBsYSBjb25maWd1cmF0aW9uIHRhY3RpbGUsIGMnZXN0IGxlIHNsaWRlIGhvcml6b250YWwgcXVpIGFzc3VyZSBjZXR0ZSBmb25jdGlvbm5hbGl0w6kgOlxyXG5sJ2luZm9ybWF0aW9uIHRlbXBvcmVsbGUgZXQgbGEgdmlnbmV0dGUgc29udCBhbG9ycyBhZmZpY2jDqWVzIGRhbnMgbGEgcGFydGllIHN1cMOpcmlldXJlIGRlIGxhIHZpZMOpby5cclxuXHJcbk9uIGTDqWNsYXJlIGRvbmMgdW5lIHZhcmlhYmxlIF9wb2ludGVyVHlwZSBldCBvbiBsdWkgYWZmZWN0ZSBsYSB2YWxldXIgJ3Vua25vd24nLlxyXG5PbiBwb3NlIHVuIHByZW1pZXIgw6ljb3V0ZXVyIHBvdXIgZMOpdGVjdGVyIHVuIMOpdmVudHVlbCBkw6lwbGFjZW1lbnQgZHUgcG9pbnRldXJcclxuZXQgdW4gc2Vjb25kIHN1ciBsJ8OpdsOobmVtZW50IHRvdWNoc3RhcnQuXHJcblNpIG9uIGTDqXRlY3RlIHVuIHRvdWNoc3RhcnQsIG9uIGRvbm5lIGxhIHZhbGV1ciAndG91Y2gnIMOgIGxhIHZhcmlhYmxlIF9wb2ludGVyVHlwZS5cclxuU2kgb24gZMOpdGVjdGUgdW4gZMOpcGxhY2VtZW50LCBvbiBwYXNzZSBsYSB2YWxldXIgJ21vdXNlJyDDoCBfcG9pbnRlclR5cGUuLlxyXG5BdXNzaXTDtHQgbGEgZMOpdGVjdGlvbiBlZmZlY3R1w6llLCBvbiBzdG9wcGUgbGVzIGRldXggw6ljb3V0ZXVycyBpbml0aWFsZW1lbnQgcG9zw6lzXHJcbmV0IG9uIHRyYW5zbWV0IGwnaW5mb3JtYXRpb24gYXV4IMOpdmVudHVlbGxlcyBpbnN0YW5jZXMgY3LDqcOpZXMgZW50cmV0ZW1wc1xyXG4qLyAgXHJcbmxldCBfcG9pbnRlclR5cGUgPSAndW5rbm93bidcclxuaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3BvaW50ZXJUeXBlJykpIHtcclxuICBfcG9pbnRlclR5cGUgPSBzdG9yYWdlLmdldEl0ZW0oJ2Ftc3RfcG9pbnRlclR5cGUnKVxyXG59IGVsc2V7XHJcbiAgY29uc3RcclxuICAgIHRlc3RQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICBfcG9pbnRlclR5cGUgPSAoZS5wb2ludGVyVHlwZSk/ZS5wb2ludGVyVHlwZTonbW91c2UnXHJcbiAgICAgIGNsZWFuVGVzdFBvaW50ZXIoKVxyXG4gICAgfSxcclxuICAgIHRlc3RUb3VjaFN0YXJ0ID0gZnVuY3Rpb24oKXtcclxuICAgICAgX3BvaW50ZXJUeXBlID0gJ3RvdWNoJ1xyXG4gICAgICBjbGVhblRlc3RQb2ludGVyKClcclxuICAgIH0sXHJcbiAgICBjbGVhblRlc3RQb2ludGVyID0gZnVuY3Rpb24oKXtcclxuICAgICAgc3RvcmFnZS5zZXRJdGVtKCdhbXN0X3BvaW50ZXJUeXBlJywgX3BvaW50ZXJUeXBlKVxyXG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIobXlQb2ludGVyTW92ZSwgdGVzdFBvaW50ZXJNb3ZlKVxyXG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0ZXN0VG91Y2hTdGFydClcclxuICAgICAgaWYgKEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIucGxheWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5wbGF5ZXJzLmZvckVhY2gocD0+cC5jb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3BvaW50ZXJEZXRlY3RlZCcpKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIHcuYWRkRXZlbnRMaXN0ZW5lcihteVBvaW50ZXJNb3ZlLCB0ZXN0UG9pbnRlck1vdmUsIGZhbHNlKVxyXG59XHJcblxyXG4vL0TDqXRlY3Rpb24gZHUgc3VwcG9ydCBkZSBsJ29wdGlvbiBwYXNzaXZlIHN1ciBsZXMgZXZlbnRzXHJcbi8vaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9FdmVudExpc3RlbmVyT3B0aW9ucy5wb2x5ZmlsbC5qc1xyXG5sZXQgX3N1cHBvcnRQYXNzaXZlRXZlbnRzID0gZmFsc2VcclxuaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZS5nZXRJdGVtKCdhbXN0X3N1cHBvcnRQYXNzaXZlRXZlbnRzJykpIHtcclxuICBfc3VwcG9ydFBhc3NpdmVFdmVudHMgPSBzdG9yYWdlLmdldEl0ZW0oJ2Ftc3Rfc3VwcG9ydFBhc3NpdmVFdmVudHMnKVxyXG59IGVsc2V7XHJcbiAgZC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsICgpPT57fSwge1xyXG4gICAgZ2V0IHBhc3NpdmUoKSB7XHJcbiAgICAgIF9zdXBwb3J0UGFzc2l2ZUV2ZW50cyA9IHRydWVcclxuICAgICAgc3RvcmFnZS5zZXRJdGVtKCdhbXN0X3N1cHBvcnRQYXNzaXZlRXZlbnRzJywgX3N1cHBvcnRQYXNzaXZlRXZlbnRzKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICBEw4lCVVQgQ0xBU1MgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW1zdHJhbWdyYW1WaWRlb1BsYXllciB7XHJcbiAgLypGb25jdGlvbiBzdGF0aXF1ZSBwZXJtZXR0YW50IGRlIHJlZMOpZmluaXIgbGVzIG9wdGlvbnMgcGFyIGTDqWZhdXQgXHJcbiAgICBVc2FnZSA6IFxyXG4gICAgICBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLm9wdGlvbnMoe3ZvbHVtZTowfSlcclxuICAgICAgbGV0IHBsYXllciA9IG5ldyBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJykpXHJcbiAgKi9cclxuICBzdGF0aWMgb3B0aW9ucyhvYmope1xyXG4gICAgaWYgKEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIucGxheWVycy5sZW5ndGggPT0gMCkgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5kZWZhdWx0T3B0aW9ucyA9IG1lcmdlRGVlcChBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmRlZmF1bHRPcHRpb25zLCBvYmopXHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihlbCwgcGFyYW1zKSB7XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgIFLDiUNVUMOJUkFUSU9OIEVUICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgVFJBSVRFTUVOVCBERVMgUEFSQU3DiFRSRVMgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLypcclxuICAgICAgUsOpY3Vww6lyYXRpb24gZGVzIGF0dHJpYnV0cyBIVE1MIMOpdmVudHVlbHMgZGUgbCfDqWzDqW1lbnQuIFxyXG4gICAgICBPbiBuZSByZXRpZW50IHF1ZSBjZXV4IHF1aSBub3VzIGludMOpcmVzc2VudCwgw6Agc2F2b2lyIDpcclxuICAgICAgLSBhdXRvcGxheVxyXG4gICAgICAtIGNyb3Nzb3JpZ2luXHJcbiAgICAgIC0gbG9vcFxyXG4gICAgICAtIG11dGVkXHJcbiAgICAgIC0gcGxheXNpbmxpbmVcclxuICAgICAgLSBwb3N0ZXJcclxuICAgICAgLSBwcmVsb2FkXHJcbiAgICAgIC0gc3JjXHJcblxyXG5cclxuICAgIEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcclxuICAgICAgY3Jvc3NvcmlnaW46ICdhbm9ueW1vdXMnLFxyXG4gICAgICBkb3dubG9hZDoge2xhYmVsOidUw6lsw6ljaGFyZ2VyJywgZGlzYWJsZWQ6ZmFsc2UsIGhpZGRlbjpmYWxzZX0sXHJcbiAgICAgIGR1cmF0aW9uOiAxMjAsXHJcbiAgICAgIGZvcm1hdDogMTYvOSxcclxuICAgICAgZnVsbHNjcmVlbjoge2xhYmVsOntlbnRlcjonUGxlaW4gw6ljcmFuJywgZXhpdDonUXVpdHRlciBsZSBwbGVpbiDDqWNyYW4nfSwgZGlzYWJsZWQ6ZmFsc2UsIGhpZGRlbjpmYWxzZX0sXHJcbiAgICAgIGxvb3A6IGZhbHNlLFxyXG4gICAgICBuZXh0OiB7bGFiZWw6J1N1aXZhbnQnLCBkaXNhYmxlZDp0cnVlLCBoaWRkZW46dHJ1ZX0sXHJcbiAgICAgIHBsYXlzaW5saW5lOiB0cnVlLFxyXG4gICAgICBwb3N0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgcHJlbG9hZDogJ25vbmUnLFxyXG4gICAgICBwcmV2aW91czoge2xhYmVsOidQcsOpY8OpZGVudCcsIGRpc2FibGVkOnRydWUsIGhpZGRlbjp0cnVlfSxcclxuICAgICAgc2tpcFRpbWU6ICcxJScsXHJcbiAgICAgIHRodW1ibmFpbHM6IHtzcmM6dW5kZWZpbmVkLCBudW1iZXI6MTAwfSxcclxuICAgICAgdm9sdW1lOiAwLjgsXHJcbiAgICAgIHZvbHVtZUJ1dHRvbjoge2xhYmVsOnttdXRlOidEw6lzYWN0aXZlciBsZSBzb24nLCB1bm11dGU6J0FjdGl2ZXIgbGUgc29uJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LFxyXG4gICAgICAvL1BsYXllcnMgcHJvcGVydGllc1xyXG4gICAgICB2b2x1bWVHcm91cDogMCxcclxuICAgICAgaGlkZUNvbnRyb2xzRGVsYXk6IDUwMDAsXHJcbiAgICAgIHZpZGVvVm9sdW1lT3JpZW50YXRpb246ICd2ZXJ0aWNhbCcsXHJcbiAgICAgIHJhaWxNaW5XaWR0aEZvck5vcm1hbFVJOiA2MDAsXHJcbiAgICAgIC8vR2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgYXBwTGFiZWw6J0xlY3RldXIgVmlkw6lvJyxcclxuICAgICAgcGF1c2VMYWJlbDonUGF1c2UnLFxyXG4gICAgICBwbGF5TGFiZWw6J0xlY3R1cmUnLFxyXG4gICAgICB2b2x1bWVIZWxwTGFiZWw6J1V0aWxpc2V6IGxlcyBmbMOoY2hlcyBIYXV0L0JhcyBkdSBjbGF2aWVyIHBvdXIgYXVnbWVudGVyIG91IGRpbWludWVyIGxlIHZvbHVtZS4nLFxyXG4gICAgICB2b2x1bWVTbGlkZXJMYWJlbDonUG90ZW50aW9tw6h0cmUgZGUgdm9sdW1lJyxcclxuICAgIH1cclxuICAqL1xyXG5cclxuICAgIC8vYm9vbGVhbkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dHMgZGUgdmFsZXVyIHZpZGUuIFMnaWxzIHNvbnQgcHLDqXNlbnRzLCBsZSBwYXJhbcOodHJlIGNvcnJlc3BvbmRhbnQgZXN0IHBhc3PDqSDDoCB0cnVlLlxyXG4gICAgLy9MYSBwcm9wcmnDqXTDqSBtdXRlZCBzaSBlbGxlIGVzdCBwcsOpc2VudGUgc2VyYSBjb252ZXJ0aWUgZW4gdm9sdW1lID0gMFxyXG4gICAgLy9MZXMgMyBhdXRyZXMgc2Vyb250IGFwcGxpcXXDqWVzIMOgIGwnw6lsw6ltZW50IGNvbnN0cnVpdFxyXG4gICAgY29uc3QgYm9vbGVhbkF0dHJpYnV0ZXMgPSBbJ2F1dG9wbGF5JywgJ2xvb3AnLCAnbXV0ZWQnLCAncGxheXNpbmxpbmUnXVxyXG4gICAgLy9MZXMgYXV0cmVzIGF0dHJpYnV0cyDDoCByw6ljdXDDqXJlciA6XHJcbiAgICBsZXQgYXR0cmlidXRlcyA9IGJvb2xlYW5BdHRyaWJ1dGVzLmNvbmNhdChbJ2Nyb3Nzb3JpZ2luJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3NyYyddKVxyXG4gICAgLy9odHRwczovL2Rhdmlkd2Fsc2gubmFtZS9qYXZhc2NyaXB0LWF0dHJpYnV0ZXMjY29tbWVudC01MTE3ODZcclxuICAgIHRoaXMucGFyYW1zID0gZWwuZ2V0QXR0cmlidXRlTmFtZXMoKS5yZWR1Y2UoKG9iaiwgbmFtZSk9PntcclxuICAgICAgaWYgKGF0dHJpYnV0ZXMuaW5jbHVkZXMobmFtZSkpIHtcclxuICAgICAgICAvL3NpIGwnYXR0cmlidXQgdHJhaXTDqSBub3VzIGludMOpcmVzc2UsIG9uIHBhc3NlIHNhIHZhbGV1ciBhdSBwYXJhbcOodHJlIHF1aSBsdWkgY29ycmVzcG9uZC5cclxuICAgICAgICBvYmpbbmFtZV0gPSBib29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcyhuYW1lKT90cnVlOmVsLmdldEF0dHJpYnV0ZShuYW1lKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9LCB7fSlcclxuICAgIC8vQ29udmVyc2lvbiBkZSBtdXRlZCBlbiB2b2x1bWUgbnVsXHJcbiAgICBpZiAodGhpcy5wYXJhbXMubXV0ZWQpIHtcclxuICAgICAgdGhpcy5wYXJhbXMudm9sdW1lID0gMFxyXG4gICAgICBkZWxldGUgdGhpcy5wYXJhbXMubXV0ZWRcclxuICAgIH1cclxuICAgIC8vU2kgbGVzIGF0dHJpYnV0cyB3aWR0aCBldCBoZWlnaHQgc29udCBwcsOpc2VudHMgZXQgb250IHVuIHNlbnMsXHJcbiAgICAvL29uIGVuIGTDqWR1aXQgbGUgZm9ybWF0XHJcbiAgICBpZiAocGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSA+IDAgJiYgcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkgPiAwKSB7XHJcbiAgICAgIHRoaXMucGFyYW1zLmZvcm1hdCA9IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkgLyBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKVxyXG4gICAgfVxyXG4gICAgLy9PbiBzdXBwcmltZSBtdXRlZCBkZSBsYSBsaXN0ZSBkZXMgYXR0cmlidXRzIMOgIHRyYWl0ZXJcclxuICAgIC8vT24gcmFqb3V0ZSBsZXMgcHJvcHJpw6l0w6lzIHN1c2NlcHRpYmxlcyBkJ8OqdHJlIHBhc3PDqWVzIGxvcnMgZGUgbGEgY3LDqWF0aW9uIGRlIGwnaW5zdGFuY2VcclxuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmZpbHRlcihwYXJhbT0+e3JldHVybiBwYXJhbSAhPSAnbXV0ZWQnfSkuY29uY2F0KFsnZG93bmxvYWQnLCAnZHVyYXRpb24nLCAnZm9ybWF0JywgJ2Z1bGxzY3JlZW4nLCAnaGlkZUNvbnRyb2xzRGVsYXknLCAnbmV4dCcsICdwcmV2aW91cycsICdza2lwVGltZScsICd0aHVtYm5haWxzJywgJ3ZpZGVvVm9sdW1lT3JpZW50YXRpb24nLCAndm9sdW1lJywgJ3ZvbHVtZUJ1dHRvbicsICd2b2x1bWVGb3JjZWQnLCAndm9sdW1lR3JvdXAnLCAncmFpbE1pbldpZHRoRm9yTm9ybWFsVUknXSlcclxuICAgIC8vU2kgZGVzIHBhcmFtw6h0cmVzIG9udCDDqXTDqSBwYXNzw6lzIMOgIGwnaW5zdGFuY2UsIGlscyBwcmltZW50IHN1ciBjZXV4IHF1aSBzb250IGTDqWZpbmlzIHBhciBsZXMgYXR0cmlidXRzLlxyXG4gICAgLy9PbiDDqWxpbWluZSB0b3V0ZSBwcm9wcmnDqXTDqSBxdWkgbidhdXJhaXQgcmllbiDDoCBmYWlyZSBsw6AgZW4gbmUgcmV0ZW5hbnQgcXVlIGNlbGxlcyBxdWkgc29udCBsaXN0w6llcyBkYW5zIGxlIHRhYmxlYXUgYXR0cmlidXRlc1xyXG4gICAgaWYgKHBhcmFtcykgXHJcbiAgICAgIHBhcmFtcyA9IE9iamVjdFxyXG4gICAgICAgIC5rZXlzKHBhcmFtcylcclxuICAgICAgICAuZmlsdGVyKGtleT0+YXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpKVxyXG4gICAgICAgIC5yZWR1Y2UoKHJlcywga2V5KT0+KHJlc1trZXldID0gcGFyYW1zW2tleV0sIHJlcyksIHt9KVxyXG4gICAgLy9PbiBtZXJnZSBsZXMgcGFyYW3DqHRyZXMgZGUgbCdpbnN0YW5jZSBhdmVjIGNldXggZGUgbGEgcGFnZSBIVE1MXHJcbiAgICBpZiAocGFyYW1zKSB0aGlzLnBhcmFtcyA9IG1lcmdlRGVlcCh0aGlzLnBhcmFtcywgcGFyYW1zKVxyXG4gICAgdGhpcy5wYXJhbXMgPSBtZXJnZURlZXAoQW1zdHJhbWdyYW1WaWRlb1BsYXllci5kZWZhdWx0T3B0aW9ucywgdGhpcy5wYXJhbXMpXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICBGSU4gUsOJQ1VQw4lSQVRJT04gRVQgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgVFJBSVRFTUVOVCBERVMgUEFSQU3DiFRSRVMgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgQ09OU1RSVUNUSU9OIEhUTUwgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBjb25zdCBcclxuICAgICAgd3JhcHBlciA9IGQuY3JlYXRlRWxlbWVudCgnZGl2JyksLy/DiWzDqW1lbnQgd3JhcHBlciByZW5mZXJtYW50IHRvdXMgbGVzIMOpbMOpbWVudHMgSFRNTCBkdSBsZWN0ZXVyXHJcbiAgICAgIC8vU2kgbGUgcGFyYW3DqHRyZSBkJ29yaWVudGF0aW9uIGR1IHBvdGVudGlvbWV0cmUgZGUgdm9sdW1lIGVzdCBkw6lmaW5pIGF1dHJlbWVudCBxdWUgcGFyIGxhIGNoYWluZSAnaG9yaXpvbnRhbCcsIFxyXG4gICAgICAvL29uIGZpeGUgc2EgdmFsZXVyIMOgICd2ZXJ0aWNhbCdcclxuICAgICAgdmlkZW9Wb2x1bWVPcmllbnRhdGlvbiA9ICh0aGlzLnBhcmFtcy52aWRlb1ZvbHVtZU9yaWVudGF0aW9uPT0naG9yaXpvbnRhbCcpPydob3Jpem9udGFsJzondmVydGljYWwnLFxyXG4gICAgICBwYXNzaXZlID0gX3N1cHBvcnRQYXNzaXZlRXZlbnRzXHJcblxyXG4gICAgLy9Db25zdHJ1Y3Rpb24gZGVzIMOpbMOpbWVudHMgSFRNTCBkZSBsJ1VJIGVuIGZvbmN0aW9uIGRlcyBwYXJhbcOodHJlc1xyXG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhbXN0X193cmFwcGVyJykgIFxyXG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhbXN0X192aWRlbycpICBcclxuICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gYnVpbGRVSSh0aGlzLnBhcmFtcylcclxuICAgIC8vSW5zZXJ0aW9uIGR1IHdyYXBwZXIgZGFucyBsZSBET01cclxuICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIGVsKVxyXG4gICAgLy9Qb3VyIMOpdml0ZXIgdG91dCBwcm9ibMOobWUgc291cyBBbmRyb8OvZCwgb24gcmVzZXQgbGEgc291cmNlIGRlIGwnw6lsw6ltZW50IG9yaWdpbmFsXHJcbiAgICAvL2F2YW50IGRlIGxlIHN1cHByaW1lclxyXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKVxyXG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcclxuICAgIFxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgRklOIENPTlNUUlVDVElPTiBIVE1MICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICBEw4lDTEFSQVRJT05TIERFUyBWQVJJQUJMRVMgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvL0NvbnN0YW50ZXNcclxuICAgIGNvbnN0IFxyXG4gICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgJCA9IF8kKHdyYXBwZXIpLC8vRMOpZmluaXRpb24gZGUgbGEgZm9uY3Rpb24gJCA6ICQoJ3ZpZGVvJykgcmVudm9pZSBsZSBwcmVtaWVyIMOpbMOpbWVudCBIVE1MIHZpZGVvIGNvbnRlbnUgZGFucyBsZSB3cmFwcGVyXHJcbiAgICAgICQkID0gXyQkKHdyYXBwZXIpLC8vRMOpZmluaXRpb24gZGUgbGEgZm9uY3Rpb24gJCQgOiAkJCgnLmFtc3RfX2xheWVyJykgcmVudm9pZSB1biB0YWJsZWF1IGRlcyDDqWzDqW1lbnRzIHBvcnRhbnQgbGEgY2xhc3NlIGFtc3RfX2xheWVyXHJcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSA9ICQoJ3ZpZGVvJyksXHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyID0gJCgnLmFtc3RfX2NvbnRhaW5lcicpLFxyXG4gICAgICBsYXllclBvc3RlciA9ICAkKCcuYW1zdF9fbGF5ZXItcG9zdGVyJyksXHJcbiAgICAgIGxheWVyUG9zdGVyQ2FudmFzID0gICQoJy5hbXN0X19sYXllci1wb3N0ZXIgY2FudmFzJyksXHJcbiAgICAgIGxheWVyU2Vla2luZ1RvdWNoID0gJCgnLmFtc3RfX2xheWVyLXNlZWtpbmctdG91Y2gnKSxcclxuICAgICAgc2Vla2luZ1RvdWNoID0gJCgnLmFtc3RfX3NlZWtpbmctdG91Y2gnKSxcclxuICAgICAgbGF5ZXJQbGF5ID0gJCgnLmFtc3RfX2xheWVyLXBsYXknKSxcclxuICAgICAgbGF5ZXJMb2FkaW5nID0gJCgnLmFtc3RfX2xheWVyLWxvYWRpbmcnKSxcclxuICAgICAgY29udHJvbHMgPSAkKCcuYW1zdF9fY29udHJvbHMnKSxcclxuICAgICAgY29udHJvbHNQYWRkaW5nID0gMiAqIGNvbnRyb2xzLmNzcygncGFkZGluZy1sZWZ0JyksXHJcbiAgICAgIHBsYXlQYXVzZUJ1dHRvbiA9ICQoJy5hbXN0X19wbGF5cGF1c2U+YnV0dG9uJyksXHJcbiAgICAgIHJhaWwgPSAkKCcuYW1zdF9fcmFpbCcpLFxyXG4gICAgICBzbGlkZXIgPSAkKCcuYW1zdF9fc2xpZGVyJyksXHJcbiAgICAgIGhhbmRsZSA9ICQoJy5hbXN0X19oYW5kbGUnKSxcclxuICAgICAgdGltZUN1cnJlbnQgPSAkKCcuYW1zdF9fY3VycmVudHRpbWUtYmFyJyksXHJcbiAgICAgIHNlZWtpbmcgPSAkKCcuYW1zdF9fc2Vla2luZycpLFxyXG4gICAgICB2b2x1bWVCdXR0b24gPSAkKCcuYW1zdF9fdm9sdW1lYnV0dG9uIGJ1dHRvbicpLFxyXG4gICAgICB2b2x1bWVTbGlkZXIgPSAkKCcuYW1zdF9fdm9sdW1lLXNsaWRlcicpXHJcblxyXG4gICAgICBcclxuICAgIC8vVmFyaWFibGVzXHJcbiAgICBsZXQgLy9MYXJnZXVyIGR1IGxlY3RldXIgYWN0dWFsaXPDqWUgc3VyIGwnw6l2w6huZW1lbnQgcmVzaXplIFxyXG4gICAgICAgIC8vZXQgbsOpY2Vzc2FpcmUgcG91ciBwb3NpdGlvbm5lciBsYSB2aWduZXR0ZSBkZSBwcmV2aWV3IHN1ciB0YWN0aWxlXHJcbiAgICAgICAgcGxheWVyV2lkdGgsXHJcbiAgICAgICAgLy9Qb3NpdGlvbiBldCBkaW1lbnNpb25zIGRlIGwnw6lsw6ltZW50IHZvbHVtZSByZWNhbGN1bMOpZXMgbG9ycyBkJ3VuIMOpdsOobmVtZW50IHJlc2l6ZSBvdSBzY3JvbGxcclxuICAgICAgICB2b2x1bWVSZWN0LFxyXG4gICAgICAgIC8vQWJzY2lzc2UgZXQgbGFyZ2V1ciBkZSBsJ8OpbMOpbWVudCBzbGlkZXIgcmVjYWxjdWzDqWVzIGxvcnMgZCd1biDDqXbDqG5lbWVudCByZXNpemUgb3Ugc2Nyb2xsXHJcbiAgICAgICAgc2xpZGVyTGVmdCwgc2xpZGVyV2lkdGgsXHJcbiAgICAgICAgLy9MYXJnZXVyIGN1bXVsw6llIGRlcyDDqWzDqW1lbnRzIHZpc2libGVzIGRhbnMgbGEgYmFycmUgZGUgY29udHLDtGxlIMOgIGwnZXhjbHVzaW9uIGR1IHNsaWRlclxyXG4gICAgICAgIC8vZG9udCBvbiBwZXV0IGTDqWR1aXJlIGxhIGxhcmdldXIgZGlzcG9uaWJsZSBwb3VyIGxlIHNsaWRlci5cclxuICAgICAgICAvL0xhcmdldXJEaXNwb25pYmxlID0gcGxheWVyV2lkdGggLSBjb250cm9sc0VsZW1lbnRzV2lkdGggLSBjb250cm9sc1BhZGRpbmdcclxuICAgICAgICAvL1NpIGNldHRlIHZhbGV1ciBlc3QgaW5mw6lyaWV1cmUgw6AgY2VsbGUgZG9ubsOpZSBwYXIgbCdvcHRpb24gcmFpbE1pbldpZHRoRm9yTm9ybWFsVUksXHJcbiAgICAgICAgLy9vbiBiYXNjdWxlIHZlcnMgbCdpbnRlcmZhY2UgcsOpZHVpdGUuXHJcbiAgICAgICAgY29udHJvbHNFbGVtZW50c1dpZHRoLFxyXG4gICAgICAgIHRpbWVvdXRHZXRDb250cm9sc0VsZW1lbnRzV2lkdGgsXHJcbiAgICAgICAgLy9BbmltYXRpb24gZGUgbGEgYmFycmUgdGVtcG9yZWxsZVxyXG4gICAgICAgIHVwZGF0ZVRpbWVSYWlsQW5pbWF0aW9uLFxyXG4gICAgICAgIC8vVmFyaWFibGUgbWlzZSDDoCBqb3VyIHN1ciBsJ8OpdsOobmVtZW50IGR1cmF0aW9uY2hhbmdlIGF1IGNhcyBvw7kgbCdvcHRpb24gc2tpcFRpbWUgYWl0IMOpdMOpIGRvbm7DqWUgZW4gcG91cmNlbnRhZ2UuXHJcbiAgICAgICAgLy9FbGxlIHJldGllbnQgbGEgdmFsZXVyIGR1IHNraXAgw6AgZWZmZWN0dWVyIGV4cHJpbcOpZSBlbiBzZWNvbmRlc1xyXG4gICAgICAgIHNraXBUaW1lLFxyXG4gICAgICAgIC8vRW5yZWdpc3RyZSBsYSBwb3NpdGlvbiB0ZW1wb3JlbGxlIGNvdXJhbnRlIGRlIGxhIHZpZMOpbyBhcnJvbmRpZSDDoCBsYSBzZWNvbmRlIGluZsOpcmlldXJlLlxyXG4gICAgICAgIC8vTGUgY2FzIMOpY2jDqWFudCwgcGVybWV0IGRlIHJlbGFuY2VyIGxhIGxlY3R1cmUgZGUgbGEgdmlkw6lvIMOgIGwnZW5kcm9pdCBvw7kgZWxsZSBhIMOpdMOpXHJcbiAgICAgICAgLy9zdG9wcMOpZSBwYXIgbGUgbGFuY2VtZW50IGQndW4gYXV0cmUgbGVjdGV1ci5cclxuICAgICAgICBmbG9vckN1cnJlbnRUaW1lID0gMCxcclxuICAgICAgICAvL1ZhcmlhYmxlIG1pc2Ugw6Agam91ciBzdXIgbCfDqXbDqW5lbWVudCB0aW1ldXBkYXRlXHJcbiAgICAgICAgLy9Qcm92b3F1ZSB1biByZXNldCBkZSBsJ2FuaW1hdGlvbiBkZSBsYSBiYXJyZSB0ZW1wb3JlbGxlIFxyXG4gICAgICAgIC8vc2kgZWxsZSBkaWZmw6hyZSBkZSBwbHVzIGQndW5lIGRlbWkgc2Vjb25kZSBkZSBsYSBwb3NpdGlvbiB0ZW1wb3JlbGxlIGVmZmVjdGl2ZVxyXG4gICAgICAgIHByZXZDdXJyZW50VGltZSA9IDAsXHJcbiAgICAgICAgLy9WYXJpYWJsZSBlbnJlZ2lzdHJhbnQgbGEgcHLDqXNlbmNlIGR1IHBvaW50ZXVyIHN1ciBsZXMgY29udHLDtGxlcy5cclxuICAgICAgICAvL1NpIHRydWUsIG9uIGJsb3F1ZSBsYSBkaXNwYXJpdGlvbiBkZSBsYSBiYXJyZSBkZSBjb250csO0bGUuXHJcbiAgICAgICAgcG9pbnRlck92ZXJDb250cm9scyA9IGZhbHNlLFxyXG4gICAgICAgIC8vU3RvY2tlIGxlIGJ1ZmZlciBkdSBtw6lkaWFcclxuICAgICAgICAvL1NpIG9uIGTDqXRlY3RlIHVuZSBkaWZmw6lyZW5jZSBlbnRyZSBidWZmZXJlZCBldCBtZWRpYS5idWZmZXJlZFxyXG4gICAgICAgIC8vb24gcmVjb25zdHJ1aXQgbGVzIHpvbmVzIHJlY3Rhbmd1bGFpcmVzIHF1aSBtZXR0ZW50IGVuIMOpdmlkZW5jZSBsZXMgcGFydGllcyBjaGFyZ8OpZXMgZGFucyBsYSBiYXJyZSB0ZW1wb3JlbGxlLlxyXG4gICAgICAgIGJ1ZmZlcmVkLFxyXG4gICAgICAgIC8vVmFyaWFibGUgcGFzc8OpZSDDoCB0cnVlIHN1ciBsZXMgw6l2w6luZW1lbnRzIHNlZWtpbmcsIHdhaXRpbmcgZXQgbG9hZGVkZGF0YS5cclxuICAgICAgICAvL1NpIHRydWUsIG9uIGJsb3F1ZSBsYSBkaXNwYXJpdGlvbiBkZSBsYSBiYXJyZSBkZSBjb250csO0bGUuXHJcbiAgICAgICAgLy9SZXRvdXJuZSDDoCBmYWxzZSBzdXIgbGVzIMOpdsOpbmVtZW50cyBwbGF5LCBwbGF5aW5nLCBzZWVrZWQgZXQgY2FucGxheVxyXG4gICAgICAgIGlzQnVmZmVyaW5nID0gZmFsc2UsXHJcbiAgICAgICAgLy9zZXRUaW1lb3V0IGNvbnRyw7RsYW50IGxhIGRpc3Bhcml0aW9uIGRlIGxhIGJhcnJlIGRlIGNvbnRyw7RsZVxyXG4gICAgICAgIGhpZGVDb250cm9sc1RpbWVPdXQsXHJcbiAgICAgICAgLy9MYXJnZXVyIGRlIGwnw6lsw6ltZW50IHNlZWtpbmcgPSAkKCcuYW1zdF9fc2Vla2luZycpLCBhY3R1YWxpc8OpZSBhdSBwcmVtaWVyIG1vdXZlbWVudCBkZSBsYSBzb3VyaXMgc3VyIGxhIGJhcnJlIHRlbXBvcmVsbGVcclxuICAgICAgICAvL05lY2Vzc2FpcmUgcG91ciBwb3NpdGlvbm5lciBsJ8OpbMOpbWVudCBhaW5zaSBxdWUgc29uIGJhY2tncm91bmRcclxuICAgICAgICBzZWVraW5nV2lkdGgsXHJcbiAgICAgICAgLy9MYXJnZXVyIGRlIGwnw6lsw6ltZW50IHNlZWtpbmdUb3VjaCA9ICQoJy5hbXN0X19zZWVraW5nLXRvdWNoJyksIGFjdHVhbGlzw6llIGF1IHByZW1pZXIgc3dpcGUgaG9yaXpvbnRhbCBzdXIgbGEgdmlkw6lvXHJcbiAgICAgICAgLy9OZWNlc3NhaXJlIHBvdXMgcG9zaXRpb25uZXIgbCfDqWzDqW1lbnQgYWluc2kgcXVlIHNvbiBiYWNrZ3JvdW5kXHJcbiAgICAgICAgc2Vla2luZ1RvdWNoV2lkdGgsXHJcbiAgICAgICAgLy9MYXJnZXVyIGRlIGxhIHZpZ25ldHRlIGTDqXRlcm1pbsOpZSBhcHLDqHMgbGUgY2hhcmdlbWVudCBkZSBsJ2ltYWdlIHNww6ljaWZpw6llIFxyXG4gICAgICAgIC8vZW4gZGl2aXNhbnQgbGEgbGFyZ2V1ciBkZSBjZXR0ZSBpbWFnZSBwYXIgbGUgbm9tYnJlIGRlIHZpZ25ldHRlcyBkw6ljbGFyw6kgZW4gcGFyYW3DqHRyZVxyXG4gICAgICAgIHRodW1iV2lkdGggPSAwLFxyXG4gICAgICAgIHZvbHVtZUJlZm9yZU11dGVcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgRklOIElOU0VSVElPTiBEQU5TIExFIERPTSAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgIFBMQVkgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIC8vRm9uY3Rpb24gZMOpY2xlbmNow6llIHBhciBsJ8OpdsOobmVtZW50ICdhbXN0RXZlbnRfX3BsYXknIGfDqW7DqXLDqSBwYXIgbGEgbcOpdGhvZGUgcHVibGlxdWUgcGxheSgpXHJcbiAgICBmdW5jdGlvbiBfcGxheSgpe1xyXG4gICAgICAvL2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTYvMDMvcGxheS1yZXR1cm5zLXByb21pc2VcclxuICAgICAgbGV0IHBsYXlQcm9taXNlID0gbWVkaWEucGxheSgpXHJcbiAgICAgIGlmIChwbGF5UHJvbWlzZSkgcGxheVByb21pc2UuY2F0Y2goKCk9Pl9wYXVzZSgpKVxyXG4gICAgICAvL1NpIHVuZSBhdXRyZSBpbnN0YW5jZSBlc3QgZW4gY291cnMgZGUgbGVjdHVyZSwgb24gbGEgcmVzZXRcclxuICAgICAgaWYgKEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudFBsYXllciAmJiBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmN1cnJlbnRQbGF5ZXIgIT0gc2VsZikgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5jdXJyZW50UGxheWVyLnJlc2V0KClcclxuICAgICAgLy9PbiBkw6ljbGFyZSBsJ2luc3RhbmNlIGNvbW1lIGxlY3RldXIgY291cmFudFxyXG4gICAgICBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmN1cnJlbnRQbGF5ZXIgPSBzZWxmXHJcbiAgICAgIGNvbnRhaW5lci5mb2N1cygpXHJcbiAgICAgIC8vTWlzZSDDoCBqb3VyIGR1IGJvdXRvblxyXG4gICAgICBwbGF5UGF1c2VCdXR0b24uc2V0QXR0cmlidXRlcyh7XHJcbiAgICAgICAgY2xhc3M6ICdhbXN0X19wYXVzZScsXHJcbiAgICAgICAgdGl0bGU6IHNlbGYucGFyYW1zLnBhdXNlTGFiZWwsXHJcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiBzZWxmLnBhcmFtcy5wYXVzZUxhYmVsXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vT24gY2FjaGUgbGUgbGF5ZXIgY29tcHJlbmFudCBsZSBncm9zIGJvdXRvbiBwbGF5XHJcbiAgICAgIGxheWVyUGxheS5jbGFzc0xpc3QuYWRkKCdhbXN0X19oaWRkZW4nKVxyXG4gICAgICAvL09uIHByb2dyYW1tZSBsYSBkaXNwYXJpdGlvbiBkZSBsYSBiYXJyZSBkZSBjb250cm9sZVxyXG4gICAgICBpZiAoIXBvaW50ZXJPdmVyQ29udHJvbHMpIF9oaWRlQ29udHJvbHMoe2RldGFpbDp7ZGVsYXllZDp0cnVlfX0pXHJcbiAgICB9XHJcbiAgICAvL09uIMOpY291dGUgbCfDqXbDqG5lbWVudCAnYW1zdEV2ZW50X19wbGF5JyBnw6luw6lyw6kgcGFyIGxhIG3DqXRob2RlIHBsYXkoKVxyXG4gICAgY29udGFpbmVyLm9uKCdhbXN0RXZlbnRfX3BsYXknLCBfcGxheSwgZmFsc2UpXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgIEZJTiBQTEFZICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICBQQVVTRSAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLy9Gb25jdGlvbiBkw6ljbGVuY2jDqWUgcGFyIGwnw6l2w6huZW1lbnQgJ2Ftc3RFdmVudF9fcGF1c2UnIGfDqW7DqXLDqSBwYXIgbGEgbcOpdGhvZGUgcHVibGlxdWUgcGF1c2UoKVxyXG4gICBmdW5jdGlvbiBfcGF1c2UoKXtcclxuICAgICAgbWVkaWEucGF1c2UoKVxyXG4gICAgICAvL01pc2Ugw6Agam91ciBkdSBib3V0b25cclxuICAgICAgcGxheVBhdXNlQnV0dG9uLnNldEF0dHJpYnV0ZXMoe1xyXG4gICAgICAgIGNsYXNzOiAnJyxcclxuICAgICAgICB0aXRsZTogc2VsZi5wYXJhbXMucGxheUxhYmVsLFxyXG4gICAgICAgICdhcmlhLWxhYmVsJzogc2VsZi5wYXJhbXMucGxheUxhYmVsXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vT24gYWZmaWNoZSBsZSBsYXllciBjb21wcmVuYW50IGxlIGdyb3MgYm91dG9uIHBsYXlcclxuICAgICAgbGF5ZXJQbGF5LmNsYXNzTGlzdC5yZW1vdmUoJ2Ftc3RfX2hpZGRlbicpXHJcbiAgICAgIC8vT24gYWZmaWNoZSBsYSBiYXJyZSBkZSBjb250csO0bGUuXHJcbiAgICAgIF9zaG93Q29udHJvbHMoKVxyXG4gICAgICBjb250YWluZXIuZm9jdXMoKVxyXG4gICAgfVxyXG4gICAgLy9PbiDDqWNvdXRlIGxlIGN1c3RvbSBldmVudCAnYW1zdEV2ZW50X19wYXVzZScgZ8OpbsOpcsOpIHBhciBsYSBtw6l0aG9kZSBwYXVzZSgpXHJcbiAgICBjb250YWluZXIub24oJ2Ftc3RFdmVudF9fcGF1c2UnLCBfcGF1c2UsIGZhbHNlKVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICBGSU4gUEFVU0UgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgUkVTRVQgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGZ1bmN0aW9uIF9yZXNldCgpe1xyXG4gICAgICAvKkxhIGZvbmN0aW9uIGVzdCBhcHBlbMOpZSBzaSB1bmUgYXV0cmUgaW5zdGFuY2UgcGFzc2UgZW4gbGVjdHVyZVxyXG4gICAgICBldCBxdWUgbGUgcHLDqXNlbnQgbGVjdGV1ciBhdmFpdCBhdXBhcmF2YW50IMOpdMOpIGxhbmPDqS5cclxuICAgICAgRWxsZSBhc3N1cmUgbGUgcmVzZXQgY29tcGxldCBkZSBsYSBzb3VyY2UgZXQgbGUgcGFzc2FnZSBkZSBwcmVsb2FkIGVuIG5vbmVcclxuICAgICAgZGUgbWFuacOocmUgw6Agw6l2aXRlciB0b3V0IHByb2Jsw6htZSBhdmVjIGxlcyBkaXNwb3NpdGlmcyBxdWkgbGltaXRlbnQgbGUgbm9tYnJlXHJcbiAgICAgIGRlIHByw6ljaGFyZ2VtZW50cyBkZSB2aWRlb3Mgc3VyIHVuZSBtw6ptZSBwYWdlIChBbmRyb8OvZCBlbnRyZSBhdXRyZXMpLlxyXG4gICAgICBQb3VyIHNpbXVsZXIgdW5lIHBhdXNlLCBvbiBlbnJlZ2lzdHJlIGwnaW1hZ2UgY291cmFudGUgZGUgbGEgdmlkw6lvXHJcbiAgICAgIGV0IG9uIGwnYWZmaWNoZSBkYW5zIHVuIGNhbnZhcyDDoCBsYSBwbGFjZSBkdSBwb3N0ZXIuXHJcbiAgICAgICovXHJcbiAgICAgIC8vRGltZW5zaW9ubmVtZW50IGR1IGNhbnZhc1xyXG4gICAgICBsYXllclBvc3RlckNhbnZhcy53aWR0aCA9IG1lZGlhLnZpZGVvV2lkdGhcclxuICAgICAgbGF5ZXJQb3N0ZXJDYW52YXMuaGVpZ2h0ID0gbWVkaWEudmlkZW9IZWlnaHRcclxuICAgICAgLy9Db3BpZSBkZSBsJ2ltYWdlIGRhbnMgbGUgY2FudmFzXHJcbiAgICAgIGxheWVyUG9zdGVyQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKG1lZGlhLCAwLCAwLCBsYXllclBvc3RlckNhbnZhcy53aWR0aCwgbGF5ZXJQb3N0ZXJDYW52YXMuaGVpZ2h0KVxyXG4gICAgICAvL09uIGFmZmljaGUgbGUgbGF5ZXItcG9zdGVyLiBMZSBwb3N0ZXIgcXVpIGNvbnN0aXR1ZSBsZSBiYWNrZ3JvdW5kIGVzdCBjYWNow6kgcGFyIGxlIGNhbnZhcy5cclxuICAgICAgbGF5ZXJQb3N0ZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9faGlkZGVuJylcclxuICAgICAgLy9PbiByZXNldCBsZSBsZWN0ZXVyXHJcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhbXN0X19sb2FkZWRtZXRhZGF0YScpXHJcbiAgICAgIG1lZGlhLnNyYyA9ICcnXHJcbiAgICAgIG1lZGlhLnByZWxvYWQgPSAnbm9uZSdcclxuICAgICAgbWVkaWEuc3JjID0gc2VsZi5wYXJhbXMuc3JjXHJcbiAgICB9XHJcbiAgICAvL09uIMOpY291dGUgbCfDqXbDqG5lbWVudCAnYW1zdEV2ZW50X18nIGfDqW7DqXLDqSBwYXIgbGEgbcOpdGhvZGUgcmVzZXQoKVxyXG4gICAgY29udGFpbmVyLm9uKCdhbXN0RXZlbnRfXycsIF9yZXNldCwgZmFsc2UpXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgIEZJTiBSRVNFVCAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgIEhJREVDT05UUk9MUyAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLypGb25jdGlvbiBkw6ljbGVuY2jDqWUgcGFyIGxlIGN1c3RvbSBldmVudCAnYW1zdEV2ZW50X19oaWRlQ29udHJvbHMnIGfDqW7DqXLDqSBwYXIgbGEgbcOpdGhvZGUgcHVibGlxdWUgaGlkZUNvbnRyb2xzKClcclxuICAgIEBwYXJhbSB7ZX0gQ3VzdG9tIEV2ZW50XHJcbiAgICBldmVudC5kZXRhaWwgOiBcclxuICAgICAgLSBkZWxheWVkIChib29sZWFuKSAtIGRlZmF1bHQgZmFsc2VcclxuICAgICAgLSBmb3JjZWQgKGJvb2xlYW4pIC0gZGVmYXVsdCBmYWxzZVxyXG4gICAgUGFzc8OpIMOgIHRydWUsIGRlbGF5ZWQgcHJvZ3JhbW1lIGxhIGRpc3Bhcml0aW9uIGRlIGxhIGJhcnJlIGRlIGNvbnRyb2xlIFxyXG4gICAgYXByw6hzIHVuIHRlbXBzIGTDqWZpbmkgcGFyIGwnb3B0aW9uIGhpZGVDb250cm9sc0RlbGF5LlxyXG4gICAgUGFzc8OpIMOgIHRydWUsIGZvcmNlZCBmb3JjZSBsYSBkaXNwYXJpdGlvbiBkZSBsYSBiYXJyZSBkZSBjb250cm9sZSBcclxuICAgIGFsb3JzIG3Dqm1lIHF1ZSBsYSB2aWTDqW8gZXN0IGVuIHBhdXNlLlxyXG4gICAgSWwgZXN0IHVuaXF1ZW1lbnQgZW1wbG95w6kgc3VyIGxlcyDDqWNyYW5zIHRhY3RpbGVzIGxvcnMgZHUgc3dpcGUgaG9yaXpvbnRhbCBcclxuICAgIHF1aSBmYWl0IGZvbmN0aW9uIGRlIHJlY2hlcmNoZS5cclxuICAgIExhIGRpc3Bhcml0aW9uIGF2ZWMgZMOpbGFpIHNlIHLDqWFsaXNlIHZpYSB1biBiw6p0ZSBzZXRUaW1lb3V0IHF1aSByZWxhbmNlIGxhIGZvbmN0aW9uXHJcbiAgICBlbGxlIG3Dqm1lLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oaWRlQ29udHJvbHMoZSl7XHJcbiAgICAgIGxldCBkZWxheWVkID0gZT9lLmRldGFpbC5kZWxheWVkOmZhbHNlLFxyXG4gICAgICAgICAgZm9yY2VkID0gZT9lLmRldGFpbC5mb3JjZWQ6ZmFsc2VcclxuICAgICAgaWYgKG1lZGlhLnBhdXNlZCAmJiAhZm9yY2VkKSB7XHJcbiAgICAgICAgLy9MYSBiYXJyZSBkZSBjb250csO0bGUgcmVzdGUgc3lzdMOpbWF0aXF1ZW1lbnQgdmlzaWJsZVxyXG4gICAgICAgIC8vw6AgbW9pbnMgZCfDqnRyZSBzdXIgdGFjdGlsZSBldCBxdWUgbCd1dGlsaXNhdGV1ciBvcMOocmUgdW4gc3dpcGUgaG9yaXpvbnRhbFxyXG4gICAgICAgIC8vcG91ciBzZSBkw6lwbGFjZXIgZGFucyBsZSB0ZW1wcy5cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfSBlbHNlIGlmIChkZWxheWVkIHx8IGlzQnVmZmVyaW5nIHx8IHBvaW50ZXJPdmVyQ29udHJvbHMpIHtcclxuICAgICAgICAvL1NpIGxlIHBhcmFtw6h0cmUgZGVsYXllZCB2YXV0IHRydWUgb3UgcXUndW4gYnVmZmVyaW5nIGVzdCBlbiBjb3Vyc1xyXG4gICAgICAgIC8vb3UgcXVlIGxlIHBvaW50ZXVyIGVzdCBwb3NpdGlvbm7DqSBzdXIgbGEgYmFycmUgZGUgY29udHLDtGxlIDpcclxuICAgICAgICAvL29uIGFubnVsZSBsJ8OpdmVudHVlbCB0aW1lb3V0IGVuIGNvdXJzIGV0IG9uIGVuIGxhbmNlIHVuIG5vdXZlYXVcclxuICAgICAgICBpZiAoaGlkZUNvbnRyb2xzVGltZU91dCkgY2xlYXJUaW1lb3V0KGhpZGVDb250cm9sc1RpbWVPdXQpXHJcbiAgICAgICAgaGlkZUNvbnRyb2xzVGltZU91dCA9IHNldFRpbWVvdXQoKCk9Pl9oaWRlQ29udHJvbHMoKSwgc2VsZi5wYXJhbXMuaGlkZUNvbnRyb2xzRGVsYXkpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9TaW5vbiwgb24gY2FjaGUuLi5cclxuICAgICAgICBjb250YWluZXIuZm9jdXMoKVxyXG4gICAgICAgIGNvbnRyb2xzLnN0eWxlW3RyYW5zZm9ybVByZWZpeF0gPSAndHJhbnNsYXRlWCgtNTAlKSBzY2FsZVkoMCknXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vT24gw6ljb3V0ZSBsZSBjdXN0b20gZXZlbnQgJ2Ftc3RFdmVudF9faGlkZUNvbnRyb2xzJyBnw6luw6lyw6kgcGFyIGxhIG3DqXRob2RlIGhpZGVDb250cm9scygpXHJcbiAgICBjb250YWluZXIub24oJ2Ftc3RFdmVudF9faGlkZUNvbnRyb2xzJywgX2hpZGVDb250cm9scywgZmFsc2UpXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgRklOIEhJREVDT05UUk9MUyAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgIFNIT1dDT05UUk9MUyAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dDb250cm9scygpe1xyXG4gICAgICAvL09uIGFubnVsZSBsJ8OpdmVudHVlbGxlIHByb2dyYW1tYXRpb24gZW4gY291cnNcclxuICAgICAgaWYgKGhpZGVDb250cm9sc1RpbWVPdXQpIGNsZWFyVGltZW91dChoaWRlQ29udHJvbHNUaW1lT3V0KVxyXG4gICAgICBjb250cm9scy5zdHlsZVt0cmFuc2Zvcm1QcmVmaXhdID0gJydcclxuICAgICAgLy9TaSBsYSB2aWTDqW8gZXN0IGVuIGxlY3R1cmUsIG9uIHByb2dyYW1tZSBsYSBkaXNwYXJpdGlvbiBkZSBsYSBiYXJyZVxyXG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCkgX2hpZGVDb250cm9scyh7ZGV0YWlsOntkZWxheWVkOnRydWV9fSlcclxuICAgIH1cclxuICAgIC8vT24gw6ljb3V0ZSBsJ8OpdsOobmVtZW50ICdhbXN0RXZlbnRfX3Nob3dDb250cm9scycgZ8OpbsOpcsOpIHBhciBsYSBtw6l0aG9kZSBzaG93Q29udHJvbHMoKVxyXG4gICAgY29udGFpbmVyLm9uKCdhbXN0RXZlbnRfX3Nob3dDb250cm9scycsIF9zaG93Q29udHJvbHMsIGZhbHNlKVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgIEZJTiBTSE9XQ09OVFJPTFMgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICBVUERBVEVCVVRUT05TICAgICAgICAgICAgICAgICAqXHJcbiAqICAgIE1BSiBQUkVWSU9VUy9ORVhUL0RPV05MT0FEL0ZVTExTQ1JFRU4gICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLypcclxuICAgIENoYWN1biBkZXMgYm91dG9ucyBuZXh0LCBwcmV2aW91cywgZG93bmxvYWQsIHZvbHVtZSBldCBmdWxsc2NyZWVuIHBldXQgw6p0cmUgZMOpc2FjdGl2w6kgb3UgY2FjaMOpLlxyXG4gICAgUGFyIGFpbGxldXJzLCBsZXMgYm91dG9ucyBuZXh0LCBwcmV2aW91cyBldCBkb3dubG9hZCBkaXNwb3NlbnQgZCd1biBsYWJlbCBjb25maWd1cmFibGUuXHJcbiAgICBMZXMgYm91dG9ucyBmdWxsc2NyZWVuIGV0IHZvbHVtZUJ1dHRvbiBkaXNwb3NlbnQgZXV4IGRlIGRldXggbGFiZWxzIGNvbmZpZ3VyYWJsZXNcclxuICAgIHBvdXIgYWNjb21wYWduZXIgbGV1ciBjaGFuZ2VtZW50IGQnw6l0YXQgw6l2ZW50dWVsIChtdXRlIGV0IHVubXV0ZSBwb3VyIHZvbHVtZUJ1dHRvbiwgaW4gZXQgb3V0IHBvdXIgZnVsbHNjcmVlbikuXHJcbiAgICBMZXMgZm9uY3Rpb25zIHB1YmxpcXVlcyBwcmV2aW91cygpLCBuZXh0KCksIGRvd25sb2FkKCksIGZ1bGxzY3JlZW4oKSBldCB2b2x1bWVCdXR0b24oKSBnw6luw6hyZW50XHJcbiAgICBjaGFjdW5lcyB1biDDqXbDqW5lbWVudCBkw6lkacOpIHF1aSBkw6ljbGVuY2hlbnQgcmVzcGVjdGl2ZW1lbnQgbGVzIGZvbmN0aW9ucyBcclxuICAgIF9wcmV2aW91cygpLCBfbmV4dCgpLCBfZG93bmxvYWQoKSwgX2Z1bGxzY3JlZW4oKSBldCBfdm9sdW1lQnV0dG9uKCksXHJcbiAgICBsZXNxdWVsbGVzIGFzc3VyZW50IGxhIG1pc2Ugw6Agam91ciBkdSBib3V0b24gY2libMOpLlxyXG4gICAgT24gcHLDqXZvaXQgZGV1eCB2YXJpYWJsZXMgcG91ciBsZXMgdGl0cmVzIGFzc29jacOpcyBhdSBib3V0b24gZnVsbHNjcmVlblxyXG4gICAgYWZpbiBkZSBwb3V2b2lyIGxlIG1ldHRyZSDDoCBqb3VyIGxvcnMgZGVzIGVudHLDqWVzL3NvcnRpZXMgZHUgbW9kZSBwbGVpbiDDqWNyYW5cclxuICAgICovXHJcbiAgICBsZXQgZW50ZXJGdWxsU2NyZWVuTGFiZWwsIGV4aXRGdWxsU2NyZWVuTGFiZWxcclxuICAgIC8vT24gZMOpY2xhcmUgdW5lIGZvbmN0aW9uIGdldE1vdmllIHBvdXIgcsOpYWdpciBhdSBjbGljayDDqXZlbnR1ZWwgc3VyIGxlIGJvdXRvbiBkb3dubG9hZC5cclxuICAgIC8vTCfDqWNvdXRldXIgbidlc3QgcGxhY8OpIHF1ZSBzaSBsZSBib3V0b24gcG9ydGUgZW4gb3B0aW9uIGxlcyBwYXJhbcOodHJlcyBkaXNhYmxlZDpmYWxzZSBldCBoaWRkZW46ZmFsc2UuXHJcbiAgICAvL0RhbnMgbGVzIGF1dHJlcyBjYXMsIGlsIGVzdCByZXRpcsOpLlxyXG4gICAgZnVuY3Rpb24gZ2V0TW92aWUoKXtcclxuICAgICAgd2luZG93LmxvY2F0aW9uID0gc2VsZi5zcmMuc3Vic3RyaW5nKDAsIHNlbGYuc3JjLmxhc3RJbmRleE9mKCcvJykpICsgJy9pbmRleC5waHA/ZmlsZT0nICsgc2VsZi5zcmMuc3Vic3RyaW5nKHNlbGYuc3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKVxyXG4gICAgfVxyXG4gICAgLypcclxuICAgIE1pc2Ugw6Agam91ciBkZXMgY2xhc3MgZXQgYXR0cmlidXRzIGR1IGJvdXRvblxyXG4gICAgbmFtZSA6IG5vbSBkdSBib3V0b25cclxuICAgIGxhYmVsIDogbGFiZWwgZHUgYm91dG9uXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlQnV0dG9uc0F0dHJpYnV0ZXMobmFtZSwgbGFiZWwpe1xyXG4gICAgICBjb25zdCBsb3dlckNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLC8vcG91ciB2b2x1bWVCdXR0b25cclxuICAgICAgICAgICAgYnV0dG9uQ29udGFpbmVyID0gJChgLmFtc3RfXyR7bG93ZXJDYXNlTmFtZX1gKSwgXHJcbiAgICAgICAgICAgIGJ1dHRvbiA9ICQoYC5hbXN0X18ke2xvd2VyQ2FzZU5hbWV9ID4gYnV0dG9uYClcclxuICAgICAgLy9NaXNlIMOgIGpvdXIgZGUgbCdhdHRyaWJ1dCBIVE1MIGRpc2FibGVkIGVuIGZvbmN0aW9uIGRlIGwnb3B0aW9uIGRpc2FibGVkLlxyXG4gICAgICBpZiAoc2VsZi5wYXJhbXNbbmFtZV0uZGlzYWJsZWQgPT09IHRydWUpIHtcclxuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsJycpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKVxyXG4gICAgICB9XHJcbiAgICAgIC8vTWlzZSDDoCBqb3VyIGRlIGxhIGNsYXNzIGVuIGZvbmN0aW9uIGRlIGwnb3B0aW9uIGhpZGRlbi5cclxuICAgICAgaWYgKHNlbGYucGFyYW1zW25hbWVdLmhpZGRlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGJ1dHRvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X19oaWRkZW4nKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJ1dHRvbkNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhbXN0X19oaWRkZW4nKVxyXG4gICAgICB9XHJcbiAgICAgIC8vT24gY2FjaGUgbGUgcG90ZW50aW9tw6l0cmUgc2kgbGUgYm91dG9uIGRlIHZvbHVtZSBlc3QgZGlzYWJsZWQgb3UgaGlkZGVuLlxyXG4gICAgICBpZiAobmFtZSA9PSAndm9sdW1lQnV0dG9uJyAmJiB2b2x1bWVTbGlkZXIpIHtcclxuICAgICAgICBpZiAoc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmRpc2FibGVkID09PSB0cnVlIHx8IHNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5oaWRkZW4gPT09IHRydWUpIHtcclxuICAgICAgICAgIHZvbHVtZVNsaWRlci5jbGFzc0xpc3QuYWRkKCdhbXN0X19oaWRkZW4nKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2b2x1bWVTbGlkZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9faGlkZGVuJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vTWlzIMOgIGpvdXIgZHUgbGFiZWxcclxuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZXMoe1xyXG4gICAgICAgIHRpdGxlOiBsYWJlbCxcclxuICAgICAgICAnYXJpYS1sYWJlbCc6IGxhYmVsXHJcbiAgICAgIH0pXHJcbiAgICAgIGdldENvbnRyb2xzRWxlbWVudHNXaWR0aCgpXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVBbGxCdXR0b25zKCl7Ly9Gb25jdGlvbiBhcHBlbMOpZSBsb3JzIGRlIGxhIG1pc2Ugw6Agam91ciBkZSBsYSBzb3VyY2VcclxuICAgICAgX3ByZXZpb3VzKClcclxuICAgICAgX25leHQoKVxyXG4gICAgICBfZG93bmxvYWQoKVxyXG4gICAgICBfdm9sdW1lQnV0dG9uKClcclxuICAgICAgaWYgKGZ1bGxzY3JlZW5BUEkpIF9mdWxsc2NyZWVuKClcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9wcmV2aW91cygpe1xyXG4gICAgICB1cGRhdGVCdXR0b25zQXR0cmlidXRlcygncHJldmlvdXMnLCBzZWxmLnBhcmFtcy5wcmV2aW91cy5sYWJlbClcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9uZXh0KCl7XHJcbiAgICAgIHVwZGF0ZUJ1dHRvbnNBdHRyaWJ1dGVzKCduZXh0Jywgc2VsZi5wYXJhbXMubmV4dC5sYWJlbClcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9kb3dubG9hZCgpIHtcclxuICAgICAgaWYgKHNlbGYucGFyYW1zLmRvd25sb2FkLmRpc2FibGVkID09PSBmYWxzZSAmJiBzZWxmLnBhcmFtcy5kb3dubG9hZC5oaWRkZW4gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgLy9PbiBwb3NlIGwnw6ljb3V0ZXVyXHJcbiAgICAgICAgJCgnLmFtc3RfX2Rvd25sb2FkPmJ1dHRvbicpLm9uKCdjbGljaycsIGdldE1vdmllLCBmYWxzZSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL09uIHJldGlyZSBsJ8OpY291dGV1clxyXG4gICAgICAgICQoJy5hbXN0X19kb3dubG9hZD5idXR0b24nKS5vZmYoJ2NsaWNrJywgZ2V0TW92aWUpXHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlQnV0dG9uc0F0dHJpYnV0ZXMoJ2Rvd25sb2FkJywgc2VsZi5wYXJhbXMuZG93bmxvYWQubGFiZWwpXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfZnVsbHNjcmVlbigpe1xyXG4gICAgICBlbnRlckZ1bGxTY3JlZW5MYWJlbCA9IHNlbGYucGFyYW1zLmZ1bGxzY3JlZW4ubGFiZWwuZW50ZXJcclxuICAgICAgZXhpdEZ1bGxTY3JlZW5MYWJlbCA9IHNlbGYucGFyYW1zLmZ1bGxzY3JlZW4ubGFiZWwuZXhpdFxyXG4gICAgICB1cGRhdGVCdXR0b25zQXR0cmlidXRlcygnZnVsbHNjcmVlbicsIChBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmN1cnJlbnRGdWxsU2NyZWVuUGxheWVyPT1zZWxmKT9leGl0RnVsbFNjcmVlbkxhYmVsOmVudGVyRnVsbFNjcmVlbkxhYmVsKVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX3ZvbHVtZUJ1dHRvbigpe1xyXG4gICAgICB1cGRhdGVCdXR0b25zQXR0cmlidXRlcygndm9sdW1lQnV0dG9uJywgKHNlbGYudm9sdW1lPT0wKT9zZWxmLnBhcmFtcy52b2x1bWVCdXR0b24ubGFiZWwudW5tdXRlOnNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5sYWJlbC5tdXRlKVxyXG4gICAgfVxyXG4gICAgLy9PbiDDqWNvdXRlIGxlcyDDqXbDqW5lbWVudHMgZ8OpbsOpcsOpcyBwYXIgbGVzIHNldHRlcnMgcHJldmlvdXMsIG5leHQsIGRvd25sb2FkIGV0IGZ1bGxzY3JlZW5cclxuICAgIGNvbnRhaW5lci5vbignYW1zdEV2ZW50X19wcmV2aW91c0J1dHRvbicsIF9wcmV2aW91cywgZmFsc2UpXHJcbiAgICBjb250YWluZXIub24oJ2Ftc3RFdmVudF9fbmV4dEJ1dHRvbicsIF9uZXh0LCBmYWxzZSlcclxuICAgIGNvbnRhaW5lci5vbignYW1zdEV2ZW50X19mdWxsc2NyZWVuQnV0dG9uJywgX2Z1bGxzY3JlZW4sIGZhbHNlKVxyXG4gICAgY29udGFpbmVyLm9uKCdhbXN0RXZlbnRfX2Rvd25sb2FkQnV0dG9uJywgX2Rvd25sb2FkLCBmYWxzZSlcclxuICAgIGNvbnRhaW5lci5vbignYW1zdEV2ZW50X192b2x1bWVCdXR0b24nLCBfdm9sdW1lQnV0dG9uLCBmYWxzZSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgIEZJTiBVUERBVEVCVVRUT05TICAgICAgICAgICAgICAgICpcclxuICogICAgTUFKIFBSRVZJT1VTL05FWFQvRE9XTkxPQUQvRlVMTFNDUkVFTiAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgU09VUkNFICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGZ1bmN0aW9uIF9zcmMoZSkge1xyXG4gICAgICBsZXQgbXlTcmMgPSBlLmRldGFpbFxyXG4gICAgICAvL0xlIGNhcyDDqWNow6lhbnQsIG9uIHRyYW5zZm9ybWUgIGxlIHBhcmFtw6h0cmUgcGFzc8OpIGF1IHNldHRlciBlbiBvYmpldFxyXG4gICAgICBteVNyYyA9ICh0eXBlb2YgbXlTcmMgPT09ICdvYmplY3QnKT9teVNyYzp7c3JjOm15U3JjfVxyXG4gICAgICBpZiAobXlTcmMudm9sdW1lR3JvdXAgPCAxKSBteVNyYy52b2x1bWVHcm91cCA9IHNlbGYucGFyYW1zLnZvbHVtZUdyb3VwXHJcbiAgICAgIGlmICghaXNOYU4obXlTcmMudm9sdW1lKSAmJiAobXlTcmMudm9sdW1lRm9yY2VkID09PSB0cnVlIHx8ICFzdG9yYWdlLmdldEl0ZW0oYGFtc3Rfdm9sdW1lZ3JvdXAke215U3JjLnZvbHVtZUdyb3VwfWApKSkge1xyXG4gICAgICAgIC8vU2kgdW4gdm9sdW1lIGEgw6l0w6kgc3DDqWNpZmnDqSBldCBxdWUgXHJcbiAgICAgICAgLy9sJ29wdGlvbiB2b2x1bWVGb3JjZWQgZXN0IHByw6lzZW50ZSBvdSBxdWUgbGUgdm9sdW1lR3JvdXAgbmUgZmlndXJlIHBhcyBkYW5zIHNlc3Npb25TdG9yYWdlXHJcbiAgICAgICAgc2VsZi5wYXJhbXMudm9sdW1lID0gbXlTcmMudm9sdW1lXHJcbiAgICAgICAgaWYgKG15U3JjLnZvbHVtZUdyb3VwID4gMCkgc3RvcmFnZS5zZXRJdGVtKGBhbXN0X3ZvbHVtZWdyb3VwJHtteVNyYy52b2x1bWVHcm91cH1gLCBteVNyYy52b2x1bWUpXHJcbiAgICAgIH0gZWxzZSBpZiAoc3RvcmFnZS5nZXRJdGVtKGBhbXN0X3ZvbHVtZWdyb3VwJHtteVNyYy52b2x1bWVHcm91cH1gKSkge1xyXG4gICAgICAgIHNlbGYucGFyYW1zLnZvbHVtZSA9IHN0b3JhZ2UuZ2V0SXRlbShgYW1zdF92b2x1bWVncm91cCR7bXlTcmMudm9sdW1lR3JvdXB9YClcclxuICAgICAgfVxyXG4gICAgICAvL09uIG5lIGNvbnNlcnZlIGRhbnMgbXlTcmMgcXVlIGxlcyBwcm9wcmnDqXTDqXMgcmVsZXZhbnRlcy4gXHJcbiAgICAgIGNvbnN0IHNyY1ZhbGlkUGFyYW1ldGVycyA9IFsnYXV0b3BsYXknLCAnY3Jvc3NvcmlnaW4nLCAnZG93bmxvYWQnLCAnZHVyYXRpb24nLCAnZm9ybWF0JywgJ2Z1bGxzY3JlZW4nLCAnbG9vcCcsICduZXh0JywgJ3BsYXlzaW5saW5lJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3ByZXZpb3VzJywgJ3NyYycsICdza2lwVGltZScsICd0aHVtYm5haWxzJywgJ3ZvbHVtZUJ1dHRvbicsICd2b2x1bWVHcm91cCddXHJcbiAgICAgIG15U3JjID0gc3JjVmFsaWRQYXJhbWV0ZXJzLnJlZHVjZSgob2JqLCBuYW1lKT0+e1xyXG4gICAgICAgIGlmIChzcmNWYWxpZFBhcmFtZXRlcnMuaW5jbHVkZXMobmFtZSkgJiYgbXlTcmNbbmFtZV0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBvYmpbbmFtZV0gPSBteVNyY1tuYW1lXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICB9LCB7fSlcclxuICAgICAgLy9TJ2lsIHMnYWdpdCBkJ3VuIGNoYW5nZW1lbnQgZGUgc291cmNlXHJcbiAgICAgIGlmIChtZWRpYS5nZXRBdHRyaWJ1dGUoJ3NyYycpKSB7XHJcbiAgICAgICAgLy9PbiByZXNldCBsZSBwbGF5ZXJcclxuICAgICAgICBzZWxmLnBhdXNlKClcclxuICAgICAgICBwcmV2Q3VycmVudFRpbWUgPSAwXHJcbiAgICAgICAgZmxvb3JDdXJyZW50VGltZSA9IDBcclxuICAgICAgICBidWZmZXJlZCA9IHVuZGVmaW5lZFxyXG4gICAgICAgIC8vT24gc3VwcHJpbWUgbCdlbnNlbWJsZSBkZXMgYXR0cmlidXRzIEhUTUwgcHLDqXNlbnRzIGRhbnMgbGUgdGFnIDx2aWRlbz5cclxuICAgICAgICB3aGlsZSAobWVkaWEuYXR0cmlidXRlcy5sZW5ndGggPiAwKSBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUobWVkaWEuYXR0cmlidXRlc1swXS5uYW1lKVxyXG4gICAgICAgIC8vUmVzZXQgZGVzIHBhcmFtw6h0cmVzIGF1dG9wbGF5LCBjcm9zc29yaWdpbiwgbG9vcCwgcGxheXNpbmxpbmUsIHRodW1uYWlsc1xyXG4gICAgICAgIGNvbnN0IGFyciA9IFsnYXV0b3BsYXknLCAnY3Jvc3NvcmlnaW4nLCAnbG9vcCcsICdwbGF5c2lubGluZScsICd0aHVtYm5haWxzJ11cclxuICAgICAgICBhcnIuZm9yRWFjaChwPT5zZWxmLnBhcmFtc1twXSA9IEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuZGVmYXVsdE9wdGlvbnNbcF0pXHJcbiAgICAgICAgLy9SZXNldCBkZXMgY2xhc3Mgc3VyIGxlIGNvbnRhaW5lclxyXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhbXN0X190aHVtYm5haWxzJywnYW1zdF9fbG9hZGVkbWV0YWRhdGEnKVxyXG4gICAgICAgIC8vUmVzZXQgZGVzIHZpZ25ldHRlc1xyXG4gICAgICAgIHRodW1iV2lkdGggPSAwXHJcbiAgICAgICAgc2Vla2luZ1dpZHRoID0gdW5kZWZpbmVkXHJcbiAgICAgICAgc2Vla2luZy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcclxuICAgICAgICBzZWVraW5nVG91Y2hXaWR0aCA9IHVuZGVmaW5lZFxyXG4gICAgICAgIHNlZWtpbmdUb3VjaC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcclxuICAgICAgICAvL01pc2Ugw6Agam91ciBkZXMgcGFyYW3DqHRyZXMgZGUgbCdpbnN0YW5jZS5cclxuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobXlTcmMpKSB7XHJcbiAgICAgICAgICBzZWxmLnBhcmFtc1trZXldID0gdmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy9MZSBjYXMgw6ljaMOpYW50LCBvbiBjaGFyZ2UgbCdpbWFnZSBjb250ZW5hbnQgbGVzIHZpZ25ldHRlc1xyXG4gICAgICBpZiAoc2VsZi5wYXJhbXMudGh1bWJuYWlscy5zcmMpIHtcclxuICAgICAgICBsZXQgdGh1bWIgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgIGNvbnN0IHRodW1iRXZlbnQgPSBmdW5jdGlvbihlKXtcclxuICAgICAgICAgIHRodW1iLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aHVtYkV2ZW50KVxyXG4gICAgICAgICAgdGh1bWIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aHVtYkV2ZW50KVxyXG4gICAgICAgICAgaWYgKGUudHlwZSA9PSAnbG9hZCcpIHtcclxuICAgICAgICAgICAgLy9TaSBsYSBzb3VyY2UgZGUgbCdpbWFnZSBlc3QgdmFsaWRlXHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X190aHVtYm5haWxzJylcclxuICAgICAgICAgICAgLy9PbiBkw6l0ZXJtaW5lIGxhIGxhcmdldXIgZGVzIHZpZ25ldHRlc1xyXG4gICAgICAgICAgICB0aHVtYldpZHRoID0gdGh1bWIubmF0dXJhbFdpZHRoL3NlbGYucGFyYW1zLnRodW1ibmFpbHMubnVtYmVyXHJcbiAgICAgICAgICAgIC8vT24gYXBwbGlxdWUgbGUgc3R5bGUgcsOpc3VsdGFudCBhdXggw6lsw6ltZW50cyBzZWVraW5nIGV0IGV0IHNlZWtpbmdUb3VjaFxyXG4gICAgICAgICAgICBsZXQgY3NzID0ge3dpZHRoOiBgJHt0aHVtYi5uYXR1cmFsV2lkdGgvc2VsZi5wYXJhbXMudGh1bWJuYWlscy5udW1iZXJ9cHhgLCBoZWlnaHQ6IGAke3RodW1iLm5hdHVyYWxIZWlnaHR9cHhgLCAnYmFja2dyb3VuZC1pbWFnZSc6YHVybChcIiR7c2VsZi5wYXJhbXMudGh1bWJuYWlscy5zcmN9XCIpYH1cclxuICAgICAgICAgICAgc2Vla2luZy5jc3MoY3NzKVxyXG4gICAgICAgICAgICBzZWVraW5nVG91Y2guY3NzKGNzcylcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYucGFyYW1zLnRodW1ibmFpbHMuc3JjID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGh1bWJFdmVudCwgZmFsc2UpXHJcbiAgICAgICAgdGh1bWIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRodW1iRXZlbnQsIGZhbHNlKVxyXG4gICAgICAgIHRodW1iLnNyYyA9IHNlbGYucGFyYW1zLnRodW1ibmFpbHMuc3JjXHJcbiAgICAgIH1cclxuICAgICAgLy9Jbml0aWFsaXNhdGlvbi9NaXNlIMOgIGpvdXIgZGVzIGF0dHJpYnV0cyBkdSB0YWcgdmlkZW9cclxuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgc3JjOiBzZWxmLnBhcmFtcy5zcmMsXHJcbiAgICAgICAgcHJlbG9hZDogKElTX01PQklMRSk/J25vbmUnOnNlbGYucGFyYW1zLnByZWxvYWRcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VsZi5wYXJhbXMucGxheXNpbmxpbmUgPT09IHRydWUpIHtcclxuICAgICAgICBhdHRyaWJ1dGVzLnBsYXlzaW5saW5lID0gJycsXHJcbiAgICAgICAgYXR0cmlidXRlc1snd2Via2l0LXBsYXlzaW5saW5lJ10gPSAnJ1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5sb29wID09PSB0cnVlKSB7XHJcbiAgICAgICAgYXR0cmlidXRlcy5sb29wID0gJydcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2VsZi5wYXJhbXMuY3Jvc3NvcmlnaW4pIHtcclxuICAgICAgICBhdHRyaWJ1dGVzLmNyb3Nzb3JpZ2luID0gc2VsZi5wYXJhbXMuY3Jvc3NvcmlnaW5cclxuICAgICAgfVxyXG4gICAgICBtZWRpYS5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpXHJcbiAgICAgIC8vSW5pdGlhbGlzYXRpb24vTWlzZSDDoCBqb3VyIGR1IHZvbHVtZVxyXG4gICAgICBzZWxmLnZvbHVtZSA9IChJU19NT0JJTEUgJiYgc2VsZi5wYXJhbXMudm9sdW1lID4gMCk/MTpzZWxmLnBhcmFtcy52b2x1bWVcclxuICAgICAgaWYgKCF2b2x1bWVCZWZvcmVNdXRlKSB7XHJcbiAgICAgICAgdm9sdW1lQmVmb3JlTXV0ZSA9IChtZWRpYS52b2x1bWUgPT0gMCk/MC4xOm1lZGlhLnZvbHVtZVxyXG4gICAgICAgIGlmIChJU19NT0JJTEUpIHZvbHVtZUJlZm9yZU11dGUgPSAxXHJcbiAgICAgIH1cclxuICAgICAgLy9Jbml0aWFsaXNhdGlvbi9NaXNlIMOgIGpvdXIgZHUgZm9ybWF0XHJcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nQm90dG9tID0gMSAvIHNlbGYucGFyYW1zLmZvcm1hdCAqIDEwMCArICclJ1xyXG4gICAgICAvL0luaXRpYWxpc2F0aW9uL01pc2Ugw6Agam91ciBkdSBwb3N0ZXJcclxuICAgICAgaWYgKHNlbGYucGFyYW1zLnBvc3Rlcikge1xyXG4gICAgICAgIGxheWVyUG9zdGVyLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke3NlbGYucGFyYW1zLnBvc3Rlcn1cIilgXHJcbiAgICAgICAgbGF5ZXJQb3N0ZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9faGlkZGVuJylcclxuICAgICAgfVxyXG4gICAgICAvL0luaXRpYWxpc2F0aW9uL01pc2Ugw6Agam91ciBkZXMgaW5mb3JtYXRpb25zIHRlbXBvcmVsbGVzXHJcbiAgICAgICQoJy5hbXN0X19kdXJhdGlvbicpLmlubmVySFRNTCA9IHNlY29uZHNUb1RpbWVDb2RlKHNlbGYucGFyYW1zLmR1cmF0aW9uKVxyXG4gICAgICAkKCcuYW1zdF9fY3VycmVudHRpbWUnKS5pbm5lckhUTUwgPSBzZWNvbmRzVG9UaW1lQ29kZSgwLCAoc2VsZi5wYXJhbXMuZHVyYXRpb24gPiAzNjAwKSk7XHJcbiAgICAgIC8vTWlzZSDDoCBqb3VyIGRlcyBib3V0b25zXHJcbiAgICAgIHVwZGF0ZUFsbEJ1dHRvbnMoKVxyXG4gICAgICAvL1NpIGF1dG9wbGF5LCBvbiBsYW5jZSBsYSBsZWN0dXJlXHJcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5hdXRvcGxheSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIF9wbGF5KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9PbiDDqWNvdXRlIGxlIGN1c3RvbSBldmVudCAnYW1zdEV2ZW50X19zcmMnIGfDqW7DqXLDqSBwYXIgbGEgbcOpdGhvZGUgc3JjKClcclxuICAgIGNvbnRhaW5lci5vbignYW1zdEV2ZW50X19zcmMnLCBfc3JjLCBmYWxzZSlcclxuICAgIC8vSW5pdGlhbGlzYXRpb24gZGUgbGEgc291cmNlXHJcbiAgICBfc3JjKHtkZXRhaWw6dGhpcy5wYXJhbXN9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICBGSU4gU09VUkNFICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgIMOJVsOITkVNRU5UUyBNRURJQSAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgbWVkaWFcclxuICAgICAgLm9uKCdtb3VzZW1vdmUnLCAoKT0+X3Nob3dDb250cm9scygpLCBwYXNzaXZlP3twYXNzaXZlOnRydWV9OmZhbHNlKVxyXG4gICAgICAub24oJ2xvYWRlZG1ldGFkYXRhJywgKCk9PntcclxuICAgICAgICBsZXQgbXlGb3JtYXQgPSB0aGlzLnBhcmFtcy5mb3JtYXQgPSBtZWRpYS52aWRlb1dpZHRoIC8gbWVkaWEudmlkZW9IZWlnaHRcclxuICAgICAgICAvL0FjdHVhbGlzYXRpb24gZGUgbGEgdGFpbGxlIGR1IGNvbnRhaW5lciBlbiBmb25jdGlvbiBkdSBmb3JtYXQgcsOpZWwgZGUgbGEgdmlkw6lvXHJcbiAgICAgICAgaWYgKEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudEZ1bGxTY3JlZW5QbGF5ZXIgPT0gc2VsZikge1xyXG4gICAgICAgICAgdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb3B0aW1pemVkUmVzaXplJykpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nQm90dG9tID0gMSAvIG15Rm9ybWF0ICogMTAwICsgJyUnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X19sb2FkZWRtZXRhZGF0YScpXHJcbiAgICAgICAgLy9TaSBsZSBsZWN0ZXVyIGEgw6l0w6kgcmVzZXTDqSBkdSBmYWl0IGR1IGxhbmNlbWVudCBkJ3VuIGF1dHJlIGxlY3RldXJcclxuICAgICAgICAvL29uIHJlcGxhY2UgbGEgdMOqdGUgZGUgbGVjdHVyZSBhdSB0ZW1wcyBvw7kgZWxsZSBzJ8OpdGFpdCBhcnLDqXTDqWVcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGZsb29yQ3VycmVudFRpbWVcclxuICAgICAgfSlcclxuICAgICAgLm9uKCdsb2FkZWRkYXRhJywgKCk9PntcclxuICAgICAgICAvL1BvdXIgaU9TIHN1ciByZXNldCBkdSBwbGF5ZXJcclxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGZsb29yQ3VycmVudFRpbWVcclxuICAgICAgfSlcclxuICAgICAgLm9uKCdkdXJhdGlvbmNoYW5nZScsICgpPT57XHJcbiAgICAgICAgdGhpcy5wYXJhbXMuZHVyYXRpb24gPSBtZWRpYS5kdXJhdGlvblxyXG4gICAgICAgIC8vTWlzZSDDoCBqb3VyIGRlIHNraXBUaW1lXHJcbiAgICAgICAgc2tpcFRpbWUgPSAodHlwZW9mKHRoaXMucGFyYW1zLnNraXBUaW1lKT09J3N0cmluZycgJiYgdGhpcy5wYXJhbXMuc2tpcFRpbWUuc2xpY2UoLTEpPT0nJScpP3BhcnNlRmxvYXQodGhpcy5wYXJhbXMuc2tpcFRpbWUpICogbWVkaWEuZHVyYXRpb24gLyAxMDA6cGFyc2VGbG9hdCh0aGlzLnBhcmFtcy5za2lwVGltZSlcclxuICAgICAgICAvL01pc2Ugw6Agam91ciBkZXMgY2hhbXBzIGluZGljYXRldXJzIGRlIHRlbXBzXHJcbiAgICAgICAgaWYgKG1lZGlhLmR1cmF0aW9uID49IDM2MDApIHsvL1NpIGxhIGR1csOpZSBkdSBtZWRpYSBlc3Qgc3Vww6lyaWV1cmUgw6AgMSBoZXVyZVxyXG4gICAgICAgICAgLy9MYSBjbGFzc2UgYW1zdF9fbG9uZyBhdWdtZW50ZSBsYSBsYXJnZXVyIGRlcyBjb250YWluZXJzIGluZGljYXRldXJzIGRlIHRlbXBzXHJcbiAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYW1zdF9fbG9uZycpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhbXN0X19sb25nJylcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW1heCcsIG1lZGlhLmR1cmF0aW9uKVxyXG4gICAgICAgICQoJy5hbXN0X19kdXJhdGlvbicpLmlubmVySFRNTCA9IHNlY29uZHNUb1RpbWVDb2RlKG1lZGlhLmR1cmF0aW9uKVxyXG4gICAgICAgICQoJy5hbXN0X19jdXJyZW50dGltZScpLmlubmVySFRNTCA9IHNlY29uZHNUb1RpbWVDb2RlKGZsb29yQ3VycmVudFRpbWUsIChtZWRpYS5kdXJhdGlvbiA+IDM2MDApKVxyXG4gICAgICAgIC8vT24gcmVwcmVuZCB1bmUgbWVzdXJlIGRlcyBjb250csO0bGVzIGF1IGNhcyBvw7kgbGUgY29udGFpbmVyIGFpdCBnYWduw6kgb3UgcGVyZHUgbGEgY2xhc3MgYW1zdF9fbG9uZyBcclxuICAgICAgICBnZXRDb250cm9sc0VsZW1lbnRzV2lkdGgoKVxyXG4gICAgICB9KVxyXG4gICAgICAub24oJ3Byb2dyZXNzJywgdXBkYXRlQnVmZmVyKS8vTWlzZSDDoCBqb3VyIGR1IGNhbnZhcyBpbmRpY2F0ZXVyIGRlIGJ1ZmZlcmluZ1xyXG4gICAgICAub24oJ3RpbWV1cGRhdGUnLCAoKT0+e1xyXG4gICAgICAgIC8vTCfDqXbDqG5lbWVudCBlc3QgYXVzc2kgZMOpY2xlbmNow6kgbG9yc3F1J29uIHJlc2V0IGxhIHNvdXJjZSBkdSBtZWRpYSxcclxuICAgICAgICAvL2NlIHF1aSBzZSBwcm9kdWl0IGF1IHJlc2V0IGR1IHBsYXllciBlZmZlY3R1w6kgc3VpdGUgYXUgbGFuY2VtZW50IGRlIGxhIGxlY3R1cmUgZCd1biBhdXRyZSBwbGF5ZXIuXHJcbiAgICAgICAgLy9EYW5zIGNlIGNhcywgbGEgcHJvcHJpw6l0w6kgZHVyYXRpb24gZHUgbWVkaWEgbidlc3QgcGFzIGTDqWZpbmllLlxyXG4gICAgICAgIGlmIChpc05hTihtZWRpYS5kdXJhdGlvbikpIHJldHVyblxyXG4gICAgICAgIHVwZGF0ZUJ1ZmZlcigpLy9NaXNlIMOgIGpvdXIgZHUgY2FudmFzIGluZGljYXRldXIgZGUgYnVmZmVyaW5nXHJcbiAgICAgICAgc2xpZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIG1lZGlhLmN1cnJlbnRUaW1lKVxyXG4gICAgICAgIGxldCBtZWRpYUZsb29yQ3VycmVudFRpbWUgPSBNYXRoLmZsb29yKG1lZGlhLmN1cnJlbnRUaW1lKVxyXG4gICAgICAgIGlmIChmbG9vckN1cnJlbnRUaW1lICE9IG1lZGlhRmxvb3JDdXJyZW50VGltZSkge1xyXG4gICAgICAgICAgLy9PbiBuJ2FjdHVhbGlzZSBsZSBjaGFtcHMgaW5kaWNhdGV1ciBkdSB0ZW1wcyBjb3VyYW50IHF1ZSBzaSBuw6ljZXNzYWlyZVxyXG4gICAgICAgICAgLy9jJ2VzdCDDoCBkaXJlIHNpIGwnYXJyb25kaSDDoCBsYSBzZWNvbmRlIGR1IHRlbXBzIGNvdXJhbnQgZGlmZsOocmUgZGUgY2VsdWkgcXUnb24gYSBwcsOpY8OpZGVtbWVudCBwcmlzIHNvaW4gZCdlbnJlZ2lzdHJlclxyXG4gICAgICAgICAgZmxvb3JDdXJyZW50VGltZSA9IG1lZGlhRmxvb3JDdXJyZW50VGltZVxyXG4gICAgICAgICAgbGV0IHRpbWUgPSBzZWNvbmRzVG9UaW1lQ29kZShmbG9vckN1cnJlbnRUaW1lLCAobWVkaWEuZHVyYXRpb24gPiAzNjAwKSlcclxuICAgICAgICAgICQoJy5hbXN0X19jdXJyZW50dGltZScpLmlubmVySFRNTCA9IHRpbWVcclxuICAgICAgICAgIHNsaWRlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgdGltZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZDdXJyZW50VGltZSA9PSAwIHx8IE1hdGguYWJzKG1lZGlhLmN1cnJlbnRUaW1lIC0gcHJldkN1cnJlbnRUaW1lKSA+IDAuNSkge1xyXG4gICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodXBkYXRlVGltZVJhaWxBbmltYXRpb24pXHJcbiAgICAgICAgICB1cGRhdGVUaW1lUmFpbCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lXHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignZW5kZWQnLCAoKT0+e1xyXG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gMFxyXG4gICAgICAgIHRoaXMucGF1c2UoKVxyXG4gICAgICB9KVxyXG4gICAgICAub24oJ3BhdXNlJywgKCk9PmNhbmNlbEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVRpbWVSYWlsQW5pbWF0aW9uKSlcclxuICAgICAgLm9uKCdwbGF5aW5nJywgKCk9PntcclxuICAgICAgICAvL09uIGZvcmNlIGxhIGZvbmN0aW9uIHVwZGF0ZVRpbWVSYWlsIGVuIHBhc3NhbnQgcHJldkN1cnJlbnRUaW1lIMOgIDAuXHJcbiAgICAgICAgcHJldkN1cnJlbnRUaW1lID0gMFxyXG4gICAgICAgIGxheWVyUG9zdGVyLmNsYXNzTGlzdC5hZGQoJ2Ftc3RfX2hpZGRlbicpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignc2Vla2VkJywgKCk9PntcclxuICAgICAgICAvL0wnw6l2w6huZW1lbnQgZXN0IGF1c3NzaSBkw6ljbGVuY2jDqSDDoCBsYSBzdWl0ZSBkZSBsJ8OpdsOobmVtZW50IGVuZGVkLlxyXG4gICAgICAgIC8vRGFucyBjZSBjYXMsIGN1cnJlbnRUaW1lIHZhdXQgMCwgbGEgdmlkw6lvIGVzdCBlbiBwYXVzZSBldCBvbiBhZmZpY2hlIGxlIHBvc3RlclxyXG4gICAgICAgIGlmIChmbG9vckN1cnJlbnRUaW1lID09IDAgJiYgdGhpcy5wYXVzZWQpIHtcclxuICAgICAgICAgIGxheWVyUG9zdGVyQ2FudmFzLndpZHRoID0gMFxyXG4gICAgICAgICAgbGF5ZXJQb3N0ZXJDYW52YXMuaGVpZ2h0ID0gMFxyXG4gICAgICAgICAgbGF5ZXJQb3N0ZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9faGlkZGVuJylcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbigncGxheSBwbGF5aW5nIHNlZWtlZCBjYW5wbGF5JywgKCk9PntcclxuICAgICAgICBpc0J1ZmZlcmluZyA9IGZhbHNlXHJcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2Ftc3RfX2J1ZmZlcmluZycpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignc2Vla2luZyB3YWl0aW5nIGxvYWRlZGRhdGEnLCAoKT0+e1xyXG4gICAgICAgIGlzQnVmZmVyaW5nID0gdHJ1ZVxyXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X19idWZmZXJpbmcnKVxyXG4gICAgICB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgRklOIMOJVsOITkVNRU5UUyBNRURJQSAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICBVUERBVEVCVUZGRVIgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLy9Jbml0aWFsaXNhdGlvbiBkdSBjYW52YXMgaW5kaWNhdGV1ciBkZSBidWZmZXJpbmdcclxuICAgIGNvbnN0IGxvYWRlZEJhciA9ICQoJy5hbXN0X19sb2FkZWQtYmFyJyksXHJcbiAgICAgICAgICBsb2FkZWRCYXJIZWlnaHQgPSBsb2FkZWRCYXIub2Zmc2V0SGVpZ2h0XHJcbiAgICBsZXQgY3R4TG9hZGVkQmFyID0gbG9hZGVkQmFyLmdldENvbnRleHQoJzJkJylcclxuICAgIGxvYWRlZEJhci5oZWlnaHQgPSBsb2FkZWRCYXJIZWlnaHRcclxuICAgIGN0eExvYWRlZEJhci5maWxsU3R5bGUgPSBsb2FkZWRCYXIuY3NzKCdjb2xvcicpXHJcbiAgICAvL01pc2Ugw6Agam91ciBkdSBjYW52YXMgaW5kaWNhdGV1ciBkZSBidWZmZXJpbmcgYXBwZWzDqWUgc3VyIGxlcyDDqXbDqG5lbWVudHMgcHJvZ3Jlc3MgZXQgdGltZXVwZGF0ZVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCl7XHJcbiAgICAgIC8vQ29tcGFyYWlzb24gZGUgZGV1eCBvYmpldHMgVGltZVJhbmdlc1xyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlVGltZVJhbmdlcyh0MSwgdDIpe1xyXG4gICAgICAgIGlmICghdDEgfHwgIXQyIHx8IHQxLmxlbmd0aCAhPSB0Mi5sZW5ndGgpIHtcclxuICAgICAgICAgIC8vU2kgbCd1biBkZXMgb2JqZXRzIG4nZXhpc3RlIHBhcyBvdSBzaSBsZXVycyBsb25ndWV1cnMgZGlmZsOocmVudCwgb24gcmVudm9pZSBmYWxzZVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy9Db21wYXJhaXNvbiBkZSBjaGFjdW4gZGVzIMOpbMOpbWVudHMgY29udGVudXMgZGFucyBsZXMgVGltZVJhbmdlc1xyXG4gICAgICAgICAgICAvL1NpIG9uIHRyb3V2ZSB1bmUgZGlmZsOpcmVuY2UsIG9uIGFycmV0ZSBldCBvbiByZW52b2llIGZhbHNlXHJcbiAgICAgICAgICAgIGlmICh0MS5zdGFydChpKSAhPSB0Mi5zdGFydChpKSB8fCB0MS5lbmQoaSkgIT0gdDIuZW5kKGkpKSB7XHJcbiAgICAgICAgICAgICAgaSA9IHQxLmxlbmd0aFxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgICAgLy9TaSBsZSB0aW1lUmFuZ2VzIHJlbnZvecOpIHBhciBsYSBwcm9wcmnDqXTDqSBidWZmZXJlZCBkdSBtw6lkaWEgZXN0IGRpZmbDqXJlbnQgZGUgY2VsdWkgZMOpasOgIGVucmVnaXN0csOpXHJcbiAgICAgIC8vT24gYWN0dWFsaXNlIGxlIGNhbnZhcyBpbmRpY2F0ZXVyIGRlIGJ1ZmZlcmluZ1xyXG4gICAgICBpZiAoIWNvbXBhcmVUaW1lUmFuZ2VzKG1lZGlhLmJ1ZmZlcmVkLCBidWZmZXJlZCkpIHtcclxuICAgICAgICBjdHhMb2FkZWRCYXIuY2xlYXJSZWN0KDAsIDAsIGxvYWRlZEJhci53aWR0aCwgbG9hZGVkQmFyLmhlaWdodClcclxuICAgICAgICBsZXQgaW5jID0gbG9hZGVkQmFyLndpZHRoIC8gbWVkaWEuZHVyYXRpb25cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgc3RhcnQgPSBtZWRpYS5idWZmZXJlZC5zdGFydChpKSAqIGluYyxcclxuICAgICAgICAgICAgICB3aWR0aCA9IChtZWRpYS5idWZmZXJlZC5lbmQoaSkgKiBpbmMpIC0gc3RhcnRcclxuICAgICAgICAgIG5ldyBBbXN0Um91bmRlZFJlY3QoY3R4TG9hZGVkQmFyLCBsb2FkZWRCYXJIZWlnaHQsIHN0YXJ0LCB3aWR0aClcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgRklOIFVQREFURUJVRkZFUiAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgVVBEQVRFVElNRVJBSUwgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLy9PbiBmaXhlIGxlIHNjYWxlWCBkZSB0aW1lQ3VycmVudCDDoCBsYSB2YWxldXIgY29ycmVzcG9uZGFudCBhdSByYXRpbyA6IGN1cnJlbnRUaW1lL2R1cmF0aW9uXHJcbiAgICAvL1BvdXIgaGFuZGxlLCBvbiByw6lhbGlzZSBsJ29ww6lyYXRpb24gw6lxdWl2YWxlbnRlIGVuIGpvdWFudCBzdXIgbGEgdmFsZXVyIGRlIHNvbiB0cmFuc2xhdGVYLlxyXG4gICAgLy9TaSBsZSBtZWRpYSBlc3QgZW4gbGVjdHVyZSwgb24gcsOpaXTDqHJlIGwnb3DDqXJhdGlvbiB2aWEgdW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAvL09uIGVucmVnaXN0cmUgbGUgcmF5b24gZGUgaGFuZGxlXHJcbiAgICBsZXQgaGFuZGxlUmFkaXVzID0gMC41ICogaGFuZGxlLm9mZnNldFdpZHRoXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVUaW1lUmFpbCgpe1xyXG4gICAgICBsZXQgdHJhbnMgPSAobWVkaWEucGF1c2VkICYmICFtZWRpYS5zZWVraW5nKT8nYWxsIC4xNXMgZWFzZS1pbic6J25vbmUnLFxyXG4gICAgICAgICAgdCA9IG1lZGlhLmN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgVCA9IG1lZGlhLmR1cmF0aW9uLFxyXG4gICAgICAgICAgLy9TaSBsYSBzb3VyY2UgY2hhbmdlLCBtZWRpYS5kdXJhdGlvbiByaXNxdWUgZGUgbmUgcGFzIMOqdHJlIGTDqWZpbmllLlxyXG4gICAgICAgICAgLy9EYW5zIGNlIGNhcywgcmF0aW8gdmF1dCAwXHJcbiAgICAgICAgICByYXRpbyA9IGlzTmFOKFQpPzA6KHQgLyBUKS50b0ZpeGVkKDQpLFxyXG4gICAgICAgICAgdHJhbnNsYXRlID0gKHJhdGlvICogc2xpZGVyV2lkdGgpIC0gaGFuZGxlUmFkaXVzXHJcbiAgICAgIHRyYW5zbGF0ZSA9IE1hdGgubWF4KHRyYW5zbGF0ZSwgMClcclxuICAgICAgdHJhbnNsYXRlID0gTWF0aC5taW4odHJhbnNsYXRlLCBzbGlkZXJXaWR0aCAtIDIgKiBoYW5kbGVSYWRpdXMpICsgJ3B4J1xyXG4gICAgICBpZiAobWVkaWEucGF1c2VkKSB7XHJcbiAgICAgICAgLy9NaXNlIMOgIGpvdXIgZGUgdGltZUN1cnJlbnRcclxuICAgICAgICB0aW1lQ3VycmVudC5jc3Moe1t0cmFuc2l0aW9uUHJlZml4XTp0cmFucywgW3RyYW5zZm9ybVByZWZpeF06YHNjYWxlWCgke3JhdGlvfSlgfSlcclxuICAgICAgICAvL01pc2Ugw6Agam91ciBkZSBoYW5kbGVcclxuICAgICAgICBoYW5kbGUuY3NzKHtbdHJhbnNpdGlvblByZWZpeF06dHJhbnMsIFt0cmFuc2Zvcm1QcmVmaXhdOmB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlfSlgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL01pc2Ugw6Agam91ciBkZSB0aW1lQ3VycmVudFxyXG4gICAgICAgIHRpbWVDdXJyZW50LmNzcyh7W3RyYW5zaXRpb25QcmVmaXhdOnRyYW5zLCBbdHJhbnNmb3JtUHJlZml4XTpgc2NhbGVYKCR7cmF0aW99KWB9KVxyXG4gICAgICAgIC8vTWlzZSDDoCBqb3VyIGRlIGhhbmRsZVxyXG4gICAgICAgIGhhbmRsZS5jc3Moe1t0cmFuc2l0aW9uUHJlZml4XTp0cmFucywgW3RyYW5zZm9ybVByZWZpeF06YHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGV9KWB9KVxyXG4gICAgICAgIHVwZGF0ZVRpbWVSYWlsQW5pbWF0aW9uID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVRpbWVSYWlsKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICBGSU4gVVBEQVRFVElNRVJBSUwgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgw4lWVFMgVEFDVElMRVMgU1VSIExBIFZJRMOJTyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvKlxyXG4gICAgw4AgbGEgc3VpdGUgZCd1biDDqXbDqG5lbWVudCAndG91Y2hzdGFydCcsIG9uIHBsYWNlIHVuIMOpY291dGV1ciBzdXIgbCfDqXbDqG5lbWVudCAndG91Y2hlbmQnXHJcbiAgICBDZXQgw6ljb3V0ZXVyIGVzdCByZXRpcsOpIHNpIHVuIMOpdsOobmVtZW50IHRvdWNobW92ZSBlc3QgZMOpY2xlbmNow6kuXHJcbiAgICBTaSBsYSB2aWTDqW8gZXN0IGVuIHBhdXNlIDpcclxuICAgICAgLSBvbiBhZmZpY2hlIGxlIGdyb3MgYm91dG9uIFBsYXkgYXUgY2VudHJlIGV0IGxhIGJhcnJlIGRlIGNvbnRyw7RsZS5cclxuICAgICAgLSB1biB0YXAgcGFzc2UgbGEgdmlkw6lvIGVuIGxlY3R1cmUsIGxlIGdyb3MgYm91dG9uIFBsYXkgZXN0IGNhY2jDqSBcclxuICAgICAgICAgIGV0IGxhIGJhcnJlIGRlIGNvbnRyw7RsZSBkaXNwYXJhaXQgYXUgYm91dCBkJ3VuIHRlbXBzIGTDqWZpbmkgcGFyIGwnb3B0aW9uIGhpZGVDb250cm9sc0RlbGF5LlxyXG4gICAgICAtIHVuIHNsaWRlIGhvcml6b250YWwgYWZmaWNoZSBsZSBzZWVraW5nIGV0LCBsZSBjYXMgw6ljaMOpYW50LCBsYSB2aWduZXR0ZSBcclxuICAgICAgICAgIG1haXMgZmFpdCBkaXNwYXJhaXRyZSBsYSBiYXJyZSBkZSBjb250cm9sZS5cclxuICAgICAgICAgIENlbGxlLWNpIHLDqWFwcGFyYWl0IMOgIGxhIGZpbiBkdSBzbGlkZSwgbGEgdmlkw6lvIHJlc3RlIGVuIHBhdXNlIGV0IHNhIHTDqnRlIGRlIGxlY3R1cmUgZXN0IHBvc2l0aW9ubsOpZVxyXG4gICAgICAgICAgYXUgdGVtcHMgY29ycmVzcG9uZGFudCDDoCBsJ2VuZHJvaXQgb8O5IGxlIHNsaWRlIGEgY2Vzc8OpLlxyXG4gICAgU2kgbGEgdmlkw6lvIGVzdCBlbiBsZWN0dXJlIDpcclxuICAgICAgLSB1biB0YXAgcGFzc2UgbGEgdmlkw6lvIGVuIHBhdXNlIGV0IG9uIGFmZmljaGUgbGUgZ3JvcyBib3V0b24gUGxheSBhaW5zaSBxdWUgbGEgYmFycmUgZGUgY29udHLDtGxlLlxyXG4gICAgICAtIHNpIGxhIGJhcnJlIGRlIGNvbnRyw7RsZSBlc3QgYXBwYXJlbnRlLCB1biBzbGlkZSB2ZXJ0aWNhbCB2ZXJzIGxlIGJhcyBsYSBmYWl0IGRpc3BhcmFpdHJlLlxyXG4gICAgICAtIHNpIGxhIGJhcnJlIGRlIGNvbnRyw7RsZSBlc3QgY2FjaMOpZSwgdW4gc2xpZGUgdmVydGljYWwgdmVycyBsZSBoYXV0IGxhIGZhaXQgYXBwYXJhaXRyZS5cclxuICAgICAgLSB1biBzbGlkZSBob3Jpem9udGFsIGFmZmljaGUgbGUgc2Vla2luZyBldCwgbGUgY2FzIMOpY2jDqWFudCwgbGEgdmlnbmV0dGUuIFNpIGVsbGUgZXN0IGFwcGFyZW50ZSwgbGEgYmFycmUgZGUgY29udHLDtGxlIGVzdCBjYWNow6llLlxyXG4gICAgICAgICAgw4AgbGEgZmluIGR1IHNsaWRlLCBsYSBsZWN0dXJlIHJlcHJlbmQgYXUgdGVtcHMgY29ycmVzcG9uZGFudCDDoCBsJ2VuZHJvaXQgb8O5IGxlIHNsaWRlIGEgY2Vzc8OpLlxyXG4gICAgKi9cclxuICAgICQkKFttZWRpYSwgbGF5ZXJMb2FkaW5nLCBsYXllclNlZWtpbmdUb3VjaCwgbGF5ZXJQbGF5XSlcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gJChlLnRhcmdldCksXHJcbiAgICAgICAgICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgLy9EdXLDqWUgbWF4aW1hbGUsIGV4cHJpbcOpZSBlbiBtcywgY29tcHJpc2UgZW50cmUgdG91Y2hzdGFydCBldCB0b3VjaGVuZCBwb3VyIHF1ZSBcclxuICAgICAgICAgICAgICAvL2wnw6l2w6huZW1lbnQgcsOpc3VsdGFudCBzb2l0IGNvbnNpZMOpcsOpIGNvbW1lIHVuIGNsaWNrIHNpIGF1Y3VuIHRvdWNobW92ZSBuJ2Egw6l0w6kgZMOpdGVjdMOpLlxyXG4gICAgICAgICAgICAgIG1heERlbGF5ID0gODAwLFxyXG4gICAgICAgICAgICAgIC8vUG9zaXRpb24gdGVtcG9yZWxsZSBleHByaW3DqWUgZW4gcG91cmNlbnRhZ2UgcGFyIHJhcHBvcnQgw6AgbGEgZHVyw6llIGR1IG3DqWRpYVxyXG4gICAgICAgICAgICAgIHRpbWVSYXRpbyA9IChtZWRpYS5kdXJhdGlvbik/bWVkaWEuY3VycmVudFRpbWUvbWVkaWEuZHVyYXRpb246dW5kZWZpbmVkXHJcbiAgICAgICAgbGV0IHN0YXJ0WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVgsLy9BYnNjaXNzZSBkZSBsJ8OpdsOobmVtZW50XHJcbiAgICAgICAgICAgIHN0YXJ0WSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVksLy9PcmRvbm7DqWUgZGUgbCfDqXbDqG5lbWVudFxyXG4gICAgICAgICAgICBkaXN0WCA9IDAsLy9WYXJpYWJsZSBkZXN0aW7DqWUgw6Agc3RvY2tlciBsYSBkaXN0YW5jZSBwYXJjb3VydWUgc3VyIGwnYXhlIFhcclxuICAgICAgICAgICAgZGlzdFkgPSAwLC8vVmFyaWFibGUgZGVzdGluw6llIMOgIHN0b2NrZXIgbGEgZGlzdGFuY2UgcGFyY291cnVlIHN1ciBsJ2F4ZSBZXHJcbiAgICAgICAgICAgIC8vVmFyaWFibGUgaW5jcsOpbWVudMOpZSBkJ3VuIHBhcyDDoCBjaGFxdWUgZm9pcyBxdSdvbiBkw6l0ZWN0ZSB1biBkw6lwbGFjZW1lbnQgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAvL2V0IGTDqWNyw6ltZW50w6llIGQndW4gcGFzIMOgIGNoYXF1ZSBmb2lzIHF1J29uIGTDqXRlY3RlIHVuIGTDqXBsYWNlbWVudCB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICBob3Jpem9udGFsTW92ZSA9IDAsXHJcbiAgICAgICAgICAgIHNlZWtpbmdSYXRpbyA9IHVuZGVmaW5lZCwvL1ZhcmlhYmxlIGTDqWZpbmllIHVuaXF1ZW1lbnQgZGFucyBsZSBjYXMgZCd1biBkw6lwbGFjZW1lbnQgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICB0b2dnbGVDb250cm9scyA9IGZhbHNlLy9WYXJpYWJsZSBwYXNzYW50IMOgIHRydWUgcydpbCBzJ2FnaXQgZCd1biBkw6lwbGFjZW1lbnQgdmVydGljYWxcclxuICAgICAgICB0YXJnZXQub24oJ3RvdWNoZW5kJywgdG91Y2hFbmQsIHBhc3NpdmU/e3Bhc3NpdmU6dHJ1ZX06ZmFsc2UpXHJcbiAgICAgICAgdGFyZ2V0Lm9uKCd0b3VjaG1vdmUnLCB0b3VjaE1vdmUsIHBhc3NpdmU/e3Bhc3NpdmU6ZmFsc2V9OmZhbHNlKVxyXG4gICAgICAgIGZ1bmN0aW9uIHRvdWNoTW92ZShlKXtcclxuICAgICAgICAgIC8vU2kgbGEgdmlkw6lvIG4nZXN0IHBhcyBjaGFyZ8OpZSBldCBuJ2EgZG9uYyBwYXMgZGUgZHVyw6llIGTDqWZpbmllXHJcbiAgICAgICAgICAvL091IHNpIGxhIHZpZMOpbyBlc3QgZW4gcGF1c2UgZXQgcXUnb24gYSBkw6l0ZWN0w6kgdW4gc3dpcGUgdmVydGljYWwsXHJcbiAgICAgICAgICAvL29uIG5lIGZhaXQgcmllbi5cclxuICAgICAgICAgIC8vQWluc2ksIHMnaWwgcydhZ2l0IGQndW4gc3dpcGUgdmVydGljYWwsIG9uIG5lIGJsb3F1ZSBwYXMgbGUgc2Nyb2xsLlxyXG4gICAgICAgICAgaWYgKCFtZWRpYS5kdXJhdGlvbiB8fCAoc2VsZi5wYXVzZWQgJiYgaG9yaXpvbnRhbE1vdmUgPCAtNSkpIHJldHVyblxyXG4gICAgICAgICAgLy9EYW5zIHRvdXMgbGVzIGF1dHJlcyBjYXNlLCBvbiBibG9xdWUgbGUgc2Nyb2xsIMOpdmVudHVlbC5cclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgLy9NZXN1cmUgZGVzIGRpc3RhbmNlc1xyXG4gICAgICAgICAgZGlzdFggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gc3RhcnRYXHJcbiAgICAgICAgICBkaXN0WSA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBzdGFydFlcclxuICAgICAgICAgIC8vTWlzZSDDoCBqb3VyIGRlIGhvcml6b250YWxNb3ZlIGVuIGZvbmN0aW9uIGR1IG1vdXZlbWVudCBkw6l0ZWN0w6lcclxuICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0WCkgPiBNYXRoLmFicyhkaXN0WSkpIHsvL0hvcml6b250YWxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbE1vdmUgKytcclxuICAgICAgICAgIH0gZWxzZSB7Ly9WZXJ0aWNhbFxyXG4gICAgICAgICAgICBob3Jpem9udGFsTW92ZSAtLVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGhvcml6b250YWxNb3ZlID49IDUpIHsvL1NpIGxlIG1vdXZlbWVudCBob3Jpem9udGFsIHNlIGNvbmZpcm1lXHJcbiAgICAgICAgICAgIHNlZWtpbmdSYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KHRpbWVSYXRpbyArIChkaXN0WCAvIHBsYXllcldpZHRoKSwwKSwwLjk5OSlcclxuICAgICAgICAgICAgaWYgKCFzZWVraW5nVG91Y2hXaWR0aCkgc2Vla2luZ1RvdWNoV2lkdGggPSBzZWVraW5nVG91Y2gub2Zmc2V0V2lkdGhcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgoc2Vla2luZ1JhdGlvICogcGxheWVyV2lkdGggLSAwLjUgKiBzZWVraW5nVG91Y2hXaWR0aCwgMCksIHBsYXllcldpZHRoIC0gc2Vla2luZ1RvdWNoV2lkdGgpICsgJ3B4J1xyXG4gICAgICAgICAgICBsZXQgY3NzID0ge1t0cmFuc2Zvcm1QcmVmaXhdOmB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlfSlgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZi5wYXJhbXMudGh1bWJuYWlscy5zcmMpIHtcclxuICAgICAgICAgICAgICBjc3NbJ2JhY2tncm91bmRQb3NpdGlvbiddID0gLSBNYXRoLmZsb29yKHNlZWtpbmdSYXRpbyAqIDEwMCkgKiB0aHVtYldpZHRoICsgJ3B4IDAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2Vla2luZ1RvdWNoLmNzcyhjc3MpXHJcbiAgICAgICAgICAgICQoJy5hbXN0X19zZWVraW5nLXRvdWNoLWNhY2hlJykuc3R5bGVbdHJhbnNmb3JtUHJlZml4XSA9IGBzY2FsZVgoJHtzZWVraW5nUmF0aW99KWBcclxuICAgICAgICAgICAgJCgnLmFtc3RfX3NlZWtpbmctdG91Y2ggPiBzcGFuJykuaW5uZXJIVE1MID0gc2Vjb25kc1RvVGltZUNvZGUobWVkaWEuZHVyYXRpb24gKiBzZWVraW5nUmF0aW8sIChtZWRpYS5kdXJhdGlvbiA+IDM2MDApKVxyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbE1vdmUgPT0gNSkge1xyXG4gICAgICAgICAgICAgIC8vT24gYWZmaWNoZSBsZSBsYXllciBzZWVraW5nXHJcbiAgICAgICAgICAgICAgbGF5ZXJTZWVraW5nVG91Y2guY2xhc3NMaXN0LmFkZCgnYW1zdF9fc2hvdycpXHJcbiAgICAgICAgICAgICAgLy9vbiBjYWNoZSBsYSBiYXJyZSBkZSBjb250csO0bGUgc2FucyBkw6lsYWkgZXQgY2UgbcOqbWUgc2kgbGEgdmlkw6lvIGVzdCBlbiBwYXVzZVxyXG4gICAgICAgICAgICAgIF9oaWRlQ29udHJvbHMoe2RldGFpbDp7ZGVsYXllZDogZmFsc2UsIGZvcmNlZDp0cnVlfX0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgtNSA9PSBob3Jpem9udGFsTW92ZSkgey8vU2kgbGUgbW91dmVtZW50IHZlcnRpY2FsIHNlIGNvbmZpcm1lXHJcbiAgICAgICAgICAgIHRvZ2dsZUNvbnRyb2xzID0gdHJ1ZVxyXG4gICAgICAgICAgICBpZiAoZGlzdFkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgX3Nob3dDb250cm9scygpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgX2hpZGVDb250cm9scygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdG91Y2hFbmQoKXtcclxuICAgICAgICAgIGlmIChzZWVraW5nUmF0aW8gIT0gdW5kZWZpbmVkKSB7Ly9TaSBzZWVraW5nIGV0IGRvbmMgc3dpcGUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAvL09uIHBsYWNlIGxhIHTDqnRlIGRlIGxlY3R1cmUgYXUgdGVtcHMgcsOpc3VsdGFudFxyXG4gICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IG1lZGlhLmR1cmF0aW9uICogc2Vla2luZ1JhdGlvXHJcbiAgICAgICAgICAgIC8vT24gY2FjaGUgbGUgbGF5ZXIgc2Vla2luZ1xyXG4gICAgICAgICAgICBsYXllclNlZWtpbmdUb3VjaC5jbGFzc0xpc3QucmVtb3ZlKCdhbXN0X19zaG93JylcclxuICAgICAgICAgICAgX3Nob3dDb250cm9scygpXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0b2dnbGVDb250cm9scykgey8vU2kgYXVjdW4gbW91dmVtZW50IG4nYSDDqXTDqSBkw6l0ZWN0w6lcclxuICAgICAgICAgICAgLy9TaSBsZSB0b3VjaGVuZCBpbnRlcnZpZW50IGF2YW50IGxlIGTDqWxhaSBtYXhpbXVtIGTDqWZpbmkgcGFyIG1heERlbGF5XHJcbiAgICAgICAgICAgIGlmIChtYXhEZWxheSA+IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgLy9PbiBiYXNjdWxlIGVudHJlIHBhdXNlIGV0IGxlY3R1cmVcclxuICAgICAgICAgICAgICBzZWxmLnRvZ2dsZVBsYXlQYXVzZSgpXHJcbiAgICAgICAgICAgIH0gLyplbHNlIHsgVE9ETyA6IGFmZmljaGVyIGxlIG1lbnUgY29udGV4dHVlbFxyXG4gICAgICAgICAgICAgIHNob3dNZW51KClcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0YXJnZXQub2ZmKCd0b3VjaGVuZCcsIHRvdWNoRW5kKVxyXG4gICAgICAgICAgdGFyZ2V0Lm9mZigndG91Y2htb3ZlJywgdG91Y2hNb3ZlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSwgcGFzc2l2ZT97cGFzc2l2ZTpmYWxzZX06ZmFsc2UpXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgRklOIMOJVlRTIFRBQ1RJTEVTIFNVUiBMQSBWSUTDiU8gICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgw4lWVFMgR8OJTsOJUkFVWCAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvL1NpIGwnb24gZXN0IHBhcyBzdXIgdW4gw6ljcmFuIHRhY3RpbGUsIHVuIGNsaWNrIHN1ciBsYSB2aWTDqW8gcGFzc2UgY2VsbGUtY2kgZW4gcGF1c2VcclxuICAgIC8vbcOqbWUgc2kgdW4gYnVmZmVyaW5nIGVzdCBlbiBjb3Vycy5cclxuICAgICQkKFttZWRpYSwgbGF5ZXJMb2FkaW5nXSkub24oJ2NsaWNrJywgKCk9PnRoaXMucGF1c2UoKSwgZmFsc2UpXHJcbiAgICAvL1RvdXQgw6l2w6huZW1lbnQgc291cmlzIHByb3ZvcXVlIGwnYWpvdXQgZGUgbGEgY2xhc3NlICdrZXlib2FyZC1pbmFjdGl2ZScgYXUgY29udGFpbmVyXHJcbiAgICAvL0NldHRlIGNsYXNzZSBlbXDDqmNoZSBsJ2FmZmljaGFnZSBkJ3VuZSBib3JkdXJlIHN1ciBsZXMgw6lsw6ltZW50cyBxdWkgb250IGxlIGZvY3VzXHJcbiAgICBjb250YWluZXIub24oJ3RvdWNoc3RhcnQgbW91c2Vkb3duJywgKCk9Pntjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9fa2V5Ym9hcmQtYWN0aXZlJyl9LCBwYXNzaXZlP3twYXNzaXZlOnRydWV9OmZhbHNlKVxyXG4gICAgLy8gVW4gY2xpY2sgc3VyIGxlIGJvdXRvbiBQbGF5L1BhdXNlIGTDqWNsZW5jaGUgdW5lIGJhc2N1bGUgUGxheS9QYXVzZSAgIFxyXG4gICAgJCgnLmFtc3RfX3BsYXlwYXVzZScpLm9uKCdjbGljaycsICgpPT50aGlzLnRvZ2dsZVBsYXlQYXVzZSgpKVxyXG4gICAgLy9VbiBjbGljayBzdXIgbGUgZ3JvcyBib3V0b24gUGxheSBhdSBjZW50cmUgZGUgbGEgdmlkw6lvIGTDqWNsZW5jaGUgdW5lIGxlY3R1cmUgXHJcbiAgICBsYXllclBsYXkub24oJ2NsaWNrJywgKCk9PnRoaXMucGxheSgpKVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICBGSU4gw4lWVFMgR8OJTsOJUkFVWCAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgIEFGRklDSEVSL0NBQ0hFUiBMRVMgQ09OVFLDlExFUyAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvL1NpIGxlIHBvaW50ZXVyIGVzdCBzdXIgbGEgYmFycmUgZGUgY29udHLDtGxlLCBvbiBibG9xdWUgbGEgZGlzcGFyaXRpb24gZGUgbGEgYmFycmVcclxuICAgIC8vUydpbCBzb3J0IGRlIGxhIHpvbmUsIG9uIHLDqXRhYmxpdCBsYSBkaXNwYXJpdGlvblxyXG4gICAgLy9SaWVuIG5lIHNlIHBhc3NlIHNpIGwnb24gZXN0IHN1ciB0YWN0aWxlXHJcbiAgICBjb250cm9sc1xyXG4gICAgICAub24obXlQb2ludGVyRW50ZXIsIChlKT0+e1xyXG4gICAgICAgIGlmIChteVBvaW50ZXJUeXBlID09ICd0b3VjaCcgfHwgKGUucG9pbnRlclR5cGUgJiYgZS5wb2ludGVyVHlwZSA9PSAndG91Y2gnKSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgX3Nob3dDb250cm9scygpXHJcbiAgICAgICAgcG9pbnRlck92ZXJDb250cm9scyA9IHRydWVcclxuICAgICAgfSlcclxuICAgICAgLm9uKG15UG9pbnRlckxlYXZlLCAoZSk9PntcclxuICAgICAgICBpZiAobXlQb2ludGVyVHlwZSA9PSAndG91Y2gnIHx8IChlLnBvaW50ZXJUeXBlICYmIGUucG9pbnRlclR5cGUgPT0gJ3RvdWNoJykpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIHBvaW50ZXJPdmVyQ29udHJvbHMgPSBmYWxzZVxyXG4gICAgICAgIF9oaWRlQ29udHJvbHMoe2RldGFpbDp7ZGVsYXllZDp0cnVlfX0pXHJcbiAgICAgIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgIEZJTiBBRkZJQ0hFUi9DQUNIRVIgTEVTIENPTlRSw5RMRVMgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICDDiVbDiU5FTUVOVFMgU1VSIFJBSUwgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLypcclxuICAgIEFmaW4gZGUgZmFjaWxpdGVyIGxhIHZpZSBkdSB2aXNpdGV1ciwgbGUgcmFpbCBkaXNwb3NlIGQndW5lIGhhdXRldXIgZGUgMzVweC5cclxuICAgIFVuIGNsaWMgb3UgdW4gbW92ZSBhbcOobmUgbGUgY3Vyc2V1ciDDoCBsYSBwb3NpdGlvbiBkZSBsJ8OpdsOobmVtZW50XHJcbiAgICBldCBsYSB0w6p0ZSBkZSBsZWN0dXJlIGRlIHZpZMOpbyBhdSB0ZW1wcyBjb3JyZXNwb25kYW50LlxyXG4gICAgT24gcG9zZSB1biDDqWNvdXRldXIgc3VyIGwnw6l2w6huZW1lbnQgbXlQb2ludGVyRG93biBxdWkgY29ycmVzcG9uZCDDoCBtb3VzZWRvd24gc3VyIGRlc2t0b3BcclxuICAgIGV0IMOgIHRvdWNoc3RhcnQgc3VyIHRhY3RpbGUuXHJcbiAgICAqL1xyXG4gICAgcmFpbC5vbihteVBvaW50ZXJEb3duLCAoKT0+e1xyXG4gICAgICAvL1NpIGxhIHZpZMOpbyBuJ2VzdCBwYXMgY2hhcmfDqWUsIG9uIGFiYW5kb25uZS4uLlxyXG4gICAgICBpZiAoaXNOYU4obWVkaWEuZHVyYXRpb24pKSByZXR1cm4gZmFsc2VcclxuICAgICAgLy9TaW5vbiwgb24gcG9zZSB1biDDqWNvdXRldXIgc3VyIGwnw6l2w6huZW1lbnQgbXlQb2ludGVyTW92ZSAobW91c2Vtb3ZlL3RvdWNobW92ZSlcclxuICAgICAgLy9ldCB1biBhdXRyZSBzdXIgbXlQb2ludGVyVXAgKG1vdXNldXAvdG91Y2hlbmQpIGV0IG15cG9pbnRlckxlYXZlIChtb3VzZWxlYXZlKVxyXG4gICAgICByYWlsLm9uKG15UG9pbnRlck1vdmUsIG1vdmVIYW5kbGUsIHBhc3NpdmU/e3Bhc3NpdmU6dHJ1ZX06ZmFsc2UpXHJcbiAgICAgIHJhaWwub24obXlQb2ludGVyVXAgKyAnICcgKyAgbXlQb2ludGVyTGVhdmUsIGNsZWFuVGltZVNsaWRlck1vdmVFdmVudHMsIGZhbHNlKVxyXG4gICAgfSwgcGFzc2l2ZT97cGFzc2l2ZTp0cnVlfTpmYWxzZSlcclxuICAgIGZ1bmN0aW9uIG1vdmVIYW5kbGUoZSkge1xyXG4gICAgICAvL09uIGTDqXRlcm1pbmUgbCdhYnNjaXNzZSBkZSBsYSBwb3NpdGlvbiBvw7kgbCfDqXbDqG5lbWVudCBzZSBwcm9kdWl0XHJcbiAgICAgIC8vZXQgb24gZW4gZMOpZHVpdCBsYSBwb3NpdGlvbiB0ZW1wb3JlbGxlIHLDqXN1bHRhbnRlIGRlIGxhIHTDqnRlIGRlIGxlY3R1cmVcclxuICAgICAgbGV0IGV2ZW50WCA9IChlLmNoYW5nZWRUb3VjaGVzKT9lLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg6ZS5jbGllbnRYLFxyXG4gICAgICAgICAgeCA9IGV2ZW50WCAtIHNsaWRlckxlZnQsXHJcbiAgICAgICAgICB0cmFuc2xhdGUgPSB4IC8gc2xpZGVyV2lkdGhcclxuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0cmFuc2xhdGUgKiBtZWRpYS5kdXJhdGlvblxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYW5UaW1lU2xpZGVyTW92ZUV2ZW50cyhlKXtcclxuICAgICAgLy9TaSBsYSB2aWTDqW8gbidlc3QgcGFzIGVuIHBhdXNlIGV0IHF1ZSBsZSBwb2ludGV1ciBuZSBzdXJ2b2xlIHBsdXMgbGEgYmFycmUgZGUgY29udHLDtGxlLFxyXG4gICAgICAvL29uIHByb2dyYW1tZSBsYSBkaXNwYXJpdGlvbiBkZSBsYWRpdGUgYmFycmUuXHJcbiAgICAgIGlmICghc2VsZi5wYXVzZWQgJiYgIXBvaW50ZXJPdmVyQ29udHJvbHMpIF9oaWRlQ29udHJvbHMoe2RldGFpbDp7ZGVsYXllZDp0cnVlfX0pXHJcbiAgICAgIC8vT24gb3DDqHJlIGxlIGTDqXBsYWNlbWVudCBkZSBsYSB0w6p0ZSBkZSBsZWN0dXJlIGNlIHF1aSBwcm92b3F1ZSBjZWx1aSBkdSBjdXJzZXVyXHJcbiAgICAgIG1vdmVIYW5kbGUoZSlcclxuICAgICAgLy9PbiByZXRpcmUgbGVzIMOpY291dGV1cnMuXHJcbiAgICAgIHJhaWwub2ZmKG15UG9pbnRlck1vdmUsIG1vdmVIYW5kbGUpXHJcbiAgICAgIHJhaWwub2ZmKG15UG9pbnRlclVwICsgJyAnICsgIG15UG9pbnRlckxlYXZlLCBjbGVhblRpbWVTbGlkZXJNb3ZlRXZlbnRzKVxyXG4gICAgfVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgIEZJTiDDiVbDiU5FTUVOVFMgU1VSIFJBSUwgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgw4lWw4lORU1FTlRTIFNPVVJJUyBTVVIgU0xJREVSICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvL0xvcnNxdWUgbGEgc291cmlzIHN1cnZvbGUgbGEgYmFycmUgZGUgbGVjdHVyZSwgb24gZmFpdCBhcHBhcmHDrnRyZSBsZSBjdXJzZXVyXHJcbiAgICAvL2luZGlxdWFudCBsYSBwb3NpdGlvbiB0ZW1wb3JlbGxlIGNvcnJlc3BvbmRhbnRlIGFpbnNpIHF1ZSBsYSB2aWduZXR0ZSBzaSB0aHVtYm5haWxzLnNyYyBlc3QgZMOpZmluaS5cclxuICAgIHRocm90dGxlKG15UG9pbnRlck1vdmUsICdvcHRpbWl6ZWRQb2ludGVyTW92ZScsIHNsaWRlcilcclxuICAgIC8vTCfDqWzDqW1lbnQgc2Vla2luZyBzZSBkw6lwbGFjZSBhdmVjIGxlIHBvaW50ZXVyIGV0IG9uIGFjdHVhbGlzZSBzb24gY29udGVudSBhZmZpY2jDqSBlbiBjb25zw6lxdWVuY2VcclxuICAgIHNsaWRlci5vbignb3B0aW1pemVkUG9pbnRlck1vdmUnLCAoZSk9PntcclxuICAgICAgLy9TaSBsJ8OpdsOobmVtZW50IGVzdCBkZSBzb3VyY2UgdGFjdGlsZSBvdSBxdWUgbGEgdmlkw6lvIG4nZXN0IHBhcyBjaGFyZ8OpZSwgb24gbCdpZ25vcmVcclxuICAgICAgaWYgKG15UG9pbnRlclR5cGUgPT0gJ3RvdWNoJyB8fCAoZS5wb2ludGVyVHlwZSAmJiBlLnBvaW50ZXJUeXBlID09ICd0b3VjaCcpIHx8IGlzTmFOKG1lZGlhLmR1cmF0aW9uKSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgIC8vU2kgbGEgbGFyZ2V1ciBkZSBsJ8OpbMOpbWVudCBzZWVraW5nIG4nYSBwYXMgZW5jb3JlIMOpdMOpIGTDqXRlcm1pbsOpZSxcclxuICAgICAgLy9vbiBpbml0aWFsaXNlIGxhIHZhcmlhYmxlIHNlZWtpbmdXaWR0aFxyXG4gICAgICBpZiAoIXNlZWtpbmdXaWR0aCkgc2Vla2luZ1dpZHRoID0gc2Vla2luZy5vZmZzZXRXaWR0aFxyXG4gICAgICBsZXQgc2Vla2luZ1dyYXBwZXJQb3NpdGlvbiA9IGUuZGV0YWlsLmNsaWVudFggLSBzbGlkZXJMZWZ0XHJcbiAgICAgIGNvbnN0IHNlZWtpbmdSYXRpbyA9IHNlZWtpbmdXcmFwcGVyUG9zaXRpb24gLyBzbGlkZXJXaWR0aCxcclxuICAgICAgICAgICAgdGh1bWJCYWNrZ3JvdW5kUG9zaXRpb24gPSAtIE1hdGguZmxvb3Ioc2Vla2luZ1JhdGlvICogMTAwKSAqIHRodW1iV2lkdGggKyAncHgnLFxyXG4gICAgICAgICAgICBzZWVraW5nV3JhcHBlckhhbGZXaWR0aCA9IDAuNSAqIHNlZWtpbmdXaWR0aCAtIDZcclxuICAgICAgaWYgKHNlbGYucGFyYW1zLnRodW1ibmFpbHMuc3JjKSBzZWVraW5nLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IHRodW1iQmFja2dyb3VuZFBvc2l0aW9uICsgJyAwJ1xyXG4gICAgICAkKCcuYW1zdF9fY3Vyc29yJykuc3R5bGVbdHJhbnNmb3JtUHJlZml4XSA9IGB0cmFuc2xhdGVYKCR7c2Vla2luZ1dyYXBwZXJQb3NpdGlvbn1weClgXHJcbiAgICAgIC8vT24gZmFpdCBlbiBzb3J0ZSBxdWUgbGUgd3JhcHBlciBuZSBkw6lib3JkZSBwYXMgYXV4IGV4dHLDqW1pdMOpcyBkZSBsYSBiYXJyZSB0ZW1wb3JlbGxlXHJcbiAgICAgIHNlZWtpbmdXcmFwcGVyUG9zaXRpb24gPSBNYXRoLm1heChzZWVraW5nV3JhcHBlclBvc2l0aW9uLCBzZWVraW5nV3JhcHBlckhhbGZXaWR0aClcclxuICAgICAgc2Vla2luZ1dyYXBwZXJQb3NpdGlvbiA9IE1hdGgubWluKHNlZWtpbmdXcmFwcGVyUG9zaXRpb24sIHNsaWRlcldpZHRoIC0gc2Vla2luZ1dyYXBwZXJIYWxmV2lkdGgpXHJcbiAgICAgICQoJy5hbXN0X19zZWVraW5nLXdyYXBwZXInKS5zdHlsZVt0cmFuc2Zvcm1QcmVmaXhdID0gYHRyYW5zbGF0ZVgoJHtzZWVraW5nV3JhcHBlclBvc2l0aW9ufXB4KWBcclxuICAgICAgJCgnLmFtc3RfX3NlZWtpbmcgPiBzcGFuJykuaW5uZXJIVE1MID0gc2Vjb25kc1RvVGltZUNvZGUoc2Vla2luZ1JhdGlvICogbWVkaWEuZHVyYXRpb24sIChtZWRpYS5kdXJhdGlvbiA+IDM2MDApKVxyXG4gICAgfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgRklOIFNPVVJJUyBTVVIgU0xJREVSICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgIFZPTFVNRUNIQU5HRSAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBtZWRpYS5vbigndm9sdW1lY2hhbmdlJywgKCk9PntcclxuICAgICAgaWYgKCFJU19NT0JJTEUpIHtcclxuICAgICAgICBjb25zdCB2b2wgPSBwYXJzZUludChtZWRpYS52b2x1bWUgKiAxMDApXHJcbiAgICAgICAgdm9sdW1lU2xpZGVyLnNldEF0dHJpYnV0ZXMoe1xyXG4gICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiB2b2wsXHJcbiAgICAgICAgICAnYXJpYS12YWx1ZXRleHQnOiB2b2wgKyAnJScsXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZiAodmlkZW9Wb2x1bWVPcmllbnRhdGlvbiA9PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICQoJy5hbXN0X192b2x1bWUtY3VycmVudCcpLnN0eWxlLndpZHRoID0gdm9sICsgJyUnXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICQoJy5hbXN0X192b2x1bWUtaGFuZGxlJykuc3R5bGUuYm90dG9tID0gdm9sICsgJyUnXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vTWlzZSDDoCBqb3VyIGVuIGNhcyBkZSBtdXRlL2RlbXV0ZVxyXG4gICAgICBpZiAobWVkaWEudm9sdW1lID09IDApIHtcclxuICAgICAgICBtZWRpYS5tdXRlZCA9IHRydWVcclxuICAgICAgICB2b2x1bWVCdXR0b24uc2V0QXR0cmlidXRlcyh7XHJcbiAgICAgICAgICB0aXRsZTogc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmxhYmVsLnVubXV0ZSxcclxuICAgICAgICAgICdhcmlhLWxhYmVsJzogc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmxhYmVsLnVubXV0ZSxcclxuICAgICAgICAgIGNsYXNzOiAnYW1zdF9fdW5tdXRlJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWVkaWEubXV0ZWQgPSBmYWxzZVxyXG4gICAgICAgIHZvbHVtZUJlZm9yZU11dGUgPSBtZWRpYS52b2x1bWVcclxuICAgICAgICBpZiAodm9sdW1lQnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygnYW1zdF9fdW5tdXRlJykpIHtcclxuICAgICAgICAgIHZvbHVtZUJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJylcclxuICAgICAgICAgIHZvbHVtZUJ1dHRvbi5zZXRBdHRyaWJ1dGVzKHtcclxuICAgICAgICAgICAgdGl0bGU6IHNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5sYWJlbC5tdXRlLFxyXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5sYWJlbC5tdXRlLFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy9TdG9ja2FnZSBkdSB2b2x1bWUgcG91ciBsZSBncm91cGUgY29ycmVzcG9uZGFudFxyXG4gICAgICBpZiAoc3RvcmFnZSAmJiBzZWxmLnBhcmFtcy52b2x1bWVHcm91cCA+IDApIHtcclxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oYGFtc3Rfdm9sdW1lZ3JvdXAke3NlbGYucGFyYW1zLnZvbHVtZUdyb3VwfWAsIHNlbGYudm9sdW1lKVxyXG4gICAgICB9XHJcbiAgICAgIHNlbGYucGFyYW1zLnZvbHVtZSA9IHNlbGYudm9sdW1lXHJcbiAgICAgIC8vUHJvcGFnYXRpb24gZHUgY2hhbmdlbWVudCBkZSB2b2x1bWUgYXUgw6l2ZW50dWVscyBhdXRyZXMgcGxheWVycyBkdSBtw6ptZSB2b2x1bWVHcm91cFxyXG4gICAgICBpZiAoc2VsZi5wYXJhbXMudm9sdW1lR3JvdXAgPiAwICYmIEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIucGxheWVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5wbGF5ZXJzLmZvckVhY2goKHBsYXllcik9PntcclxuICAgICAgICAgIGlmIChwbGF5ZXIgIT0gc2VsZiAmJiBwbGF5ZXIucGFyYW1zLnZvbHVtZUdyb3VwID09IHNlbGYucGFyYW1zLnZvbHVtZUdyb3VwICYmIHBsYXllci52b2x1bWUgIT0gc2VsZi52b2x1bWUpIHtcclxuICAgICAgICAgICAgcGxheWVyLnZvbHVtZSA9IHNlbGYudm9sdW1lXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICBGSU4gVk9MVU1FQ0hBTkdFICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgVk9MVU1FIENMSUNLIFNVUiBIUCAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICB2b2x1bWVCdXR0b24ub24oJ2NsaWNrJywgKCk9PntcclxuICAgICAgaWYgKG1lZGlhLm11dGVkKSB7XHJcbiAgICAgICAgbWVkaWEudm9sdW1lID0gdm9sdW1lQmVmb3JlTXV0ZVxyXG4gICAgICAgIG1lZGlhLm11dGVkID0gZmFsc2VcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZWRpYS52b2x1bWUgPSAwXHJcbiAgICAgICAgbWVkaWEubXV0ZWQgPSB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgRklOIFZPTFVNRSBDTElDSyBTVVIgSFAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgVk9MVU1FIFBPVEVOVElPTcOIVFJFIC0gU09VUklTICYgQ0xBVklFUiAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGlmICghSVNfTU9CSUxFKSB7XHJcbiAgICAgIHZvbHVtZVNsaWRlci5vbihteVBvaW50ZXJEb3duLCgpPT57XHJcbiAgICAgICAgdm9sdW1lU2xpZGVyXHJcbiAgICAgICAgICAub24obXlQb2ludGVyTW92ZSwgdXBkYXRlVm9sdW1lKVxyXG4gICAgICAgICAgLm9uKG15UG9pbnRlckxlYXZlLCBjbGVhblZvbHVtZUV2ZW50cylcclxuICAgICAgICAgIC5vbihteVBvaW50ZXJVcCwgdXBkYXRlVm9sdW1lKVxyXG4gICAgICAgICAgLm9uKG15UG9pbnRlclVwLCBjbGVhblZvbHVtZUV2ZW50cylcclxuICAgICAgfSlcclxuICAgICAgY29uc3QgdXBkYXRlVm9sdW1lID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgbGV0IHJhdGlvXHJcbiAgICAgICAgaWYgKHZpZGVvVm9sdW1lT3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICByYXRpbyA9IE1hdGgubWF4KDAsIGUuY2xpZW50WCAtIHZvbHVtZVJlY3QubGVmdClcclxuICAgICAgICAgIHJhdGlvID0gIHJhdGlvIC8gdm9sdW1lUmVjdC53aWR0aFxyXG4gICAgICAgICAgcmF0aW8gPSAocmF0aW8gPiAwLjk2KT8xOnJhdGlvXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZvbHVtZVNsaWRlci5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJ1xyXG4gICAgICAgICAgcmF0aW8gPSB2b2x1bWVSZWN0LmhlaWdodCAtIGUuY2xpZW50WSArIHZvbHVtZVJlY3QudG9wXHJcbiAgICAgICAgICByYXRpbyA9IE1hdGgubWF4KDAgLE1hdGgubWluKHJhdGlvLCAxMDApKSAvIDEwMFxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxmLnZvbHVtZSA9IHJhdGlvXHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2xlYW5Wb2x1bWVFdmVudHMgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZvbHVtZVNsaWRlclxyXG4gICAgICAgICAgLm9mZihteVBvaW50ZXJNb3ZlLCB1cGRhdGVWb2x1bWUpXHJcbiAgICAgICAgICAub2ZmKG15UG9pbnRlckxlYXZlLCBjbGVhblZvbHVtZUV2ZW50cylcclxuICAgICAgICAgIC5vZmYobXlQb2ludGVyVXAsIHVwZGF0ZVZvbHVtZSlcclxuICAgICAgICAgIC5vZmYobXlQb2ludGVyVXAsIGNsZWFuVm9sdW1lRXZlbnRzKVxyXG4gICAgICAgIGlmICh2aWRlb1ZvbHVtZU9yaWVudGF0aW9uID09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgIHZvbHVtZVNsaWRlci5zdHlsZS5jdXJzb3IgPSAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvL8OpdsOobmVtZW50cyBjbGF2aWVyXHJcbiAgICAgIGNvbnRhaW5lci5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X19rZXlib2FyZC1hY3RpdmUnKVxyXG4gICAgICAgIF9zaG93Q29udHJvbHMoKVxyXG4gICAgICAgIGlmIChbMzcsMzgsMzksNDAsNzddLmluY2x1ZGVzKGUud2hpY2gpKSBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICBpZiAoZS53aGljaCA+IDM2ICYmIGUud2hpY2ggPCA0MSkge1xyXG4gICAgICAgICAgaWYgKChlLndoaWNoID09IDM4IHx8IGUud2hpY2ggPT0gNDApICYmIGQuYWN0aXZlRWxlbWVudCAhPSB2b2x1bWVTbGlkZXIpIHtcclxuICAgICAgICAgICAgaWYgKHZpZGVvVm9sdW1lT3JpZW50YXRpb24gPT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgIHZvbHVtZVNsaWRlci5vbigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICB2b2x1bWVCdXR0b24uZm9jdXMoKVxyXG4gICAgICAgICAgICB9IGVsc2Ugdm9sdW1lU2xpZGVyLmZvY3VzKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoKGUud2hpY2ggPT0gMzcgfHwgZS53aGljaCA9PSAzOSkgJiYgZC5hY3RpdmVFbGVtZW50ICE9IHNsaWRlcikge1xyXG4gICAgICAgICAgICBzbGlkZXIuZm9jdXMoKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcclxuICAgICAgICAgIGNhc2UgNzc6Ly9NLT5NdXRlL1VubXV0ZVxyXG4gICAgICAgICAgICBpZiAoc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmRpc2FibGVkICE9PSB0cnVlICYmIHNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5oaWRkZW4gIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICB2b2x1bWVCdXR0b24uZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSlcclxuICAgICAgICAgICAgICB2b2x1bWVCdXR0b24uZm9jdXMoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIDQwOi8vQXJyb3cgRG93blxyXG4gICAgICAgICAgICBpZiAoc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmRpc2FibGVkICE9PSB0cnVlICYmIHNlbGYucGFyYW1zLnZvbHVtZUJ1dHRvbi5oaWRkZW4gIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICBzZWxmLnZvbHVtZSA9IE1hdGgubWF4KDAsIHNlbGYudm9sdW1lIC0gMC4wNSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAzODovL0Fycm93IFVwXHJcbiAgICAgICAgICAgIGlmIChzZWxmLnBhcmFtcy52b2x1bWVCdXR0b24uZGlzYWJsZWQgIT09IHRydWUgJiYgc2VsZi5wYXJhbXMudm9sdW1lQnV0dG9uLmhpZGRlbiAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lID0gTWF0aC5taW4oMSwgc2VsZi52b2x1bWUgKyAwLjA1KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIDM3Oi8vQXJyb3cgTGVmdFxyXG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgoMCwgc2VsZi5jdXJyZW50VGltZSAtIHNraXBUaW1lKVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAzOTovL0Fycm93IFJpZ2h0XHJcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFRpbWUgPSBNYXRoLm1pbihzZWxmLmR1cmF0aW9uLCBzZWxmLmN1cnJlbnRUaW1lICsgc2tpcFRpbWUpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlIDMyOi8vU3BhY2VcclxuICAgICAgICAgICAgaWYgKGQuYWN0aXZlRWxlbWVudCA9PSBwbGF5UGF1c2VCdXR0b24pIHtcclxuICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgIT0gJ0JVVFRPTicpIHtcclxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgICBzZWxmLnRvZ2dsZVBsYXlQYXVzZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZhbHNlKVxyXG4gICAgfVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgRklOIFZPTFVNRSBQT1RFTlRJT03DiFRSRSAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgIEZVTExTQ1JFRU4gICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAvKlxyXG4gICAgTG9yc3F1J29uIHBhc3NlIGVuIHBsZWluIMOpY3JhbiwgbGVzIHByb3ByacOpdMOpcyBwYWdlWE9mZnNldCBldCBwYWdlWU9mZnNldCBkZSB3aW5kb3cgc29udCBtb2RpZmnDqWVzLlxyXG4gICAgU2kgbCdvbiBuZSBwcmVuZCBwYXMgZGUgcHLDqWNhdXRpb25zLCDDoCBsYSBzb3J0aWUgZHUgcGxlaW4gw6ljcmFuLCBsYSBwYWdlIGF1cmEgcGVyZHUgc29uIHNjcm9sbCBpbml0aWFsLlxyXG4gICAgT24gaW50aWFsaXNlIGRvbmMgZGV1eCB2YXJpYWJsZXMgc2Nyb2xsWCBldCBzY3JvbGxZIGRhbnMgbGVzcXVlbGxlcyBvbiBzdG9ja2VyYSBsZXMgdmFsZXVycyBkZSBzY3JvbGxcclxuICAgIGF2YW50IGxlIHBhc3NhZ2UgZW4gcGxlaW4gw6ljcmFuIHBvdXIgcG91dm9pciBsZXMgcsOpdGFibGlyIMOgIGxhIHNvcnRpZS5cclxuICAgIEF1IHBhc3NhZ2UgZW4gbW9kZSBwbGVpbiDDqWNyYW4sIG9uIHBvc2UgdW4gw6ljb3V0ZXVyIHNww6ljaWZpcXVlIHN1ciBsJ8OpdsOpbmVtZW50IHJlc2l6ZS5cclxuICAgIERhbnMgY2UgbW9kZSwgbGUgZGlzcGxheSBkdSB3cmFwcGVyIHBhc3NlIGVuIGZsZXggZXQgb24gcG9zZSB1biBtYXJnaW46YXV0byBzdXIgbGUgY29udGFpbmVyXHJcbiAgICBhZmluIGQnYXNzdXJlciBzb24gY2VudHJhZ2UgaG9yaXpvbnRhbCBldCB2ZXJ0aWNhbC5cclxuICAgIFNpIGwnw6ljcmFuIGVzdCBwbHVzIGxhcmdlIHF1ZSBsYSB2aWTDqW8sIGxlIGNvbnRhaW5lciBlc3QgY2VudHLDqSBob3Jpem9udGFsZW1lbnQsIHNhIGhhdXRldXIgZXN0IGZpeMOpZSDDoCAxMDAlLCBcclxuICAgIHNvbiBwYWRkaW5nLWJvdHRvbSBlc3QgYW5udWzDqSBldCBzYSBsYXJnZXVyIGVzdCBkw6l0ZXJtaW7DqWUgZ3LDomNlIGF1IGZvcm1hdCBkZSBsYSB2aWTDqW8uXHJcbiAgICBEYW5zIGxlIGNhcyBjb250cmFpcmUsIGxlIGNvbnRhaW5lciBlc3QgY2VudHLDqSB2ZXJ0aWNhbGVtZW50LCBzb24gcGFkZGluZy1ib3R0b20gZXN0IGRvbm7DqSBwYXIgbGUgZm9ybWF0IGRlIGxhIHZpZMOpbyBldCBzYSBsYXJnZXVyIGZpeMOpZSDDoCAxMDAlLlxyXG4gICAgw4AgbGEgc29ydGllIGR1IHBsZWluIMOpY3Jhbiwgb24gYXNzdXJlIHVuIG5ldHRveWFnZSBkZXMgc3R5bGVzIGFqb3V0w6lzLlxyXG4gICAgKi9cclxuICAgIGlmIChmdWxsc2NyZWVuQVBJKSB7XHJcbiAgICAgIGxldCBzY3JvbGxYID0gMCwgXHJcbiAgICAgICAgICBzY3JvbGxZID0gMFxyXG4gICAgICBjb25zdCBmdWxsU2NyZWVuQnV0dG9uID0gJCgnLmFtc3RfX2Z1bGxzY3JlZW4+YnV0dG9uJylcclxuICAgICAgZnVsbFNjcmVlbkJ1dHRvbi5vbignY2xpY2snLCAoKT0+e1xyXG4gICAgICAgIGlmIChkW2Z1bGxzY3JlZW5BUEkuZnVsbHNjcmVlbkVsZW1lbnRdICE9PSBudWxsKSB7Ly9PbiBlc3QgZW4gbW9kZSBwbGVpbiDDqWNyYW5cclxuICAgICAgICAgIC8vT24gZW4gc29ydFxyXG4gICAgICAgICAgZFtmdWxsc2NyZWVuQVBJLmV4aXRGdWxsc2NyZWVuXSgpXHJcbiAgICAgICAgfSBlbHNlIHsvL09uIG4nZXN0IHBhcyBlbiBtb2RlIHBsZWluIMOpY3JhblxyXG4gICAgICAgICAgLy9PbiBtw6ltb3Jpc2UgbGEgcG9zaXRpb24gZGFucyBsYSBwYWdlIHBvdXIgcG91dm9pciBsYSByw6l0YWJsaXIgw6AgbGEgc29ydGllIGR1IHBsZWluIMOpY3JhblxyXG4gICAgICAgICAgc2Nyb2xsWCA9IHcucGFnZVhPZmZzZXRcclxuICAgICAgICAgIHNjcm9sbFkgPSB3LnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAvL09uIHBhc3NlIGVuIHBsZWluIMOpY3JhblxyXG4gICAgICAgICAgd3JhcHBlcltmdWxsc2NyZWVuQVBJLnJlcXVlc3RGdWxsc2NyZWVuXSgpXHJcbiAgICAgICAgICAvLyBjb250YWluZXJbZnVsbHNjcmVlbkFQSS5yZXF1ZXN0RnVsbHNjcmVlbl0oKVxyXG4gICAgICAgICAgLy9PbiBpbml0aWFsaXNlIGxhIHByb3ByacOpdMOpIGN1cnJlbnRGdWxsU2NyZWVuUGxheWVyIGRlIGxhIGNsYXNzXHJcbiAgICAgICAgICBBbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmN1cnJlbnRGdWxsU2NyZWVuUGxheWVyID0gc2VsZlxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLy9FY291dGUgZGUgbCfDqXbDqG5lbWVudCBmdWxsc2NyZWVuY2hhbmdlXHJcbiAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcihmdWxsc2NyZWVuQVBJLmZ1bGxzY3JlZW5jaGFuZ2UsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKGRbZnVsbHNjcmVlbkFQSS5mdWxsc2NyZWVuRWxlbWVudF0gPT0gd3JhcHBlcikgey8vU2kgbGUgcGxheWVyIHBhc3NlIGVuIHBsZWluIMOpY3JhblxyXG4gICAgICAgICAgLy/DiWNvdXRlIGR1IHJlc2l6ZVxyXG4gICAgICAgICAgdy5hZGRFdmVudExpc3RlbmVyKCdvcHRpbWl6ZWRSZXNpemUnLCByZXNpemVGdWxsU2NyZWVuKVxyXG4gICAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdhbXN0X19pc2Z1bGxzY3JlZW4nKVxyXG4gICAgICAgICAgLy9PbiBlbmzDqHZlIGxhIHRyYW5zaXRpb24gc3VyIGxhIHBhZGRpbmcgZHUgY29udGFpbmVyXHJcbiAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYW1zdF9fbm90cmFuc2l0aW9uJylcclxuICAgICAgICAgIC8vTWlzZSDDoCBqb3VyIGR1IGJvdXRvbiBldCBkZSBzZXMgbGFiZWxzXHJcbiAgICAgICAgICBmdWxsU2NyZWVuQnV0dG9uLnNldEF0dHJpYnV0ZXMoe1xyXG4gICAgICAgICAgICB0aXRsZTogZXhpdEZ1bGxTY3JlZW5MYWJlbCxcclxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBleGl0RnVsbFNjcmVlbkxhYmVsLFxyXG4gICAgICAgICAgICBjbGFzczonIGFtc3RfX3VuZnVsbHNjcmVlbidcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICByZXNpemVGdWxsU2NyZWVuKClcclxuICAgICAgICB9IGVsc2UgaWYgKEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudEZ1bGxTY3JlZW5QbGF5ZXIgPT0gc2VsZil7Ly9TaSBsZSBwbGF5ZXIgc29ydCBkdSBwbGVpbiDDqWNyYW5cclxuICAgICAgICAgIC8vT24gcmV0aXJlIGwnw6ljb3V0ZXVyIHN1ciBsZSByZXNpemVcclxuICAgICAgICAgIHcucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3B0aW1pemVkUmVzaXplJywgcmVzaXplRnVsbFNjcmVlbilcclxuICAgICAgICAgIC8vT24gcmVzZXQgbGVzIGRpbWVuc2lvbnMgw6l2ZW50dWVsbGVtZW50IHNww6ljaWZpw6llcyBwYXIgbGEgZm9uY3Rpb24gcmVzaXplRnVsbFNjcmVlblxyXG4gICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLGBwYWRkaW5nLWJvdHRvbTokezEgLyBzZWxmLnBhcmFtcy5mb3JtYXQgKiAxMDB9JWApXHJcbiAgICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoJ2Ftc3RfX2lzZnVsbHNjcmVlbicpXHJcbiAgICAgICAgICAvL01pc2Ugw6Agam91ciBkdSBib3V0b24gZXQgZGUgc2VzIGxhYmVsc1xyXG4gICAgICAgICAgZnVsbFNjcmVlbkJ1dHRvbi5zZXRBdHRyaWJ1dGVzKHtcclxuICAgICAgICAgICAgdGl0bGU6IGVudGVyRnVsbFNjcmVlbkxhYmVsLFxyXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGVudGVyRnVsbFNjcmVlbkxhYmVsLFxyXG4gICAgICAgICAgICBjbGFzczogJydcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAvL09uIHNlIHJlcG9zaXRpb25uZSBzdXIgbGEgcGFnZVxyXG4gICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICB3LnNjcm9sbChzY3JvbGxYLCBzY3JvbGxZKVxyXG4gICAgICAgICAgICAvL09uIHJlbWV0IGxhIHRyYW5zaXRpb24gc3VyIGxlIHBhZGRpbmcgZHUgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9Pntjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9fbm90cmFuc2l0aW9uJyl9LDUwKVxyXG4gICAgICAgICAgfSw1MClcclxuICAgICAgICAgIC8vT24gcmVzZXQgbGEgcHJvcHJpw6l0w6kgY3VycmVudEZ1bGxTY3JlZW5QbGF5ZXIgZGUgbGEgY2xhc3NcclxuICAgICAgICAgIEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudEZ1bGxTY3JlZW5QbGF5ZXIgPSB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgY29uc3QgcmVzaXplRnVsbFNjcmVlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh3LmlubmVyV2lkdGggLyB3LmlubmVySGVpZ2h0ID4gc2VsZi5wYXJhbXMuZm9ybWF0KSB7Ly9TaSBsJ8OpY3JhbiBlc3QgcGx1cyBsYXJnZSBxdWUgbGEgdmlkw6lvXHJcbiAgICAgICAgICBjb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6IHcuaW5uZXJIZWlnaHQgKiBzZWxmLnBhcmFtcy5mb3JtYXQgKyAncHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgJ3BhZGRpbmdCb3R0b20nOiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICdwYWRkaW5nQm90dG9tJzogMSAvIHNlbGYucGFyYW1zLmZvcm1hdCAqIDEwMCArICclJ1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzaXplKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgRklOIEZVTExTQ1JFRU4gICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgUkVTSVpFICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIC8qXHJcbiAgICBPbiBlZmZlY3R1ZSB1bmUgbWVzdXJlIGRlcyDDqWzDqW1lbnRzIEhUTUxcclxuICAgIENldHRlIG9ww6lyYXRpb24gZXN0IHBvbmTDqXLDqWUgcGFyIHVuIHNldFRpbWVvdXQgYWZpbiBkJ8Opdml0ZXIgbGVzIHJlZG9uZGFuY2VzLlxyXG4gICAgRWxsZSBlc3QgZW4gZWZmZXQgYXBwZWzDqWUgw6AgY2hhcXVlIGZvaXMgcXUndW4gYm91dG9uIGVzdCBtaXMgw6Agam91ci5cclxuICAgIFNpIHBsdXNpZXVycyBib3V0b25zIHNvbnQgbW9kaWZpw6lzIGVuIG3Dqm1lIHRlbXBzLCBlbGxlIG4nZXN0IGFpbnNpIGVmZmVjdHXDqWUgcXUndW5lIGZvaXMuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29udHJvbHNFbGVtZW50c1dpZHRoKCl7XHJcbiAgICAgIGlmICh0aW1lb3V0R2V0Q29udHJvbHNFbGVtZW50c1dpZHRoKSBjbGVhclRpbWVvdXQodGltZW91dEdldENvbnRyb2xzRWxlbWVudHNXaWR0aClcclxuICAgICAgdGltZW91dEdldENvbnRyb2xzRWxlbWVudHNXaWR0aCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICBjb250cm9sc0VsZW1lbnRzV2lkdGggPSAwXHJcbiAgICAgICAgJCQoJy5hbXN0X19jb250cm9scz5kaXY6bm90KC5hbXN0X19yYWlsKTpub3QoLmFtc3RfX2hpZGRlbik6bm90KC5hbXN0X190aW1lLWR1cmF0aW9uKScpLmZvckVhY2goZWw9PntcclxuICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Ftc3RfX3RpbWUnKSkge1xyXG4gICAgICAgICAgICBjb250cm9sc0VsZW1lbnRzV2lkdGggKz0gKDIgKiBlbC5vZmZzZXRXaWR0aClcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzRWxlbWVudHNXaWR0aCArPSBlbC5vZmZzZXRXaWR0aFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIHJlc2l6ZSgpXHJcbiAgICAgIH0sMSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgdy5hZGRFdmVudExpc3RlbmVyKCdvcHRpbWl6ZWRSZXNpemUnLCByZXNpemUpXHJcbiAgICB3LmFkZEV2ZW50TGlzdGVuZXIoJ29wdGltaXplZFNjcm9sbCcsIHJlc2l6ZSlcclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemUoKXtcclxuICAgICAgcGxheWVyV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGhcclxuICAgICAgaWYgKHBsYXllcldpZHRoIC0gY29udHJvbHNQYWRkaW5nIC0gY29udHJvbHNFbGVtZW50c1dpZHRoIDwgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5kZWZhdWx0T3B0aW9ucy5yYWlsTWluV2lkdGhGb3JOb3JtYWxVSSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbXN0X19jb21wYWN0JylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnYW1zdF9fY29tcGFjdCcpXHJcbiAgICAgIH1cclxuICAgICAgbGV0IHNsaWRlclJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgc2xpZGVyTGVmdCA9IHNsaWRlclJlY3QubGVmdFxyXG4gICAgICBzbGlkZXJXaWR0aCA9IHNsaWRlclJlY3Qud2lkdGhcclxuICAgICAgdXBkYXRlVGltZVJhaWwoKVxyXG4gICAgICAvL1NpIGxlIGZvcm1hdCBkZSBsYSBzb3VyY2UgZXN0IG1vZGlmacOpZSwgbCdhYnNjaXNzZSBkdSBwb3RlbnRpb23DqHRyZSBkZSB2b2x1bWUgZW4gbW9kZSB2ZXJ0aWNhbCBcclxuICAgICAgLy9uZSBzZXJhIGZpeMOpZSBxdSfDoCBsYSBmaW4gZGUgbCdhbmltYXRpb24gcG9zw6llIHN1ciBsZSBwYWRkaW5nLWJvdHRvbSBkdSBjb250YWluZXIuXHJcbiAgICAgIGlmICghSVNfTU9CSUxFKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlVm9sdW1lUmVjdCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHZvbHVtZVJlY3QgPSAkKCcuYW1zdF9fdm9sdW1lLXRvdGFsJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ID09IGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBjb250YWluZXIub2ZmKCd0cmFuc2l0aW9uZW5kJywgdXBkYXRlVm9sdW1lUmVjdClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLm9uKCd0cmFuc2l0aW9uZW5kJywgdXBkYXRlVm9sdW1lUmVjdCwgZmFsc2UpXHJcbiAgICAgICAgdXBkYXRlVm9sdW1lUmVjdCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgRklOIFJFU0laRSAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgIEZJTkFMSVNBVElPTiAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe3BhcmFtcy5vbmluaXQoc2VsZil9LDEpXHJcbiAgICB9XHJcblxyXG4gICAgLy9MYSBmb25jdGlvbiBwb2ludGVyRGV0ZWN0ZWQoKSDDqWNvdXRlIGwnw6l2w6huZW1lbnQgJ3BvaW50ZXJEZXRlY3RlZCcgZGlzcGF0Y2jDqSBwYXIgbGEgY2xhc3NcclxuICAgIC8vbG9yc3F1ZSBsZSB0eXBlIGRlIHBvaW50ZXVyIGEgw6l0w6kgZMOpdGVjdMOpLlxyXG4gICAgZnVuY3Rpb24gcG9pbnRlckRldGVjdGVkKCl7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyRGV0ZWN0ZWQnLCBwb2ludGVyRGV0ZWN0ZWQpXHJcbiAgICAgIGlmIChfcG9pbnRlclR5cGUgIT0gJ3RvdWNoJykgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Ftc3RfX25vLXRvdWNoJylcclxuICAgIH1cclxuICAgIC8vU2kgbGEgY2xhc3MgbidhIHBhcyBlbmNvcmUgZMOpdGVjdMOpIGxlIHR5cGUgZGUgcG9pbnRldXIsIG9uIHNlIHByw6lwYXJlIMOgIHLDqWFnaXIgw6Agc2EgZnV0dXJlIGTDqXRlY3Rpb25cclxuICAgIGlmIChfcG9pbnRlclR5cGUgPT0gJ3Vua25vd24nKSB7XHJcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyRGV0ZWN0ZWQnLCBwb2ludGVyRGV0ZWN0ZWQsIGZhbHNlKVxyXG4gICAgfSBlbHNlIGlmIChfcG9pbnRlclR5cGUgIT0gJ3RvdWNoJykge1xyXG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYW1zdF9fbm8tdG91Y2gnKVxyXG4gICAgfVxyXG4gICAgLy9PbiBham91dGUgbCdpbnN0YW5jZSBkYW5zIGxlIHRhYmxlYXUgcmVncm91cGFudCB0b3V0ZXMgbGVzIGF1dHJlcyBpbnN0YW5jZXMgZGUgcGxheWVyc1xyXG4gICAgQW1zdHJhbWdyYW1WaWRlb1BsYXllci5wbGF5ZXJzLnB1c2godGhpcylcclxuICB9XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgIEZJTiBSRVNJWkUgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgRklOIENPTlNUUlVDVE9SICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgR0VUVEVSUy9TRVRURVJTICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgc2V0IHNyYyhzcmMpe1xyXG4gICAgLypcclxuICAgIHNyYyBlc3QgOlxyXG4gICAgICAtIHNvaXQgdW5lIGNoYWluZSByZW52b3lhbnQgdmVycyBsYSBzb3VyY2Ugdmlkw6lvXHJcbiAgICAgIC0gc29pdCB1biBvYmpldCBkZSBsYSBmb3JtZSBcclxuICAgICAgICB7XHJcbiAgICAgICAgICBzcmM6ICdjaGVtaW4gZHUgZmljaGllciB2aWTDqW8nLFxyXG4gICAgICAgICAgZm9ybWF0OiAncmFwcG9ydCBsYXJnZXVyL2hhdXRldXIgZGUgbGEgdmlkw6lvJyxcclxuICAgICAgICAgIHBvc3RlcjogJ2NoZW1pbiBkdSBmaWNoaWVyIHBvc3RlcicsXHJcbiAgICAgICAgICB2b2x1bWU6ICd2b2x1bWUnLFxyXG4gICAgICAgICAgZHVyYXRpb246ICdkdXLDqWUgZGUgbGEgdmlkw6lvIGVuIHNlY29uZGUnLFxyXG4gICAgICAgICAgc2tpcFRpbWU6ICd2YWxldXIgZGUgbCdpbmNyw6ltZW50IHRlbXBvcmVsIGxvcnNxdWUgbCd1dGlsaXNhdGV1ciBhcHB1aWUgc3VyIGxlcyBmbMOoY2hlcyBnYXVjaGUgb3UgZHJvaXRlIGRlIHNvbiBjbGF2aWVyJ1xyXG4gICAgICAgICAgdGh1bWJuYWlsczogJ2NoZW1pbiBkdSBmaWNoaWVyIGRlcyB2aWduZXR0ZXMnLFxyXG4gICAgICAgICAgcHJldmlvdXM6IG9iamV0LFxyXG4gICAgICAgICAgbmV4dDogb2JqZXQsXHJcbiAgICAgICAgICBmdWxsc2NyZWVuOiBvYmpldCxcclxuICAgICAgICAgIGRvd25sb2FkOiBvYmpldCxcclxuICAgICAgICB9XHJcbiAgICAqL1xyXG4gICAgdGhpcy5jb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Ftc3RFdmVudF9fc3JjJyx7J2RldGFpbCc6IHNyY30pKVxyXG4gIH1cclxuICBnZXQgc3JjKCl7XHJcbiAgICByZXR1cm4gdGhpcy5tZWRpYS5nZXRBdHRyaWJ1dGUoJ3NyYycpXHJcbiAgfVxyXG5cclxuICBnZXQgcGF1c2VkKCl7XHJcbiAgICByZXR1cm4gdGhpcy5tZWRpYS5wYXVzZWRcclxuICB9XHJcbiAgZ2V0IGR1cmF0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5tZWRpYS5kdXJhdGlvblxyXG4gIH1cclxuXHJcbiAgc2V0IGN1cnJlbnRUaW1lKHQpIHtcclxuICAgIGlmICh0aGlzLm1lZGlhLmR1cmF0aW9uICYmIHQgPj0gMCAmJiB0IDw9IHRoaXMubWVkaWEuZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHRcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCl7XHJcbiAgICByZXR1cm4gdGhpcy5tZWRpYS5jdXJyZW50VGltZVxyXG4gIH1cclxuXHJcbiAgc2V0IHZvbHVtZSh2b2wpe1xyXG4gICAgdGhpcy5tZWRpYS52b2x1bWUgPSB2b2xcclxuICB9XHJcbiAgZ2V0IHZvbHVtZSgpe1xyXG4gICAgcmV0dXJuIHRoaXMubWVkaWEudm9sdW1lXHJcbiAgfVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgRklOIEdFVFRFUlMvU0VUVEVSUyAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgIE3DiVRIT0RFUyAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgcGF1c2UoKXtcclxuICAgIHRoaXMuY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdhbXN0RXZlbnRfX3BhdXNlJykpXHJcbiAgfVxyXG5cclxuICBwbGF5KCl7XHJcbiAgICB0aGlzLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYW1zdEV2ZW50X19wbGF5JykpXHJcbiAgfVxyXG5cclxuICByZXNldCgpe1xyXG4gICAgdGhpcy5wYXVzZSgpXHJcbiAgICB0aGlzLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYW1zdEV2ZW50X19yZXNldCcpKVxyXG4gIH1cclxuIFxyXG4gIHRvZ2dsZVBsYXlQYXVzZSgpe1xyXG4gICAgaWYgKHRoaXMucGF1c2VkKSB7XHJcbiAgICAgIHRoaXMucGxheSgpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBhdXNlKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhpZGVDb250cm9scyhkZWxheWVkID0gZmFsc2UsIGZvcmNlZCA9IGZhbHNlKXtcclxuICAgIHRoaXMuY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdhbXN0RXZlbnRfX2hpZGVDb250cm9scycseydkZXRhaWwnOntkZWxheWVkOiBkZWxheWVkLCBmb3JjZWQ6IGZvcmNlZH19KSlcclxuICB9XHJcblxyXG4gIHNob3dDb250cm9scygpe1xyXG4gICAgdGhpcy5jb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Ftc3RFdmVudF9fc2hvd0NvbnRyb2xzJykpXHJcbiAgfVxyXG5cclxuICBwcmV2aW91cyhvcHQpe1xyXG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgLy9NaXNlIMOgIGpvdXIgZGVzIHBhcmFtw6h0cmVzXHJcbiAgICAgIHRoaXMucGFyYW1zID0gbWVyZ2VEZWVwKHRoaXMucGFyYW1zLCB7cHJldmlvdXM6b3B0fSlcclxuICAgICAgLy9Hw6luw6lyYXRpb24gZGUgbCfDqXbDqW5lbWVudCBxdWkgdmEgcHJvdm9xdWVyIGxhIG1pc2Ugw6Agam91clxyXG4gICAgICB0aGlzLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYW1zdEV2ZW50X19wcmV2aW91c0J1dHRvbicpKVxyXG4gICAgfVxyXG4gIH1cclxuICBuZXh0KG9wdCl7XHJcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICB0aGlzLnBhcmFtcyA9IG1lcmdlRGVlcCh0aGlzLnBhcmFtcywge25leHQ6b3B0fSlcclxuICAgICAgdGhpcy5jb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Ftc3RFdmVudF9fbmV4dEJ1dHRvbicpKVxyXG4gICAgfVxyXG4gIH1cclxuICBmdWxsc2NyZWVuKG9wdCl7XHJcbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xyXG4gICAgICB0aGlzLnBhcmFtcyA9IG1lcmdlRGVlcCh0aGlzLnBhcmFtcywge2Z1bGxzY3JlZW46b3B0fSlcclxuICAgICAgdGhpcy5jb250YWluZXIuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Ftc3RFdmVudF9fZnVsbHNjcmVlbkJ1dHRvbicpKVxyXG4gICAgfVxyXG4gIH1cclxuICBkb3dubG9hZChvcHQpe1xyXG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgdGhpcy5wYXJhbXMgPSBtZXJnZURlZXAodGhpcy5wYXJhbXMsIHtkb3dubG9hZDpvcHR9KVxyXG4gICAgICB0aGlzLmNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYW1zdEV2ZW50X19kb3dubG9hZEJ1dHRvbicpKVxyXG4gICAgfVxyXG4gIH1cclxuICB2b2x1bWVCdXR0b24ob3B0KXtcclxuICAgIGlmIChpc09iamVjdChvcHQpKSB7XHJcbiAgICAgIHRoaXMucGFyYW1zID0gbWVyZ2VEZWVwKHRoaXMucGFyYW1zLCB7dm9sdW1lQnV0dG9uOm9wdH0pXHJcbiAgICAgIHRoaXMuY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdhbXN0RXZlbnRfX3ZvbHVtZUJ1dHRvbicpKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgRklOIEdFVFRFUlMvU0VUVEVSUyAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgIEZJTiBDTEFTUyAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgIFBST1BSScOJVMOJUyBHTE9CQUxFUyAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbkFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIuY3VycmVudFBsYXllciA9IHVuZGVmaW5lZFxyXG5BbXN0cmFtZ3JhbVZpZGVvUGxheWVyLnBsYXllcnMgPSBbXVxyXG5BbXN0cmFtZ3JhbVZpZGVvUGxheWVyLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGF1dG9wbGF5OiBmYWxzZSxcclxuICBjcm9zc29yaWdpbjogJ2Fub255bW91cycsXHJcbiAgZG93bmxvYWQ6IHtsYWJlbDonVMOpbMOpY2hhcmdlcicsIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LFxyXG4gIGR1cmF0aW9uOiAxMjAsXHJcbiAgZm9ybWF0OiAxNi85LFxyXG4gIGZ1bGxzY3JlZW46IHtsYWJlbDp7ZW50ZXI6J1BsZWluIMOpY3JhbicsIGV4aXQ6J1F1aXR0ZXIgbGUgcGxlaW4gw6ljcmFuJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LFxyXG4gIGxvb3A6IGZhbHNlLFxyXG4gIG5leHQ6IHtsYWJlbDonU3VpdmFudCcsIGRpc2FibGVkOnRydWUsIGhpZGRlbjp0cnVlfSxcclxuICBwbGF5c2lubGluZTogdHJ1ZSxcclxuICBwb3N0ZXI6IHVuZGVmaW5lZCxcclxuICBwcmVsb2FkOiAnbm9uZScsXHJcbiAgcHJldmlvdXM6IHtsYWJlbDonUHLDqWPDqWRlbnQnLCBkaXNhYmxlZDp0cnVlLCBoaWRkZW46dHJ1ZX0sXHJcbiAgc2tpcFRpbWU6ICcxJScsXHJcbiAgdGh1bWJuYWlsczoge3NyYzp1bmRlZmluZWQsIG51bWJlcjoxMDB9LFxyXG4gIHZvbHVtZTogMC44LFxyXG4gIHZvbHVtZUJ1dHRvbjoge2xhYmVsOnttdXRlOidEw6lzYWN0aXZlciBsZSBzb24nLCB1bm11dGU6J0FjdGl2ZXIgbGUgc29uJ30sIGRpc2FibGVkOmZhbHNlLCBoaWRkZW46ZmFsc2V9LFxyXG4gIC8vUGxheWVycyBwcm9wZXJ0aWVzXHJcbiAgdm9sdW1lR3JvdXA6IDAsXHJcbiAgaGlkZUNvbnRyb2xzRGVsYXk6IDUwMDAsXHJcbiAgdmlkZW9Wb2x1bWVPcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcclxuICByYWlsTWluV2lkdGhGb3JOb3JtYWxVSTogNjAwLFxyXG4gIC8vR2xvYmFsIHByb3BlcnRpZXNcclxuICBhcHBMYWJlbDonTGVjdGV1ciBWaWTDqW8nLFxyXG4gIHBhdXNlTGFiZWw6J1BhdXNlJyxcclxuICBwbGF5TGFiZWw6J0xlY3R1cmUnLFxyXG4gIHZvbHVtZUhlbHBMYWJlbDonVXRpbGlzZXogbGVzIGZsw6hjaGVzIEhhdXQvQmFzIGR1IGNsYXZpZXIgcG91ciBhdWdtZW50ZXIgb3UgZGltaW51ZXIgbGUgdm9sdW1lLicsXHJcbiAgdm9sdW1lU2xpZGVyTGFiZWw6J1BvdGVudGlvbcOodHJlIGRlIHZvbHVtZScsXHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICBGSU4gUFJPUFJJw4lUw4lTIEdMT0JBTEVTICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICBCVUlMRFVJICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuZnVuY3Rpb24gYnVpbGRVSShwYXJhbXMpe1xyXG4gIGxldCB2aWRlb1ZvbHVtZUhUTUxTdHJpbmcgPSAnJyxcclxuICAgICAgdm9sdW1lU2xpZGVySFRNTFN0cmluZyA9ICcnXHJcbiAgaWYgKCFJU19NT0JJTEUpIHtcclxuICAgIHZvbHVtZVNsaWRlckhUTUxTdHJpbmcgPSBgXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X192b2x1bWUtc2xpZGVyXCIgYXJpYS1sYWJlbD1cIiR7cGFyYW1zLnZvbHVtZVNsaWRlckxhYmVsfVwiIGFyaWEtdmFsdWVtaW49XCIwXCIgYXJpYS12YWx1ZW1heD1cIjEwMFwiIGFyaWEtdmFsdWVub3c9XCIxMDBcIiBhcmlhLXZhbHVldGV4dD1cIjEwMCVcIiByb2xlPVwic2xpZGVyXCIgYXJpYS1vcmllbnRhdGlvbj1cIiR7cGFyYW1zLnZpZGVvVm9sdW1lT3JpZW50YXRpb259XCIgdGFiaW5kZXg9XCIwXCIgdGl0bGU9XCIke3BhcmFtcy52b2x1bWVIZWxwTGFiZWx9XCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJhbXN0X19vZmZzY3JlZW5cIj4ke3BhcmFtcy52b2x1bWVIZWxwTGFiZWx9PC9zcGFuPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X192b2x1bWUtdG90YWxcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X192b2x1bWUtY3VycmVudFwiIHN0eWxlPVwiaGVpZ2h0OiAxMDAlO1wiPjwvZGl2PmBcclxuICAgIGlmKHBhcmFtcy52aWRlb1ZvbHVtZU9yaWVudGF0aW9uICE9ICdob3Jpem9udGFsJykge1xyXG4gICAgICB2b2x1bWVTbGlkZXJIVE1MU3RyaW5nICs9IGA8ZGl2IGNsYXNzPVwiYW1zdF9fdm9sdW1lLWhhbmRsZVwiIHN0eWxlPVwiYm90dG9tOiAxMDAlOyBtYXJnaW4tYm90dG9tOiAtM3B4O1wiPjwvZGl2PmBcclxuICAgIH1cclxuICAgIHZvbHVtZVNsaWRlckhUTUxTdHJpbmcgKz0gYDwvZGl2PjwvZGl2PmBcclxuICB9XHJcbiAgdmlkZW9Wb2x1bWVIVE1MU3RyaW5nID0gYFxyXG4gICAgPGRpdiBjbGFzcz1cImFtc3RfX2J1dHRvbiBhbXN0X192b2x1bWVidXR0b25cIj5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCI+PC9idXR0b24+YFxyXG4gIGlmIChwYXJhbXMudmlkZW9Wb2x1bWVPcmllbnRhdGlvbiAhPSAnaG9yaXpvbnRhbCcpIHtcclxuICAgIHZpZGVvVm9sdW1lSFRNTFN0cmluZyArPSAodm9sdW1lU2xpZGVySFRNTFN0cmluZyArICc8L2Rpdj4nKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2aWRlb1ZvbHVtZUhUTUxTdHJpbmcgKz0gKCc8L2Rpdj4nICsgdm9sdW1lU2xpZGVySFRNTFN0cmluZylcclxuICB9XHJcblxyXG4gIGxldCBidWlsZFVJU3RyID0gYFxyXG4gICAgPHNwYW4gY2xhc3M9XCJhbXN0X19vZmZzY3JlZW5cIj4ke3BhcmFtcy5hcHBMYWJlbH08L3NwYW4+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fY29udGFpbmVyXCIgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImFwcGxpY2F0aW9uXCIgYXJpYS1sYWJlbD1cIiR7cGFyYW1zLmFwcExhYmVsfVwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fbWVkaWFlbGVtZW50XCI+XHJcbiAgICAgICAgPHZpZGVvPjwvdmlkZW8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImFtc3RfX2xheWVyc1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fbGF5ZXItcG9zdGVyXCI+XHJcbiAgICAgICAgPGNhbnZhcz48L2NhbnZhcz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X19sYXllci1sb2FkaW5nXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImFtc3RfX2xvYWRpbmdcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYW1zdF9fc3ZnXCI+PC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImFtc3RfX2xheWVyLXBsYXlcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fc3ZnXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGFyaWEtbGFiZWw9XCIke3BhcmFtcy5wbGF5TGFiZWx9XCIgYXJpYS1wcmVzc2VkPVwiZmFsc2VcIj48L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X19sYXllci1zZWVraW5nLXRvdWNoXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImFtc3RfX3NlZWtpbmctdG91Y2gtY2FjaGVcIj48L2Rpdj5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX3RpbWUgYW1zdF9fc2Vla2luZy10b3VjaFwiPlxyXG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJhbXN0X19jb250cm9sc1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fYnV0dG9uIGFtc3RfX3ByZXZpb3VzXCI+XHJcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdGl0bGU9XCIke3BhcmFtcy5wcmV2aW91cy5sYWJlbH1cIiBhcmlhLWxhYmVsPVwiJHtwYXJhbXMucHJldmlvdXMubGFiZWx9XCIgdGFiaW5kZXg9XCIwXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fYnV0dG9uIGFtc3RfX3BsYXlwYXVzZVwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHRpdGxlPVwiJHtwYXJhbXMucGxheUxhYmVsfVwiIGFyaWEtbGFiZWw9XCIke3BhcmFtcy5wbGF5TGFiZWx9XCIgdGFiaW5kZXg9XCIwXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fYnV0dG9uIGFtc3RfX25leHRcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT1cIiR7cGFyYW1zLm5leHQubGFiZWx9XCIgYXJpYS1sYWJlbD1cIiR7cGFyYW1zLm5leHQubGFiZWx9XCIgdGFiaW5kZXg9XCIwXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fdGltZVwiIHJvbGU9XCJ0aW1lclwiIGFyaWEtbGl2ZT1cIm9mZlwiPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYW1zdF9fY3VycmVudHRpbWVcIj4wMDowMDwvc3Bhbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJhbXN0X19yYWlsXCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJhbXN0X19zbGlkZXJcIiByb2xlPVwic2xpZGVyXCIgdGFiaW5kZXg9XCIwXCI+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX2J1ZmZlcmluZy1iYXJcIj48L3NwYW4+XHJcbiAgICAgICAgICA8Y2FudmFzIGNsYXNzPVwiYW1zdF9fbG9hZGVkLWJhclwiPjwvY2FudmFzPlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJhbXN0X19jdXJyZW50dGltZS1iYXJcIj48L3NwYW4+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX2hhbmRsZVwiPjxzcGFuPjwvc3Bhbj48L3NwYW4+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX2N1cnNvclwiPjxzcGFuPjwvc3Bhbj48L3NwYW4+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX3NlZWtpbmctd3JhcHBlclwiPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFtc3RfX3RpbWUgYW1zdF9fc2Vla2luZ1wiPlxyXG4gICAgICAgICAgICAgIDxzcGFuPjAwOjAwPC9zcGFuPlxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImFtc3RfX3RpbWUgYW1zdF9fdGltZS1kdXJhdGlvblwiPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYW1zdF9fZHVyYXRpb25cIj4wMDowMDwvc3Bhbj5cclxuICAgICAgPC9kaXY+YFxyXG4gIGJ1aWxkVUlTdHIgKz0gdmlkZW9Wb2x1bWVIVE1MU3RyaW5nXHJcbiAgaWYgKGZ1bGxzY3JlZW5BUEkpIGJ1aWxkVUlTdHIgKz0gIGAgICAgICAgIFxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYW1zdF9fYnV0dG9uIGFtc3RfX2Z1bGxzY3JlZW5cIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT1cIiR7cGFyYW1zLmZ1bGxzY3JlZW4ubGFiZWx9XCIgYXJpYS1sYWJlbD1cIiR7cGFyYW1zLmZ1bGxzY3JlZW4ubGFiZWx9XCIgdGFiaW5kZXg9XCIwXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PmBcclxuICBidWlsZFVJU3RyICs9IGBcclxuICAgICAgPGRpdiBjbGFzcz1cImFtc3RfX2J1dHRvbiBhbXN0X19kb3dubG9hZFwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIHRpdGxlPVwiJHtwYXJhbXMuZG93bmxvYWQubGFiZWx9XCIgYXJpYS1sYWJlbD1cIiR7cGFyYW1zLmRvd25sb2FkLmxhYmVsfVwiIHRhYmluZGV4PVwiMFwiPjwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIGBcclxuICByZXR1cm4gYnVpbGRVSVN0clxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgRklOIEJVSUxEVUkgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICBVVElMSVRBSVJFUyAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5mdW5jdGlvbiBzZWNvbmRzVG9UaW1lQ29kZSh0LCBsb25nKXtcclxuICB0ID0gTWF0aC5yb3VuZCh0KVxyXG4gIGxldCBoID0gTWF0aC5mbG9vcih0IC8gMzYwMCksXHJcbiAgICAgIG0gPSBNYXRoLmZsb29yKCh0IC0gaCAqIDM2MDApIC8gNjApLFxyXG4gICAgICBzID0gTWF0aC5yb3VuZCh0ICUgNjApXHJcbiAgaCA9IChoPjkpP2grJzonOihoPjApPycwJytoKyc6Jzpsb25nPycwMDonOicnXHJcbiAgbSA9IChtPjkpP206JzAnK21cclxuICBzID0gKHM+OSk/czonMCcrc1xyXG5cdHJldHVybiBoICsgbSArICAnOicgKyBzXHJcbn1cclxuXHJcbi8vaHR0cDovL2pzLWJpdHMuYmxvZ3Nwb3QuY29tLzIwMTAvMDcvY2FudmFzLXJvdW5kZWQtY29ybmVyLXJlY3RhbmdsZXMuaHRtbFxyXG5jbGFzcyBBbXN0Um91bmRlZFJlY3R7XHJcbiAgY29uc3RydWN0b3IoY3R4LCBoLCB4LCB3KSB7XHJcbiAgICBsZXQgeSA9IDAsIHIgPSAyO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4Lm1vdmVUbyh4ICsgciwgeSk7XHJcbiAgICBjdHgubGluZVRvKHggKyB3IC0gciwgeSk7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByKTtcclxuICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgdywgeSArIGgsIHggKyB3IC0gciwgeSArIGgpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgciwgeSArIGgpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcik7XHJcbiAgICBjdHgubGluZVRvKHgsIHkgKyByKTtcclxuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByLCB5KTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5maWxsKCk7XHJcbiAgfVxyXG59XHJcblxyXG5sZXQgdGhyb3R0bGUgPSAodHlwZSwgbmFtZSwgb2JqID0gdyk9PntcclxuICBsZXQgcnVubmluZyA9IGZhbHNlLFxyXG4gICAgICBmdW5jID0gKGUpPT57XHJcbiAgICAgICAgaWYgKHJ1bm5pbmcpIHJldHVyblxyXG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XHJcbiAgICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwge2RldGFpbDplfSkpXHJcbiAgICAgICAgICBydW5uaW5nID0gZmFsc2VcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYylcclxufTtcclxudGhyb3R0bGUoJ3Jlc2l6ZScsICdvcHRpbWl6ZWRSZXNpemUnKVxyXG50aHJvdHRsZSgnc2Nyb2xsJywgJ29wdGltaXplZFNjcm9sbCcpXHJcblxyXG4vL2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzE2NDUzOFxyXG5mdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XHJcbiAgcmV0dXJuIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gIGxldCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpXHJcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSlcclxuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dFxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgIEZJTiBVVElMSVRBSVJFUyAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgICAgICAgICAgKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICAgICAgICQgZXQgJCQgICAgICAgICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5sZXQgXyQgPSAoY29udGV4dCk9PntcclxuICBsZXQgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICBsZXQgZWwgPSAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyk/Y29udGV4dC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTpzZWxlY3RvclxyXG4gICAgaWYgKGVsKSB7XHJcbiAgICAgIGVsLmNzcyA9IChuZXdDU1MpPT57XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDU1MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBsZXQgdiA9IHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuZXdDU1MpXHJcbiAgICAgICAgICByZXR1cm4gaXNOYU4ocGFyc2VGbG9hdCh2KSk/djoocGFyc2VGbG9hdCh2KSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgbmV3Q1NTKVxyXG4gICAgICAgICAgcmV0dXJuIGVsXHRcdFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbC5zZXRBdHRyaWJ1dGVzID0gKGF0dHJzKT0+e1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleT0+ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSkpXHJcbiAgICAgIH1cclxuICAgICAgZWwub24gPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIsIG9wdGlvbnMgPSBmYWxzZSl7XHJcbiAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChlPT5lbC5hZGRFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIsIG9wdGlvbnMpKTtcclxuICAgICAgICByZXR1cm4gZWxcdFx0XHJcbiAgICAgIH1cclxuICAgICAgZWwub2ZmID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKXtcclxuICAgICAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGU9PmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgaGFuZGxlcikpO1xyXG4gICAgICAgIHJldHVybiBlbFx0XHRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsXHJcbiAgfVxyXG4gIHJldHVybiAkXHJcbn1cclxuXHJcbmxldCBfJCQgPSAoY29udGV4dCk9PntcclxuICBsZXQgJCQgPSAoc2VsZWN0b3IpPT57XHJcbiAgICBsZXQgZWxzID0gKEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpKT9zZWxlY3RvcjpBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXHJcbiAgICBlbHMuY3NzID0gKG5ld0NTUyk9PntcclxuICAgICAgaWYgKHR5cGVvZiBuZXdDU1MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbGV0IHYgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbHNbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmV3Q1NTKVxyXG4gICAgICAgIHJldHVybiBpc05hTihwYXJzZUZsb2F0KHYpKT92OihwYXJzZUZsb2F0KHYpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVscy5mb3JFYWNoKGVsPT57XHJcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCBuZXdDU1MpXHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gZWxzXHRcdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHMub24gPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIsIG9wdGlvbnMgPSBmYWxzZSl7XHJcbiAgICAgIGVscy5mb3JFYWNoKGVsPT57XHJcbiAgICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChlPT5lbC5hZGRFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIsIG9wdGlvbnMpKTtcclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuIGVsc1x0XHRcclxuICAgIH1cclxuICAgIGVscy5vZmYgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpe1xyXG4gICAgICBlbHMuZm9yRWFjaChlbD0+e1xyXG4gICAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZT0+ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBoYW5kbGVyKSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBlbHNcdFx0XHJcbiAgICB9XHJcbiAgICBsZXQgciA9IChlbHMubGVuZ3RoKT9lbHM6bnVsbFxyXG4gICAgcmV0dXJuIHJcclxuICB9XHJcbiAgcmV0dXJuICQkXHJcbn1cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAqICAgICAgICAgICAgICBUSElTIElTIFRIRSBFTkQuLi4gICAgICAgICAgICAgICpcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/amstramgramVideoPlayer.js\n");

/***/ }),

/***/ "./src/css/main.scss":
/*!***************************!*\
  !*** ./src/css/main.scss ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\nmodule.exports = {\"MOBILE_WIDTH\":\"700px\"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3NzL21haW4uc2Nzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9EOlxcTGF1cmVudFxcRG9jdW1lbnRzXFxIdG1sXFxhbXN0cmFtZ3JhbVZpZGVvUGxheWVyXFxzcmNcXGNzc1xcbWFpbi5zY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJNT0JJTEVfV0lEVEhcIjpcIjcwMHB4XCJ9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/css/main.scss\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/main.scss */ \"./src/css/main.scss\");\n/* harmony import */ var _css_main_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_main_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/utils */ \"./src/js/utils.js\");\n/* harmony import */ var _app_js_amstramgramVideoPlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app/js/amstramgramVideoPlayer */ \"./app/js/amstramgramVideoPlayer.js\");\n/* harmony import */ var _app_css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app/css/amstramgramVideoPlayer.scss */ \"./app/css/amstramgramVideoPlayer.scss\");\n/* harmony import */ var _app_css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_app_css_amstramgramVideoPlayer_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nvar // Récupération des constantes déclarées en css\n// Largeur Max du viewport pour basculer le menu en mode hamburger\nMOBILE_WIDTH = parseFloat(_css_main_scss__WEBPACK_IMPORTED_MODULE_0___default.a.MOBILE_WIDTH),\n    w = window,\n    d = document,\n    b = d.body;\nd.addEventListener(\"DOMContentLoaded\", main);\n\nfunction main() {\n  console.log('INIT', Object(_js_utils__WEBPACK_IMPORTED_MODULE_1__[\"$\"])(b), MOBILE_WIDTH);\n  w.addEventListener('resize', resize, false);\n  w.addEventListener('scroll', scroll, false);\n  new _app_js_amstramgramVideoPlayer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](Object(_js_utils__WEBPACK_IMPORTED_MODULE_1__[\"$\"])('video'));\n  resize();\n}\n\nfunction resize() {\n  console.log('resize');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRDovTGF1cmVudC9Eb2N1bWVudHMvSHRtbC9hbXN0cmFtZ3JhbVZpZGVvUGxheWVyL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vY3NzL21haW4uc2NzcydcclxuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi9jc3MvbWFpbi5zY3NzXCJcclxuaW1wb3J0IHskLCAkJH0gZnJvbSAnLi9qcy91dGlscydcclxuaW1wb3J0IEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIgZnJvbSAnLi4vYXBwL2pzL2Ftc3RyYW1ncmFtVmlkZW9QbGF5ZXInXHJcbmltcG9ydCAnLi4vYXBwL2Nzcy9hbXN0cmFtZ3JhbVZpZGVvUGxheWVyLnNjc3MnXHJcblxyXG5jb25zdFxyXG4gIC8vIFLDqWN1cMOpcmF0aW9uIGRlcyBjb25zdGFudGVzIGTDqWNsYXLDqWVzIGVuIGNzc1xyXG4gIC8vIExhcmdldXIgTWF4IGR1IHZpZXdwb3J0IHBvdXIgYmFzY3VsZXIgbGUgbWVudSBlbiBtb2RlIGhhbWJ1cmdlclxyXG4gIE1PQklMRV9XSURUSCA9IHBhcnNlRmxvYXQoc3R5bGVzLk1PQklMRV9XSURUSCksXHJcbiAgdyA9IHdpbmRvdyxcclxuICBkID0gZG9jdW1lbnQsXHJcbiAgYiA9IGQuYm9keVxyXG5cclxuZC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBtYWluKVxyXG5cclxuZnVuY3Rpb24gbWFpbigpe1xyXG4gIGNvbnNvbGUubG9nKCdJTklUJywgJChiKSwgTU9CSUxFX1dJRFRIKVxyXG4gIHcuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSlcclxuICB3LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbCwgZmFsc2UpXHJcbiAgbmV3IEFtc3RyYW1ncmFtVmlkZW9QbGF5ZXIoJCgndmlkZW8nKSlcclxuICByZXNpemUoKVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNpemUoKXtcclxuICBjb25zb2xlLmxvZygncmVzaXplJylcclxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/js/utils.js":
/*!*************************!*\
  !*** ./src/js/utils.js ***!
  \*************************/
/*! exports provided: gePositionStickySupport, next, $, $$ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gePositionStickySupport\", function() { return gePositionStickySupport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"next\", function() { return next; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$\", function() { return $; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$$\", function() { return $$; });\nfunction gePositionStickySupport() {\n  var el = document.createElement('a'),\n      mStyle = el.style;\n  mStyle.cssText = \"position:sticky;position:-webkit-sticky;position:-ms-sticky;\";\n  return mStyle.position.indexOf('sticky') !== -1;\n}\nfunction next(el) {\n  do {\n    el = el.nextSibling;\n  } while (el && el.nodeType !== 1);\n\n  return el;\n}\nfunction $(selector) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var el = typeof selector === 'string' ? context.querySelector(selector) : selector;\n\n  if (el) {\n    el.css = function (newCSS) {\n      if (typeof newCSS === 'string') {\n        var v = window.getComputedStyle(el, null).getPropertyValue(newCSS);\n        return isNaN(parseFloat(v)) ? v : parseFloat(v);\n      } else {\n        Object.assign(ln.style, newCSS);\n        return el;\n      }\n    };\n\n    el.setAttributes = function (attrs) {\n      Object.keys(attrs).forEach(function (key) {\n        return attrs[key] ? el.setAttribute(key, attrs[key]) : el.removeAttribute(key);\n      });\n    };\n\n    el.on = function (events, handler) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      events.split(' ').forEach(function (e) {\n        return el.addEventListener(e, handler, options);\n      });\n      return el;\n    };\n\n    el.off = function (events, handler) {\n      events.split(' ').forEach(function (e) {\n        return el.removeEventListener(e, handler);\n      });\n      return el;\n    };\n  }\n\n  return el;\n}\nfunction $$(selector) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var els = Array.from(context.querySelectorAll(selector));\n\n  els.css = function (newCSS) {\n    if (typeof newCSS === 'string') {\n      var v = window.getComputedStyle(els[0], null).getPropertyValue(newCSS);\n      return isNaN(parseFloat(v)) ? v : parseFloat(v);\n    } else {\n      els.forEach(function (el) {\n        Object.assign(el.style, newCSS);\n      });\n      return els;\n    }\n  };\n\n  els.on = function (events, handler) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    els.forEach(function (el) {\n      events.split(' ').forEach(function (e) {\n        return el.addEventListener(e, handler, options);\n      });\n    });\n    return els;\n  };\n\n  els.off = function (events, handler) {\n    els.forEach(function (el) {\n      events.split(' ').forEach(function (e) {\n        return el.removeEventListener(e, handler);\n      });\n    });\n    return els;\n  };\n\n  var r = els.length ? els : null;\n  return r;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRDovTGF1cmVudC9Eb2N1bWVudHMvSHRtbC9hbXN0cmFtZ3JhbVZpZGVvUGxheWVyL3NyYy9qcy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2VQb3NpdGlvblN0aWNreVN1cHBvcnQoKSB7XHJcbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpLCBtU3R5bGUgPSBlbC5zdHlsZVxyXG4gIG1TdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpzdGlja3k7cG9zaXRpb246LXdlYmtpdC1zdGlja3k7cG9zaXRpb246LW1zLXN0aWNreTtcIlxyXG4gIHJldHVybiBtU3R5bGUucG9zaXRpb24uaW5kZXhPZignc3RpY2t5JykhPT0tMVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmV4dChlbCkge1xyXG4gIGRvIHtcclxuXHRcdGVsID0gZWwubmV4dFNpYmxpbmc7XHJcbiAgfSB3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgIT09IDEpO1xyXG4gIHJldHVybiBlbDsgICAgICAgIFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gJChzZWxlY3RvciwgY29udGV4dCA9IGRvY3VtZW50KSB7XHJcblx0bGV0IGVsID0gKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpP2NvbnRleHQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik6c2VsZWN0b3JcclxuXHRpZiAoZWwpIHtcclxuXHRcdGVsLmNzcyA9IGZ1bmN0aW9uKG5ld0NTUyl7XHJcblx0XHRcdGlmICh0eXBlb2YgbmV3Q1NTID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGxldCB2ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmV3Q1NTKVxyXG5cdFx0XHRcdHJldHVybiBpc05hTihwYXJzZUZsb2F0KHYpKT92OihwYXJzZUZsb2F0KHYpKVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24obG4uc3R5bGUsIG5ld0NTUylcclxuXHRcdFx0XHRyZXR1cm4gZWxcdFx0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsLnNldEF0dHJpYnV0ZXMgPSAoYXR0cnMpPT57XHJcblx0XHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiAoYXR0cnNba2V5XSk/ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk6ZWwucmVtb3ZlQXR0cmlidXRlKGtleSkpXHJcblx0XHR9XHJcblx0XHRlbC5vbiA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlciwgb3B0aW9ucyA9IGZhbHNlKXtcclxuXHRcdFx0ZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChlPT5lbC5hZGRFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIsIG9wdGlvbnMpKTtcclxuXHRcdFx0cmV0dXJuIGVsXHRcdFxyXG5cdFx0fVxyXG5cdFx0ZWwub2ZmID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKXtcclxuXHRcdFx0ZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChlPT5lbC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIpKTtcclxuXHRcdFx0cmV0dXJuIGVsXHRcdFxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZWxcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcclxuXHRsZXQgZWxzID0gQXJyYXkuZnJvbShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxyXG5cdGVscy5jc3MgPSBmdW5jdGlvbihuZXdDU1Mpe1xyXG5cdFx0aWYgKHR5cGVvZiBuZXdDU1MgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGxldCB2ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5ld0NTUylcclxuXHRcdFx0cmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQodikpP3Y6KHBhcnNlRmxvYXQodikpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbHMuZm9yRWFjaChlbCA9PiB7XHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgbmV3Q1NTKVxyXG5cdFx0XHR9KVxyXG5cdFx0XHRyZXR1cm4gZWxzXHRcdFxyXG5cdFx0fVxyXG5cdH1cclxuXHRlbHMub24gPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIsIG9wdGlvbnMgPSBmYWxzZSl7XHJcblx0XHRlbHMuZm9yRWFjaChlbD0+e1xyXG5cdFx0XHRldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGU9PmVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgaGFuZGxlciwgb3B0aW9ucykpO1xyXG5cdFx0fSlcclxuXHRcdHJldHVybiBlbHNcdFx0XHJcblx0fVxyXG5cdGVscy5vZmYgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpe1xyXG5cdFx0ZWxzLmZvckVhY2goZWw9PntcclxuXHRcdFx0ZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChlPT5lbC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIpKTtcclxuXHRcdH0pXHJcblx0XHRyZXR1cm4gZWxzXHJcblx0fVxyXG5cdGxldCByID0gKGVscy5sZW5ndGgpP2VsczpudWxsXHJcblx0cmV0dXJuIHJcclxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/utils.js\n");

/***/ })

/******/ });